<!doctype html><html lang="ko"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>오목 SAFE (강화 AI)</title>
<style>
body{margin:0;display:grid;place-items:center;min-height:100vh;background:#111;color:#e5e7eb;font-family:system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Arial}
.wrap{padding:16px;background:#0f172a;border:1px solid #243042;border-radius:14px;box-shadow:0 10px 28px rgba(0,0,0,.35)}
h1{font-size:18px;margin:0 0 10px}
.row{display:flex;gap:8px;margin-bottom:10px;flex-wrap:wrap}
button,select{border:0;border-radius:10px;background:#2563eb;color:#fff;padding:10px 14px;font-weight:700;cursor:pointer}
button.sec{background:#374151}
.badge{padding:6px 10px;border-radius:999px;background:#0b1220;border:1px solid #334155}
canvas{
  display:block;background:#f7efd9;border:1px solid #111827;border-radius:12px;
  /* 작은 화면에서 자동 축소되도록 */
  width:min(900px,92vw); height:auto;
  /* 모바일 탭/제스처 품질 개선: 300ms 지연/더블탭 확대 제거 */
  touch-action: manipulation;
}
small{color:#93c5fd}

/* 모바일 UI 토글 켬일 때 살짝 더 큼직한 UI */
body.mobile .wrap{ padding:18px; }
body.mobile h1{ font-size:20px; }
body.mobile .badge{ font-weight:700; }
</style>

<div class="wrap">
  <h1>오목 SAFE</h1>
  <div class="row">
    <button id="new">새 게임</button>
    <button id="undo" class="sec">되돌리기</button>
    <select id="mode">
      <option value="pvp">사람 vs 사람</option>
      <option value="ai-ez">사람 vs AI(보통)</option>
      <option value="ai-hard" selected>사람 vs AI(강함)</option>
    </select>
    <button id="mobile" class="sec">모바일 최적화: 끔</button>
    <span class="badge" id="status">흑 선공</span>
  </div>
  <canvas id="cv" width="900" height="900"></canvas>
  <small>팁: “강함”은 2~3수 앞을 보고 ‘열린3/4’ 같은 패턴을 적극 노립니다.</small>
</div>

<script>
/* ===== 기본 상수/상태 ===== */
const N=15, BLACK=1, WHITE=2;
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const statusEl=document.getElementById('status'), modeSel=document.getElementById('mode');
const mobileBtn=document.getElementById('mobile');

/* 모바일 UI 토글 파라미터 */
const mobileUI = {
  on:false,
  MARGIN:40, MARGIN_M:48,
  RATIO:0.42, RATIO_M:0.50,     // 돌 크기
  GRID_W:2,  GRID_W_M:3,        // 선 굵기
  STAR_R:4,  STAR_R_M:6         // 별점 크기
};
function MARGIN(){ return mobileUI.on?mobileUI.MARGIN_M:mobileUI.MARGIN; }
function RATIO(){  return mobileUI.on?mobileUI.RATIO_M :mobileUI.RATIO;  }
function GRID_W(){ return mobileUI.on?mobileUI.GRID_W_M:mobileUI.GRID_W; }
function STAR_R(){ return mobileUI.on?mobileUI.STAR_R_M:mobileUI.STAR_R; }
const STAR=[3,7,11];

let board, turn, over, moves, winLine=null;

function clear(){ ctx.clearRect(0,0,cv.width,cv.height); }
function cellSize(){ return (cv.width - MARGIN()*2)/(N-1); }
function cellCenter(gx,gy){ const s=cellSize(); return {x:MARGIN()+gx*s, y:MARGIN()+gy*s, s}; }
function pxToCell(px,py){ const s=cellSize(); const gx=Math.round((px-MARGIN())/s), gy=Math.round((py-MARGIN())/s); return {gx,gy}; }

/* ===== 보드 그리기 ===== */
function drawBoard(){
  clear();
  const g=ctx.createLinearGradient(0,0,cv.width,cv.height); g.addColorStop(0,'#f7efd9'); g.addColorStop(1,'#f0e2bf');
  ctx.fillStyle=g; ctx.fillRect(0,0,cv.width,cv.height);

  ctx.strokeStyle='#111827'; ctx.lineWidth=GRID_W();
  const s=cellSize();
  for(let i=0;i<N;i++){
    ctx.beginPath(); ctx.moveTo(MARGIN(), MARGIN()+i*s); ctx.lineTo(MARGIN()+(N-1)*s, MARGIN()+i*s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(MARGIN()+i*s, MARGIN()); ctx.lineTo(MARGIN()+i*s, MARGIN()+(N-1)*s); ctx.stroke();
  }
  ctx.fillStyle='#0b1220';
  STAR.forEach(ix=>STAR.forEach(iy=>{ const {x,y}=cellCenter(ix,iy); ctx.beginPath(); ctx.arc(x,y,STAR_R(),0,Math.PI*2); ctx.fill(); }));

  for(let y=0;y<N;y++)for(let x=0;x<N;x++) if(board[y][x]) drawStone(x,y,board[y][x]);
  if(winLine) drawWinLine(winLine);
}
function drawStone(gx,gy,col){
  const {x,y,s}=cellCenter(gx,gy); const r=s*RATIO();
  const gr=ctx.createRadialGradient(x-r*0.3,y-r*0.3,r*0.2,x,y,r);
  if(col===BLACK){ gr.addColorStop(0,'#6b7280'); gr.addColorStop(1,'#111827'); }
  else{ gr.addColorStop(0,'#fff'); gr.addColorStop(1,'#d1d5db'); }
  ctx.fillStyle=gr; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.lineWidth=1.6; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke();
}
function drawWinLine(line){
  ctx.save(); ctx.strokeStyle='#22c55e'; ctx.lineWidth=5; ctx.lineJoin='round'; ctx.lineCap='round';
  for(let i=0;i<line.length-1;i++){ const a=cellCenter(line[i][0],line[i][1]), b=cellCenter(line[i+1][0],line[i+1][1]);
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  ctx.restore();
}

/* ===== 규칙/로직 ===== */
function checkWin(gx,gy,c){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let cnt=1, line=[[gx,gy]], x=gx+dx, y=gy+dy;
    while(x>=0&&x<N&&y>=0&&y<N&&board[y][x]===c){ line.push([x,y]); cnt++; x+=dx; y+=dy; }
    x=gx-dx; y=gy-dy;
    while(x>=0&&x<N&&y>=0&&y<N&&board[y][x]===c){ line.unshift([x,y]); cnt++; x-=dx; y-=dy; }
    if(cnt>=5) return line;
  }
  return null;
}
function reset(){ board=Array.from({length:N},()=>Array(N).fill(0)); turn=BLACK; over=false; moves=[]; winLine=null; statusEl.textContent='흑 선공'; drawBoard(); }
function place(gx,gy,byAI=false){
  if(over||gx<0||gx>=N||gy<0||gy>=N||board[gy][gx]) return;
  board[gy][gx]=turn; moves.push([gx,gy,turn]); drawStone(gx,gy,turn);
  const line=checkWin(gx,gy,turn);
  if(line){ over=true; winLine=line; drawBoard(); statusEl.textContent=(turn===BLACK?'흑':'백')+' 승리!'; return; }
  turn=(turn===BLACK?WHITE:BLACK);
  statusEl.textContent=(turn===BLACK?'흑 차례':'백 차례') + (isAIturn() ? ' (AI)' : '');
  if(isAIturn() && !byAI) setTimeout(aiMove, 60);
}
function undo(){
  if(!moves.length || (over && winLine)){ winLine=null; over=false; }
  if(!moves.length) return;
  const last=moves.pop(); board[last[1]][last[0]]=0; turn=last[2]; drawBoard();
  statusEl.textContent=(turn===BLACK?'흑 차례':'백 차례') + (isAIturn() ? ' (AI)' : '');
}
function isAIturn(){ return (modeSel.value==='ai-ez' || modeSel.value==='ai-hard') && turn===WHITE; }

/* ===== 강화 AI ===== */
const SCORE = {
  FIVE: 1_000_000_000,
  OPEN_FOUR: 8_000_000,
  CLOSED_FOUR: 800_000,
  OPEN_THREE: 80_000,
  CLOSED_THREE: 8_000,
  OPEN_TWO: 800,
  CLOSED_TWO: 120
};
function lineScore(x,y,c){
  let total=0;
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let count=1, openL=0, openR=0;
    let nx=x+dx, ny=y+dy;
    while(nx>=0&&nx<N&&ny>=0&&ny<N&&board[ny][nx]===c){count++; nx+=dx; ny+=dy;}
    if(nx>=0&&nx<N&&ny>=0&&ny<N&&board[ny][nx]===0) openR=1;
    nx=x-dx; ny=y-dy;
    while(nx>=0&&nx<N&&ny>=0&&ny<N&&board[ny][nx]===c){count++; nx-=dx; ny-=dy;}
    if(nx>=0&&nx<N&&ny>=0&&ny<N&&board[ny][nx]===0) openL=1;
    const open = openL + openR;
    if(count>=5) { total += SCORE.FIVE; continue; }
    if(count===4){
      if(open===2) total += SCORE.OPEN_FOUR;
      else if(open===1) total += SCORE.CLOSED_FOUR;
    } else if(count===3){
      if(open===2) total += SCORE.OPEN_THREE;
      else if(open===1) total += SCORE.CLOSED_THREE;
    } else if(count===2){
      if(open===2) total += SCORE.OPEN_TWO;
      else if(open===1) total += SCORE.CLOSED_TWO;
    }
  }
  return total;
}
function heuristic(x,y,me){
  const opp = me===WHITE?BLACK:WHITE;
  let s = 0;
  s += lineScore(x,y,me);
  s += Math.floor(lineScore(x,y,opp)*0.9);
  const mid=7; s += (20 - (Math.abs(x-mid)+Math.abs(y-mid))) * 20;
  let near=0;
  for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){
    const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=N||ny>=N) continue;
    if(board[ny][nx]) near++;
  }
  s += near*50;
  return s;
}
function genCandidates(){
  const cand=[]; let any=false;
  for(let y=0;y<N;y++)for(let x=0;x<N;x++) if(board[y][x]) any=true;
  if(!any) return [[7,7,99999999]];
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(board[y][x]) continue;
    let ok=false;
    for(let dy=-2;dy<=2;dy++){ if(ok) break;
      for(let dx=-2;dx<=2;dx++){
        const nx=x+dx, ny=y+dy;
        if(nx>=0&&nx<N&&ny>=0&&ny<N && board[ny][nx]){ ok=true; break; }
      }
    }
    if(!ok) continue;
    cand.push([x,y,0]);
  }
  return cand;
}
function bestOnePly(me){
  const cand = genCandidates();
  let best=null, bestScore=-1e100;
  for(const c of cand){
    const [x,y] = c;
    c[2] = heuristic(x,y,me);
    if(c[2] > bestScore){ best = c; bestScore = c[2]; }
  }
  return best;
}
function immediate(me){
  const opp = me===WHITE?BLACK:WHITE;
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(board[y][x]) continue;
    board[y][x]=me;
    const win = !!checkWin(x,y,me);
    board[y][x]=0;
    if(win) return [x,y];
  }
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(board[y][x]) continue;
    board[y][x]=opp;
    const win = !!checkWin(x,y,opp);
    board[y][x]=0;
    if(win) return [x,y];
  }
  return null;
}
function alphaBeta(depth, me, alpha, beta){
  const opp = me===WHITE?BLACK:WHITE;
  let cand = genCandidates();
  cand.forEach(c => c[2] = heuristic(c[0], c[1], me));
  cand.sort((a,b)=>b[2]-a[2]);
  const LIMIT = depth>=3 ? 6 : 10;
  cand = cand.slice(0, LIMIT);
  let bestScore = -1e100, bestMove = null;
  for(const [x,y,] of cand){
    board[y][x]=me;
    if(checkWin(x,y,me)){ board[y][x]=0; return {score: SCORE.FIVE, move:[x,y]}; }
    const sc = (depth<=1) ? evaluateStatic(me) : -alphaBeta(depth-1, opp, -beta, -alpha).score;
    board[y][x]=0;
    if(sc > bestScore){ bestScore=sc; bestMove=[x,y]; }
    if(sc > alpha) alpha=sc;
    if(alpha >= beta) break;
  }
  return {score: bestScore, move: bestMove};
}
function evaluateStatic(me){
  const opp = me===WHITE?BLACK:WHITE;
  let my=0, their=0;
  for(let y=0;y<N;y++)for(let x=0;x<N;x++){
    if(board[y][x]) continue;
    my   += heuristic(x,y,me)*0.3;
    their+= heuristic(x,y,opp)*0.3;
  }
  return my - their;
}
function aiMove(){
  const me = WHITE;
  const fast = immediate(me);
  if(fast){ place(fast[0], fast[1], true); return; }
  if(modeSel.value==='ai-ez'){
    const best = bestOnePly(me) || [7,7];
    place(best[0], best[1], true);
  } else {
    const depth = moves.length<10 || moves.length>60 ? 3 : 2;
    const {move} = alphaBeta(depth, me, -1e100, 1e100);
    const m = move || bestOnePly(me) || [7,7];
    place(m[0], m[1], true);
  }
}

/* ===== 입력/이벤트 — 모바일 터치 보정 ===== */
// 화면 좌표 → 캔버스 내부 좌표(반응형 스케일 보정)
function getCanvasXY(clientX, clientY){
  const r = cv.getBoundingClientRect();
  const scaleX = cv.width / r.width;
  const scaleY = cv.height / r.height;
  return { x: (clientX - r.left) * scaleX, y: (clientY - r.top) * scaleY };
}
let lastTouchAt = 0; // 고스트 클릭 무시용 타임스탬프

cv.addEventListener('click', e=>{
  if(performance.now() - lastTouchAt < 450) return; // 터치 직후 click 무시
  const p = getCanvasXY(e.clientX, e.clientY);
  const c = pxToCell(p.x, p.y);
  place(c.gx, c.gy);
});

cv.addEventListener('touchstart', e=>{
  if(e.touches.length>1) return; // 멀티터치 무시
  lastTouchAt = performance.now();
  e.preventDefault(); // 더블탭 확대/스크롤 방지
  const t=e.touches[0];
  const p = getCanvasXY(t.clientX, t.clientY);
  const c = pxToCell(p.x, p.y);
  place(c.gx, c.gy);
},{passive:false});

document.getElementById('new').onclick=reset;
document.getElementById('undo').onclick=undo;
modeSel.onchange=()=>{ statusEl.textContent=(turn===BLACK?'흑 차례':'백 차례') + (isAIturn() ? ' (AI)' : ''); };

/* === 모바일 UI 토글 === */
mobileBtn.onclick = ()=>{
  mobileUI.on = !mobileUI.on;
  document.body.classList.toggle('mobile', mobileUI.on);
  mobileBtn.textContent = `모바일 최적화: ${mobileUI.on ? '켬' : '끔'}`;
  drawBoard();
  reportSizeSoon();
};

reset();
</script>
<script>
/* ===== 부모 창에 사이즈 보고(티스토리 iframe용) ===== */
(function(){
  function report(){
    const h = Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight
    );
    window.parent?.postMessage({ type:'OMOK_SIZE', w:900, h }, '*');
  }
  function reportSizeSoon(){ setTimeout(report, 0); setTimeout(report, 120); }
  window.addEventListener('load', report);
  window.addEventListener('resize', reportSizeSoon);
  setTimeout(report, 100);
  window.reportSizeSoon = reportSizeSoon;
})();
</script>
</html>
