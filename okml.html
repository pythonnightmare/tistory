<!doctype html><html lang="ko"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>오목 (15x15)</title>
<style>
:root{--bg:#0b1220;--card:#111827;--line:#1f2937;--ink:#e5e7eb;--accent:#22c55e}
*{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto}
.wrap{max-width:980px;margin:20px auto;padding:16px}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 28px rgba(0,0,0,.35)}
.head{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
h1{font-size:18px;margin:0}
.controls{display:flex;gap:10px;flex-wrap:wrap}
button,select{border:0;border-radius:10px;background:#2563eb;color:#fff;padding:10px 14px;font-weight:700;cursor:pointer}
button.sec{background:#374151}
.badge{padding:6px 10px;border-radius:999px;background:#0f172a;border:1px solid #334155;font-variant-numeric:tabular-nums}
.notice{color:#93c5fd;font-size:12px;margin-top:8px}
.boardWrap{position:relative}
canvas{width:100%;height:auto;display:block;background:#0f172a;border:1px solid #243042;border-radius:12px}
.winline{position:absolute;inset:0;pointer-events:none}
</style>

<div class="wrap">
  <div class="card">
    <div class="head">
      <h1>오목(15×15)</h1>
      <div class="controls">
        <button id="new">새 게임</button>
        <button id="undo" class="sec">되돌리기</button>
        <select id="mode">
          <option value="pvp">사람 vs 사람</option>
          <option value="ai">사람 vs AI(기본)</option>
        </select>
        <span class="badge" id="status">흑 선공</span>
      </div>
    </div>

    <div class="boardWrap">
      <canvas id="cv" width="900" height="900"></canvas>
      <canvas id="hl" class="winline" width="900" height="900"></canvas>
    </div>
    <div class="notice">팁: 돌을 잘못 놓았으면 <b>되돌리기</b>. 승리하면 승리선이 강조됩니다. 모바일 터치 지원.</div>
  </div>
</div>

<script>
/* ===== 기본 설정 ===== */
const N=15;               // 보드 크기
const MARGIN=28;          // 바둑판 테두리 여백(px, 논리좌표)
const STAR=[3,7,11];      // 화점 위치(0-index 기준)
const STONE_RATIO=0.42;   // 칸 대비 돌 반지름 비율
const BLACK=1, WHITE=2;

const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const hl=document.getElementById('hl'), hctx=hl.getContext('2d');
const statusEl=document.getElementById('status');
const newBtn=document.getElementById('new');
const undoBtn=document.getElementById('undo');
const modeSel=document.getElementById('mode');

let board, turn, over, moves, winLine=null;

/* ===== 유틸 ===== */
function dprResize(canvas){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.round(rect.width * dpr);
  canvas.height= Math.round(rect.width * dpr); // 정사각
  return dpr;
}
function clear(ctx){ ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); }

/* 좌표 변환 (화면px -> 칸 index) */
function pxToCell(x,y){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const W=cv.width, H=cv.height;
  const size = (Math.min(W,H) - MARGIN*2*dpr) / (N-1);
  const gx = Math.round((x - MARGIN*dpr)/size);
  const gy = Math.round((y - MARGIN*dpr)/size);
  return {gx, gy};
}
/* 셀 중심 px */
function cellCenter(gx,gy){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const W=cv.width, H=cv.height;
  const size = (Math.min(W,H) - MARGIN*2*dpr) / (N-1);
  const cx = MARGIN*dpr + gx*size;
  const cy = MARGIN*dpr + gy*size;
  return {cx, cy, size};
}

/* ===== 보드 그리기 ===== */
function drawBoard(){
  const dpr = dprResize(cv);
  dprResize(hl);
  clear(ctx); clear(hctx);

  ctx.save();
  ctx.lineWidth = 1*dpr;
  ctx.strokeStyle = '#334155';
  ctx.fillStyle = '#0f172a';
  ctx.fillRect(0,0,cv.width,cv.height);

  const W=cv.width, H=cv.height;
  const size = (Math.min(W,H) - MARGIN*2*dpr) / (N-1);

  // 격자
  for(let i=0;i<N;i++){
    const x = MARGIN*dpr + i*size;
    ctx.beginPath(); ctx.moveTo(MARGIN*dpr, MARGIN*dpr + i*size);
    ctx.lineTo(MARGIN*dpr + (N-1)*size, MARGIN*dpr + i*size); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, MARGIN*dpr);
    ctx.lineTo(x, MARGIN*dpr + (N-1)*size); ctx.stroke();
  }
  // 화점
  ctx.fillStyle='#94a3b8';
  const starR = 3*dpr;
  STAR.forEach(ix=>{
    STAR.forEach(iy=>{
      const {cx,cy}=cellCenter(ix,iy);
      ctx.beginPath(); ctx.arc(cx,cy,starR,0,Math.PI*2); ctx.fill();
    });
  });
  ctx.restore();

  // 돌 다시 그림
  for(let y=0;y<N;y++){
    for(let x=0;x<N;x++){
      if(board[y][x]) drawStone(x,y,board[y][x]);
    }
  }
  if(winLine) drawWinLine(winLine);
}

function drawStone(gx,gy,color){
  const {cx,cy,size} = cellCenter(gx,gy);
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const r = size * STONE_RATIO;
  ctx.save();
  const gradient = ctx.createRadialGradient(cx - r*0.3, cy - r*0.3, r*0.2, cx, cy, r);
  if(color===BLACK){
    gradient.addColorStop(0,'#4b5563'); gradient.addColorStop(1,'#0b0f16');
  }else{
    gradient.addColorStop(0,'#ffffff'); gradient.addColorStop(1,'#cbd5e1');
  }
  ctx.fillStyle = gradient;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();

  ctx.lineWidth = 1.2*dpr; ctx.strokeStyle='rgba(0,0,0,.25)';
  ctx.stroke();
  ctx.restore();
}

/* ===== 승리 판정 ===== */
function checkWin(gx,gy,color){
  // 4방향: (1,0), (0,1), (1,1), (1,-1)
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let count=1, line=[[gx,gy]];

    // 한쪽
    let x=gx+dx, y=gy+dy;
    while(x>=0&&x<N&&y>=0&&y<N&&board[y][x]===color){ line.push([x,y]); count++; x+=dx; y+=dy; }
    // 반대쪽
    x=gx-dx; y=gy-dy;
    while(x>=0&&x<N&&y>=0&&y<N&&board[y][x]===color){ line.unshift([x,y]); count++; x-=dx; y-=dy; }

    if(count>=5) return line; // 5목 이상 승리
  }
  return null;
}

function drawWinLine(line){
  clear(hctx);
  hctx.save();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  hctx.strokeStyle = '#22c55e';
  hctx.lineWidth = 4*dpr;
  hctx.lineJoin = 'round'; hctx.lineCap='round';
  for(let i=0;i<line.length-1;i++){
    const a=cellCenter(line[i][0],line[i][1]);
    const b=cellCenter(line[i+1][0],line[i+1][1]);
    hctx.beginPath(); hctx.moveTo(a.cx,a.cy); hctx.lineTo(b.cx,b.cy); hctx.stroke();
  }
  hctx.restore();
}

/* ===== 게임 로직 ===== */
function reset(){
  board = Array.from({length:N},()=>Array(N).fill(0));
  turn = BLACK; over=false; moves=[]; winLine=null;
  statusEl.textContent='흑 선공';
  drawBoard();
}

function place(gx,gy,byAI=false){
  if(over) return;
  if(gx<0||gx>=N||gy<0||gy>=N) return;
  if(board[gy][gx]) return;

  board[gy][gx]=turn;
  moves.push([gx,gy,turn]);

  drawStone(gx,gy,turn);
  const line = checkWin(gx,gy,turn);
  if(line){
    over=true; winLine=line; drawWinLine(line);
    statusEl.textContent = (turn===BLACK?'흑':'백') + ' 승리!';
    return;
  }
  // 턴 전환
  turn = (turn===BLACK?WHITE:BLACK);
  statusEl.textContent = (turn===BLACK?'흑 차례':'백 차례') + (modeSel.value==='ai'&&turn===WHITE? ' (AI)': '');
  // AI 차례면 두기
  if(modeSel.value==='ai' && !over && turn===WHITE && !byAI){
    setTimeout(aiMove, 120);
  }
}

function undo(){
  if(!moves.length || over && winLine){ // 승리선 있었으면 지우고 계속 undo 가능
    winLine=null; over=false; clear(hctx); 
  }
  if(!moves.length) return;
  const last = moves.pop();
  board[last[1]][last[0]]=0;
  turn = last[2]; // 마지막 착수자의 턴으로 되돌림
  drawBoard();
  statusEl.textContent = (turn===BLACK?'흑 차례':'백 차례') + (modeSel.value==='ai'&&turn===WHITE? ' (AI)': '');
}

/* ===== 간단 AI =====
   1) 즉시 승리 수 있으면 둠
   2) 상대의 즉시 승리 수 차단
   3) 주변(거리<=2) 가중 무작위
*/
function aiMove(){
  if(over) return;
  const me=WHITE, opp=BLACK;

  function tryWin(col){
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(board[y][x]) continue;
        board[y][x]=col;
        const ok = !!checkWin(x,y,col);
        board[y][x]=0;
        if(ok) return [x,y];
      }
    }
    return null;
  }
  let mv = tryWin(me) || tryWin(opp);
  if(!mv){
    // 근처 후보 수집
    const cand=[];
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(board[y][x]) continue;
        // 인접(2칸 이내)에 돌이 있으면 가중치 부여
        let near=0;
        for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){
          const ny=y+dy,nx=x+dx;
          if(nx>=0&&nx<N&&ny>=0&&ny<N && board[ny][nx]) near++;
        }
        if(near>0) cand.push({x,y,w:near});
      }
    }
    if(cand.length){
      const sum=cand.reduce((a,c)=>a+c.w,0);
      let r=Math.random()*sum;
      for(const c of cand){ r-=c.w; if(r<=0){ mv=[c.x,c.y]; break; } }
      if(!mv){ const c=cand[Math.floor(Math.random()*cand.length)]; mv=[c.x,c.y]; }
    }else{
      // 보드 비었을 때 중앙
      mv=[7,7];
    }
  }
  if(mv) place(mv[0],mv[1],true);
}

/* ===== 이벤트 ===== */
function pointerPos(ev){
  const rect = cv.getBoundingClientRect();
  const clientX = (ev.touches? ev.touches[0].clientX : ev.clientX);
  const clientY = (ev.touches? ev.touches[0].clientY : ev.clientY);
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  return { x:(clientX-rect.left)*dpr, y:(clientY-rect.top)*dpr };
}
function onTap(ev){
  ev.preventDefault?.();
  if(over) return;
  const p = pointerPos(ev);
  const c = pxToCell(p.x,p.y);
  place(c.gx,c.gy);
}
cv.addEventListener('click', onTap);
cv.addEventListener('touchstart', onTap, {passive:false});
window.addEventListener('resize', drawBoard);

newBtn.onclick=reset;
undoBtn.onclick=undo;
modeSel.onchange=()=>{
  // 사람↔AI 바꿔도 현재 보드는 유지, 상태표시만 반영
  statusEl.textContent = (turn===BLACK?'흑 차례':'백 차례') + (modeSel.value==='ai'&&turn===WHITE? ' (AI)': '');
};

/* 시작 */
reset();
</script>
</html>
