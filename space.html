<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>StarGrow — 우주인 키우기 게임</title>
  <style>
    :root{ --bg:#050712; --ink:#e6edf3; --muted:#9aa4b2; --panel:#0e1220; --primary:#22c55e; --warn:#f59e0b; --danger:#ef4444; --cool:#38bdf8; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:15px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; overflow:hidden; }
    .wrap{ display:flex; align-items:center; justify-content:center; min-height:100%; padding:0; box-sizing:border-box; }
    .game{ width:100%; height:100%; position:relative; }
    .bar{ display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; padding:8px; background:rgba(0,0,0,.35); color:var(--muted); position:absolute; top:0; left:0; right:0; z-index:10; backdrop-filter: blur(4px); }
    .left,.right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .tag{ background:var(--panel); color:var(--ink); border:1px solid #182035; padding:4px 8px; border-radius:10px; }
    .btn{ background:var(--panel); border:1px solid #233047; color:var(--ink); padding:4px 8px; border-radius:10px; cursor:pointer; }
    .btn:hover{ border-color:#2d3c5a; }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }
    canvas{ width:100%; height:100%; display:block; background:#000; touch-action:none; -webkit-user-select:none; user-select:none; transform:translateZ(0); }
    .fab{ position:absolute; z-index:999; min-width:90px; min-height:90px; padding:20px; border-radius:999px; border:1px solid rgba(51,65,85,.6); color:#e6edf3; background:rgba(15,23,42,.65); backdrop-filter:saturate(120%) blur(6px); box-shadow:0 6px 18px rgba(0,0,0,.35); display:none; font-size:20px; }
    .fab:active{ transform:scale(.96); }
    #btnDash{ right:12px; bottom:12px; }
    #btnShoot{ right:118px; bottom:12px; }
    #btnLaser{ left:12px; bottom:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <div class="bar">
        <div class="left">
          <span class="tag">StarGrow</span>
          <span>레벨 <strong id="lv">1</strong></span>
          <span>HP <strong id="hp">100</strong></span>
          <span>스테이지 <strong id="stage">1</strong>/30</span>
          <span>무기 <strong id="weapon">Lv.1</strong></span>
        </div>
        <div class="right">
          <button class="btn" id="btnMobile">모바일 최적화: 끔</button>
          <button class="btn" id="btnPause">일시정지</button>
          <button class="btn" id="btnReset">리셋</button>
        </div>
      </div>
      <canvas id="cv" width="1280" height="800"></canvas>
      <button id="btnDash" class="fab">대시</button>
      <button id="btnShoot" class="fab">공격</button>
      <button id="btnLaser" class="fab">레이저</button>
    </div>
  </div>

  <script>
  (function(){
    'use strict';
    // ===== Canvas & DPR-safe resize =====
    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');
    let W=0, H=0, DPR=1;
    function resize(){
      DPR = Math.min(2, window.devicePixelRatio||1);
      W = window.innerWidth; H = window.innerHeight;
      cv.width = Math.floor(W*DPR); cv.height = Math.floor(H*DPR);
      ctx.setTransform(1,0,0,1,0,0); // reset
      ctx.scale(DPR, DPR);            // draw in CSS px
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // ===== UI refs =====
    const ui = {
      lv: document.getElementById('lv'), hp: document.getElementById('hp'),
      stage: document.getElementById('stage'), weapon: document.getElementById('weapon'),
      btnMobile: document.getElementById('btnMobile'), btnPause: document.getElementById('btnPause'), btnReset: document.getElementById('btnReset'),
      btnDash: document.getElementById('btnDash'), btnShoot: document.getElementById('btnShoot'), btnLaser: document.getElementById('btnLaser')
    };

    // ===== State =====
    const state = {
      mobile:false, paused:false, last:0,
      lv:1, xp:0, xpNext:20,
      player:{ x:W*0.5, y:H*0.78, r:22, hp:100, speed:360, vx:0, vy:0,
        dash:{t:0, dur:0.25, cd:1.8, ready:true, active:false},
        weapon:{lvl:1, fireRate:8.5, bulletSpd:980, dmg:5},
        laser:{active:false, t:0, dur:0.45, cd:5, ready:true, dirX:0, dirY:-1}
      },
      bullets:[], enemies:[], ufo:[], beams:[], orbs:[], stage:1, maxStage:30, stageClock:0,
      target:{x:W*0.5, y:H*0.78}, dragging:false,
      stars:[], theme:0
    };

    // ===== Utilities =====
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const rand=(a,b)=>a+Math.random()*(b-a);
    const hypot=(x,y)=>Math.sqrt(x*x+y*y);

    // ===== Difficulty & Stage Balancing =====
    function stageBalancing(stage){
      if(stage<6)  return { enemySpawnProb:0.012, ufoSpawnProb:0.001, enemyHpBase:26, enemySpeedMul:0.75, maxEnemies:6,  maxUfo:1 };
      if(stage<16) return { enemySpawnProb:0.018, ufoSpawnProb:0.003, enemyHpBase:36, enemySpeedMul:1.00, maxEnemies:8,  maxUfo:2 };
      if(stage<26) return { enemySpawnProb:0.022, ufoSpawnProb:0.0045,enemyHpBase:46, enemySpeedMul:1.10, maxEnemies:10, maxUfo:3 };
      return { enemySpawnProb:0.026, ufoSpawnProb:0.006, enemyHpBase:56, enemySpeedMul:1.20, maxEnemies:12, maxUfo:3 };
    }

    // ★ New: per-stage, per-kind HP and spawn pool
    function enemyKindPool(stage){
      if(stage<6)  return ['jelly','beetle'];
      if(stage<11) return ['jelly','beetle','eye'];
      if(stage<16) return ['jelly','beetle','eye','crystal'];
      return ['jelly','beetle','eye','crystal','wisp'];
    }
    function enemyHPFor(kind, stage, radius){
      const stageMul = 1 + (Math.max(1,stage)-1)*0.08; // stage별 8% 성장
      const kindBase = { jelly:0.9, beetle:1.1, eye:1.0, crystal:1.25, wisp:0.75 }[kind]||1.0;
      const sizeMul = 1 + (radius-14)*0.04; // 크기 보정
      const P = stageBalancing(stage);
      return Math.round(P.enemyHpBase * stageMul * kindBase * sizeMul);
    }

    // ===== Background (themes) =====
    function buildStars(){
      state.stars=[
        Array.from({length:70},()=>({x:Math.random()*W,y:Math.random()*H,r:1,s:10})),
        Array.from({length:110},()=>({x:Math.random()*W,y:Math.random()*H,r:1.6,s:24})),
        Array.from({length:160},()=>({x:Math.random()*W,y:Math.random()*H,r:2.2,s:40}))
      ];
    }
    buildStars();

    // ===== Planet painter (modular) =====
    function drawPlanet(x,y,r,opts={}){
      const {type='rock', hueA='#64748b', hueB='#94a3b8', ring=false, ringTilt=0.3, band=0, crater=0.15, glow='#0ea5e9', atmosphere=0.18} = opts;
      ctx.save();
      ctx.translate(x,y);
      // Atmosphere glow
      if(atmosphere>0){
        const ag = ctx.createRadialGradient(0,0,r*0.4, 0,0,r*(1+atmosphere));
        ag.addColorStop(0,'rgba(255,255,255,0)');
        ag.addColorStop(1, typeof glow==='string'? glow : 'rgba(14,165,233,.2)');
        ctx.fillStyle = ag; ctx.beginPath(); ctx.arc(0,0,r*(1+atmosphere),0,Math.PI*2); ctx.fill();
      }
      // Body base
      const g = ctx.createLinearGradient(-r,-r,r,r);
      g.addColorStop(0,hueA); g.addColorStop(1,hueB);
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      // Details by type
      if(type==='gas'){ // banded gas giant
        const bands = Math.max(3, band||6);
        for(let i=0;i<bands;i++){
          const t=i/(bands-1); const ly = (t-0.5)*r*1.6;
          ctx.strokeStyle = `rgba(255,255,255,${0.16+0.18*Math.sin(i*1.2)})`;
          ctx.lineWidth = Math.max(2, r*0.08*(1-Math.abs(t-0.5)*1.2));
          ctx.beginPath(); ctx.ellipse(0,0,r*0.98, r*0.55, 0, 0, Math.PI*2); ctx.stroke();
          ctx.translate(0, r*0.03);
        }
      } else if(type==='ice'){
        // subtle ice cracks
        ctx.strokeStyle='rgba(255,255,255,.28)';
        for(let i=0;i<8;i++){
          ctx.beginPath(); ctx.moveTo(-r*0.8+Math.random()*r*0.2, -r*0.3+Math.random()*r*0.2);
          ctx.bezierCurveTo(-r*0.2, -r*0.1, r*0.2, r*0.1, r*0.8, r*0.3);
          ctx.stroke();
        }
      } else { // rocky with craters
        const n = Math.floor(6 + r*crater*0.5);
        ctx.fillStyle='rgba(0,0,0,.15)';
        for(let i=0;i<n;i++){
          const a=Math.random()*Math.PI*2; const rr = r*(0.1+Math.random()*0.18); const rx=Math.cos(a)*(r*0.55), ry=Math.sin(a)*(r*0.45);
          ctx.beginPath(); ctx.ellipse(rx, ry, rr*1.1, rr*0.8, a*0.6, 0, Math.PI*2); ctx.fill();
          ctx.globalAlpha=.6; ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.beginPath(); ctx.arc(rx-rr*0.2, ry-rr*0.2, rr*0.9, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
        }
      }
      // Ring (after body for proper overlap)
      if(ring){
        ctx.save();
        ctx.rotate(ringTilt);
        const R1=r*1.15, R2=r*1.95;
        const rg=ctx.createRadialGradient(0,0,R1,0,0,R2);
        rg.addColorStop(0,'rgba(255,255,255,0)');
        rg.addColorStop(0.6,'rgba(148,163,184,.45)');
        rg.addColorStop(1,'rgba(148,163,184,0)');
        ctx.strokeStyle=rg; ctx.lineWidth=R2-R1; ctx.beginPath(); ctx.ellipse(0,0,(R1+R2)/2,(R1+R2)/2*0.35,0,0,Math.PI*2); ctx.stroke();
        ctx.restore();
      }
      // Specular highlight
      ctx.globalAlpha=.45; ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(-r*0.35,-r*0.45,r*0.28,r*0.12,-0.5,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      ctx.restore();
    }

    function drawBackground(t){
      const theme = state.theme; // 0..5
      const sky = [
        ['#0a0f1e','#050712'],
        ['#0b1028','#091022'],
        ['#0e0b1a','#140a22'],
        ['#060a0f','#0b1324'],
        ['#080a10','#0a0f19'],
        ['#020308','#07040e']
      ][theme]||['#0a0f1e','#050712'];
      const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,sky[0]); g.addColorStop(1,sky[1]); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

      // parallax stars
      for(let i=0;i<state.stars.length;i++){
        const layer=state.stars[i]; ctx.globalAlpha=0.4+i*0.25; for(let s of layer){ const y=(s.y + (t*s.s)%H); ctx.beginPath(); ctx.arc(s.x, y%H, s.r, 0, Math.PI*2); ctx.fillStyle='#e2e8f0'; ctx.fill(); }
      }
      ctx.globalAlpha=1;

      // Set pieces per theme
      ctx.save();
      if(theme===0){
        // 네온 블루 가스자이언트 + 작은 위성
        drawPlanet(W*0.78, H*0.28, 86, {type:'gas', hueA:'#22d3ee', hueB:'#6366f1', band:7, atmosphere:0.2, glow:'rgba(56,189,248,.22)'});
        drawPlanet(W*0.56, H*0.18, 26, {type:'ice', hueA:'#cbd5e1', hueB:'#94a3b8', atmosphere:0.06});
      } else if(theme===1){
        // 고리 행성 + 먼 달
        drawPlanet(W*0.22, H*0.24, 64, {type:'rock', hueA:'#94a3b8', hueB:'#64748b', ring:true, ringTilt:-0.5, atmosphere:0.12, glow:'rgba(148,163,184,.18)'});
        drawPlanet(W*0.86, H*0.18, 30, {type:'rock', hueA:'#475569', hueB:'#94a3b8', crater:0.22, atmosphere:0.08});
      } else if(theme===2){
        // 보라 성운 뒤의 행성 실루엣 + 근접 위성
        const nb=ctx.createRadialGradient(W*0.3,H*0.4,20, W*0.3,H*0.4,260);
        nb.addColorStop(0,'rgba(168,85,247,.35)'); nb.addColorStop(1,'rgba(59,130,246,0)');
        ctx.fillStyle=nb; ctx.beginPath(); ctx.arc(W*0.3,H*0.4,260,0,Math.PI*2); ctx.fill();
        drawPlanet(W*0.68, H*0.30, 72, {type:'gas', hueA:'#8b5cf6', hueB:'#6d28d9', band:8, atmosphere:0.18, glow:'rgba(168,85,247,.22)'});
        drawPlanet(W*0.76, H*0.52, 24, {type:'rock', hueA:'#a78bfa', hueB:'#7c3aed', crater:0.2});
      } else if(theme===3){
        // 회색 행성 + 얇은 링 + 먼 고리
        drawPlanet(W*0.72, H*0.28, 80, {type:'rock', hueA:'#9ca3af', hueB:'#4b5563', ring:true, ringTilt:-0.38, atmosphere:0.1, glow:'rgba(125,211,252,.25)'});
        ctx.strokeStyle='rgba(125,211,252,.35)'; ctx.lineWidth=5; ctx.beginPath(); ctx.ellipse(W*0.72,H*0.28, 160, 48, -0.4, 0, Math.PI*2); ctx.stroke();
      } else if(theme===4){
        // 별똥별 밴드 + 작고 선명한 달
        ctx.strokeStyle='rgba(255,255,255,.55)'; ctx.lineWidth=2; for(let i=0;i<18;i++){ const x=rand(0,W), y=rand(0,H*0.5); ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+rand(30,90), y+rand(2,8)); ctx.stroke(); }
        drawPlanet(W*0.12, H*0.2, 36, {type:'ice', hueA:'#e2e8f0', hueB:'#94a3b8', atmosphere:0.08});
      } else if(theme===5){
        // 블랙홀 + 근접 가스행성
        const cx=W*0.5, cy=H*0.38, rr=94; const rg=ctx.createRadialGradient(cx,cy,10,cx,cy,rr);
        rg.addColorStop(0,'#000'); rg.addColorStop(1,'#1f2937'); ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(cx,cy,rr,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(99,102,241,.6)'; ctx.lineWidth=5; ctx.beginPath(); ctx.ellipse(cx,cy,rr*1.6, rr*0.5, 0.3, 0, Math.PI*2); ctx.stroke();
        drawPlanet(W*0.78, H*0.22, 70, {type:'gas', hueA:'#22d3ee', hueB:'#0ea5e9', band:7, atmosphere:0.16, glow:'rgba(59,130,246,.25)'});
      }
      ctx.restore();
    }

    // ===== Drawing: Astronaut =====
    function drawAstronaut(p){
      const r=p.r; ctx.save(); ctx.translate(p.x,p.y);
      const body=ctx.createRadialGradient(-r*0.25,-r*0.25,r*0.2,0,0,r*1.2); body.addColorStop(0,'#e5e7eb'); body.addColorStop(1,'#1f2937');
      ctx.fillStyle=body; ctx.beginPath(); ctx.ellipse(0,0,r*0.9,r*1.15,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.45)'; ctx.lineWidth=1.5; ctx.stroke();
      ctx.fillStyle='#0b1220'; ctx.beginPath(); ctx.arc(0,-r*0.23,r*0.64,0,Math.PI*2); ctx.fill();
      const visor=ctx.createLinearGradient(-r*0.3,-r*0.36, r*0.32, r*0.12); visor.addColorStop(0,'#a7f3d0'); visor.addColorStop(1,'#06b6d4');
      ctx.globalAlpha=0.92; ctx.fillStyle=visor; ctx.beginPath(); ctx.ellipse(0,-r*0.23, r*0.56, r*0.4, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
      ctx.fillStyle='#334155'; ctx.fillRect(-r*0.72, r*0.05, r*1.44, r*0.5);
      ctx.fillStyle='#94a3b8'; ctx.fillRect(-r*0.95, -r*0.1, r*0.3, r*0.8);
      ctx.fillRect( r*0.65, -r*0.1, r*0.3, r*0.8);
      ctx.fillStyle='#cbd5e1'; ctx.fillRect(-r*0.4, r*0.8, r*0.32, r*0.8);
      ctx.fillRect( r*0.08, r*0.8, r*0.32, r*0.8);
      const thrust=Math.min(1, Math.hypot(p.vx,p.vy)/(p.speed*1.2));
      if(thrust>0.05){ ctx.globalAlpha=0.8*thrust; ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.ellipse(0, r*1.05, r*0.28, r*0.5+thrust*12, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
      ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.ellipse(-r*0.28,-r*0.38,r*0.2,r*0.08,-0.4,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // ===== Drawing: Enemies & Bosses =====
    function drawAlien(a){
      const r=a.r; ctx.save(); ctx.translate(a.x,a.y);
      // 공통: 약한 외곽 글로우
      ctx.shadowBlur = 12; ctx.shadowColor = 'rgba(255,255,255,0.15)';

      if(a.kind==='jelly'){
        // ─ Jelly: 반투명 돔 + 촉수 + 내부 스팽글
        const shell=ctx.createRadialGradient(-r*0.2,-r*0.3,r*0.2, 0,0,r*1.1);
        shell.addColorStop(0,'rgba(186,230,253,.95)');
        shell.addColorStop(1,'rgba(59,130,246,.65)');
        ctx.fillStyle=shell;
        ctx.beginPath(); ctx.ellipse(0,0,r*0.98,r*0.78,0,0,Math.PI*2); ctx.fill();
        // 하이라이트 띠
        ctx.globalAlpha=.35; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(-r*0.2,-r*0.2,r*0.6,r*0.18,-0.5,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
        // 내부 스팽글
        ctx.fillStyle='rgba(255,255,255,.35)'; for(let i=0;i<8;i++){ ctx.beginPath(); ctx.arc(Math.cos(i*0.9)*r*0.4, Math.sin(i*1.1)*r*0.2, r*0.10, 0, Math.PI*2); ctx.fill(); }
        // 촉수
        ctx.strokeStyle='rgba(125,211,252,.8)'; ctx.lineWidth=2; for(let i=0;i<6;i++){ const ang=i*Math.PI/3; ctx.beginPath(); ctx.moveTo(Math.cos(ang)*r*0.6, r*0.35+Math.sin(ang)*r*0.15); ctx.quadraticCurveTo(Math.cos(ang+0.8)*r*0.2, r*0.8, Math.cos(ang+0.4)*r*0.3, r*0.95); ctx.stroke(); }
      }
      else if(a.kind==='beetle'){
        // ─ Beetle: 메탈릭 등갑 + 중앙 능선 + 다리 실루엣
        const shell=ctx.createLinearGradient(0,-r,0,r);
        shell.addColorStop(0,'#10b981'); shell.addColorStop(.5,'#059669'); shell.addColorStop(1,'#064e3b');
        ctx.fillStyle=shell; ctx.beginPath(); ctx.ellipse(0,0,r*1.0,r*0.74,0,0,Math.PI*2); ctx.fill();
        // 스펙큘러 하이라이트
        ctx.globalAlpha=.22; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(-r*0.15,-r*0.35,r*0.55,r*0.18,-0.5,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
        // 등 중앙 능선 + 횡리브
        ctx.strokeStyle='rgba(16,185,129,.9)'; ctx.lineWidth=r*0.12; ctx.beginPath(); ctx.moveTo(0,-r*0.7); ctx.lineTo(0,r*0.7); ctx.stroke();
        ctx.lineWidth=r*0.06; ctx.beginPath(); ctx.moveTo(-r*0.5,-r*0.35); ctx.lineTo(r*0.5,r*0.35); ctx.stroke();
        // 다리 실루엣
        ctx.strokeStyle='rgba(6,95,70,.9)'; ctx.lineWidth=2; for(let i=-1;i<=1;i++){ ctx.beginPath(); ctx.moveTo(-r*0.9, r*0.1*i); ctx.lineTo(-r*1.2, r*0.25+ i*r*0.15); ctx.stroke(); ctx.beginPath(); ctx.moveTo(r*0.9, r*0.1*i); ctx.lineTo(r*1.2, r*0.25+ i*r*0.15); ctx.stroke(); }
      }
      else if(a.kind==='eye'){
        // ─ Eye: 세밀 아이리스 + 반짝 하이라이트 + 외곽 링
        const sclera=ctx.createRadialGradient(0,0,r*0.2, 0,0,r);
        sclera.addColorStop(0,'#f8fafc'); sclera.addColorStop(1,'#cbd5e1'); ctx.fillStyle=sclera;
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
        // 아이리스
        const irisR=r*0.62; ctx.save();
        for(let i=0;i<22;i++){ const ang=i*(Math.PI*2/22); ctx.strokeStyle='rgba(56,189,248,.55)'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(Math.cos(ang)*irisR*0.2, Math.sin(ang)*irisR*0.2); ctx.lineTo(Math.cos(ang)*irisR, Math.sin(ang)*irisR); ctx.stroke(); }
        ctx.restore();
        ctx.strokeStyle='#38bdf8'; ctx.lineWidth=r*0.12; ctx.beginPath(); ctx.arc(0,0,irisR,0,Math.PI*2); ctx.stroke();
        // 동공
        ctx.fillStyle='#0f172a'; ctx.beginPath(); ctx.arc(0,0,r*0.38,0,Math.PI*2); ctx.fill();
        // 하이라이트 점
        ctx.fillStyle='rgba(255,255,255,.9)'; ctx.beginPath(); ctx.arc(-r*0.2,-r*0.18,r*0.10,0,Math.PI*2); ctx.fill();
      }
      else if(a.kind==='crystal'){
        // ─ Crystal: 육면체 보디 + 코어 + 모서리 광택
        const faces=6; ctx.fillStyle='#60a5fa'; ctx.strokeStyle='rgba(255,255,255,.35)';
        ctx.beginPath(); for(let i=0;i<faces;i++){ const ang=(Math.PI*2/faces)*i + 0.2; const x=Math.cos(ang)*r*0.95, y=Math.sin(ang)*r*0.85; i?ctx.lineTo(x,y):ctx.moveTo(x,y);} ctx.closePath(); ctx.fill(); ctx.stroke();
        const core=ctx.createRadialGradient(0,0,2, 0,0,r*0.5); core.addColorStop(0,'rgba(191,219,254,.95)'); core.addColorStop(1,'rgba(191,219,254,0)'); ctx.fillStyle=core; ctx.beginPath(); ctx.arc(0,0,r*0.46,0,Math.PI*2); ctx.fill();
        // 스파클
        ctx.globalAlpha=.7; ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.lineWidth=1; for(let i=0;i<3;i++){ ctx.beginPath(); const a=i*2.1; ctx.moveTo(Math.cos(a)*r*0.2, Math.sin(a)*r*0.2); ctx.lineTo(Math.cos(a)*r*0.9, Math.sin(a)*r*0.9); ctx.stroke(); } ctx.globalAlpha=1;
      }
      else { // wisp: 네온 구체 + 꼬리 테일
        const glow=ctx.createRadialGradient(0,0,2,0,0,r*1.1); glow.addColorStop(0,'rgba(236,72,153,.95)'); glow.addColorStop(1,'rgba(236,72,153,0)');
        ctx.fillStyle=glow; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
        // 꼬리 트레일
        ctx.globalAlpha=.55; for(let t=1;t<=3;t++){ ctx.beginPath(); ctx.arc(-t*4, -t*2, r*0.7*(1-t*0.18), 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha=1;
      }
      ctx.restore();
    }

    function drawUfo(u){
      const r=u.r; ctx.save(); ctx.translate(u.x,u.y);
      // 공통 글로우
      ctx.shadowBlur = 14; ctx.shadowColor = 'rgba(148,163,184,.35)';
      if(u.boss){
        const t=u.btype||'Obelisk';
        if(t==='Obelisk'){
          const g=ctx.createLinearGradient(-r, -r, r, r); g.addColorStop(0,'#64748b'); g.addColorStop(1,'#94a3b8'); ctx.fillStyle=g;
          ctx.beginPath(); ctx.moveTo(-r*0.6, r*0.7); ctx.lineTo(0,-r*0.9); ctx.lineTo(r*0.6, r*0.7); ctx.closePath(); ctx.fill();
          ctx.strokeStyle='#7dd3fc'; ctx.lineWidth=2; ctx.stroke();
          // 코어 라인
          ctx.globalAlpha=.6; ctx.strokeStyle='rgba(125,211,252,.6)'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(0,-r*0.9); ctx.lineTo(0,r*0.7); ctx.stroke(); ctx.globalAlpha=1;
        } else if(t==='Mothership'){
          const hull=ctx.createLinearGradient(-r,0,r,0); hull.addColorStop(0,'#a1a1aa'); hull.addColorStop(1,'#52525b'); ctx.fillStyle=hull;
          ctx.beginPath(); ctx.ellipse(0,0,r*1.35, r*0.65, 0, 0, Math.PI*2); ctx.fill();
          // 라이트 링
          ctx.strokeStyle='rgba(125,211,252,.55)'; ctx.lineWidth=3; ctx.beginPath(); ctx.ellipse(0,0,r*1.1, r*0.35, 0, 0, Math.PI*2); ctx.stroke();
          // 돔
          const dome=ctx.createRadialGradient(0,-r*0.05,r*0.2, 0,0,r*0.75); dome.addColorStop(0,'#e0f2fe'); dome.addColorStop(1,'rgba(255,255,255,0.06)');
          ctx.fillStyle=dome; ctx.beginPath(); ctx.arc(0,-r*0.12,r*0.75,0,Math.PI*2); ctx.fill();
        } else if(t==='Wyrm'){
          ctx.strokeStyle='#7dd3fc'; ctx.lineWidth=3; for(let i=-3;i<=3;i++){ ctx.beginPath(); ctx.ellipse(0, i*6, r*0.95, r*0.3, i*0.2, 0, Math.PI*2); ctx.stroke(); }
        } else if(t==='Harvester'){
          ctx.fillStyle='#3f3f46'; ctx.beginPath(); ctx.rect(-r*0.95,-r*0.5,r*1.9,r); ctx.fill();
          ctx.strokeStyle='#a3e635'; ctx.lineWidth=2; ctx.strokeRect(-r*0.95,-r*0.5,r*1.9,r);
          // 집게암 실루엣
          ctx.strokeStyle='#84cc16'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-r*1.1,0); ctx.lineTo(-r*1.5,-r*0.35); ctx.moveTo(r*1.1,0); ctx.lineTo(r*1.5,-r*0.35); ctx.stroke();
        } else if(t==='Sentinel'){
          ctx.fillStyle='#475569'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='#22d3ee'; ctx.lineWidth=3; ctx.beginPath(); ctx.ellipse(0,0,r*1.6,r*0.5,0,0,Math.PI*2); ctx.stroke();
          // 내부 코어 링
          ctx.strokeStyle='rgba(14,165,233,.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,r*0.55,0,Math.PI*2); ctx.stroke();
        } else { // Singularity
          const rg=ctx.createRadialGradient(0,0,10,0,0,r); rg.addColorStop(0,'#000'); rg.addColorStop(1,'#4338ca'); ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='rgba(168,85,247,.65)'; ctx.lineWidth=4; ctx.beginPath(); ctx.ellipse(0,0,r*1.7,r*0.55,0.4,0,Math.PI*2); ctx.stroke();
        }
      } else {
        // ─ 일반 UFO 리디자인: 얇은 링형 섀시 + 돔 + 포트홀 + 착륙등
        const hull=ctx.createLinearGradient(-r,0,r,0); hull.addColorStop(0,'#a8b1c1'); hull.addColorStop(1,'#6b7280'); ctx.fillStyle=hull;
        ctx.beginPath(); ctx.ellipse(0,0,r*1.05, r*0.42, 0, 0, Math.PI*2); ctx.fill();
        // 라이트 링(회전감 주는 스트로크)
        ctx.strokeStyle='rgba(125,211,252,.55)'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,0,r*0.95, r*0.3, 0.15, 0, Math.PI*2); ctx.stroke();
        // 포트홀
        ctx.fillStyle='rgba(203,213,225,.9)'; for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.arc(i*r*0.32, -r*0.02, r*0.08, 0, Math.PI*2); ctx.fill(); }
        // 돔
        const dome=ctx.createRadialGradient(0,-r*0.08,r*0.2, 0,0,r*0.6); dome.addColorStop(0,'#c7d2fe'); dome.addColorStop(1,'rgba(255,255,255,0.08)');
        ctx.fillStyle=dome; ctx.beginPath(); ctx.arc(0,-r*0.18,r*0.55,0,Math.PI*2); ctx.fill();
        // 착륙등
        ctx.fillStyle='rgba(250,204,21,.7)'; ctx.beginPath(); ctx.arc(-r*0.72,r*0.18,r*0.09,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(r*0.72,r*0.18,r*0.09,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    function drawBeams(){
      for(const bm of state.beams){
        // 길이 기반 그라디언트 코어+글로우
        const dx=bm.x2-bm.x1, dy=bm.y2-bm.y1; const len=Math.hypot(dx,dy)||1; const ux=dx/len, uy=dy/len;
        const off=12; const x1=bm.x1, y1=bm.y1, x2=bm.x2-ux*off, y2=bm.y2-uy*off;
        const g=ctx.createLinearGradient(x1,y1,x2,y2);
        if(bm.hostile){ g.addColorStop(0,'rgba(251,113,133,1)'); g.addColorStop(1,'rgba(239,68,68,0)'); }
        else{ g.addColorStop(0,'rgba(125,211,252,1)'); g.addColorStop(1,'rgba(59,130,246,0)'); }
        ctx.save(); ctx.shadowBlur = bm.hostile?16:20; ctx.shadowColor = bm.hostile?'#f43f5e':'#60a5fa';
        ctx.strokeStyle=g; ctx.lineWidth=bm.hostile?3:5; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        // 코어 점
        ctx.globalAlpha=.9; ctx.fillStyle=bm.hostile?'#fecaca':'#e0f2fe'; ctx.beginPath(); ctx.arc(x1,y1, bm.hostile?2.2:2.8, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    // ===== Spawns =====
    function spawnAlien(){
      const P=stageBalancing(state.stage);
      const pool = enemyKindPool(state.stage);
      const kind = pool[(Math.random()*pool.length)|0];
      const r=rand(14,20);
      const hp = enemyHPFor(kind, state.stage, r);
      const vx=rand(-40,40)*P.enemySpeedMul, vy=rand(-20,20)*P.enemySpeedMul;
      state.enemies.push({kind,x:rand(30,W-30),y:rand(60,H*0.5),r,vx,vy,hp,phase:Math.random()*Math.PI*2});
    }
    function spawnUfo(boss=false){
      const P=stageBalancing(state.stage);
      const side=Math.random()<0.5?-80:W+80; const y=rand(60,H*0.45); const vx= side<0 ? rand(60,110) : -rand(60,110);
      const u={x:side,y,r:boss?46:26,vx,hp:boss?360:90,boss,shoot:0};
      if(boss){ const idx=Math.ceil(state.stage/5); u.btype=['Obelisk','Mothership','Wyrm','Harvester','Sentinel','Singularity'][Math.min(5,Math.max(0,idx-1))]; }
      if(state.ufo.length < P.maxUfo) state.ufo.push(u);
    }

    // ===== Input =====
    const keys={};
    window.addEventListener('keydown',e=>{
      keys[e.code]=true;
      if(e.code==='Space' || e.code==='Spacebar' || e.code==='KeyJ'){ keys.shoot=true; e.preventDefault(); }
    });
    window.addEventListener('keyup',e=>{ keys[e.code]=false; if(e.code==='Space' || e.code==='Spacebar' || e.code==='KeyJ') keys.shoot=false; });

    cv.addEventListener('pointerdown',e=>{ state.dragging=true; setTarget(e); cv.setPointerCapture(e.pointerId); keys.shoot=true; });
    cv.addEventListener('pointerup',()=>{ state.dragging=false; keys.shoot=false; });
    cv.addEventListener('pointermove',e=>{ if(state.dragging) setTarget(e); });
    function setTarget(e){ const r=cv.getBoundingClientRect(); state.target.x=(e.clientX-r.left); state.target.y=(e.clientY-r.top); }

    // Mobile toggles
    ui.btnMobile.onclick=()=>{ state.mobile=!state.mobile; const disp=state.mobile?'block':'none'; ui.btnDash.style.display=disp; ui.btnShoot.style.display=disp; ui.btnLaser.style.display=disp; ui.btnMobile.textContent='모바일 최적화: '+(state.mobile?'켬':'끔'); };
    ui.btnShoot.onpointerdown=()=>{ keys.shoot=true; ui._shootTimer=setInterval(()=>shoot(false), 1000/state.player.weapon.fireRate); };
    ui.btnShoot.onpointerup=ui.btnShoot.onpointerleave=()=>{ clearInterval(ui._shootTimer); keys.shoot=false; };
    ui.btnDash.onclick=()=>dash(); ui.btnLaser.onclick=()=>laser();

    // ===== Actions =====
    let shootClock=999; // 첫 입력 즉시 발사
    function bulletColorForLevel(lv){
      const palette=[
        ['#f59e0b','#fde68a'], // 1-5 amber
        ['#06b6d4','#67e8f9'], // 6-10 cyan
        ['#d946ef','#f0abfc'], // 11-15 magenta
        ['#22c55e','#a7f3d0'], // 16-20 lime
        ['#fbbf24','#fde68a'], // 21-25 gold
        ['#e5e7eb','#ffffff']  // 26-30 white
      ];
      const idx=Math.min(5, Math.floor((lv-1)/5));
      return {head:palette[idx][0], tail:palette[idx][1]};
    }
    function shoot(force){
      const p=state.player; const need=1/p.weapon.fireRate;
      if(!force && shootClock<need) return; shootClock=0;
      const spread = p.weapon.lvl>=3? 3:1; for(let i=0;i<spread;i++){
        const ang=(i-(spread-1)/2)*0.08; const vx=Math.sin(ang)*120;
        state.bullets.push({x:p.x, y:p.y-p.r-4, vx, vy:-p.weapon.bulletSpd, r:4, dmg:p.weapon.dmg, life:1, col:bulletColorForLevel(state.lv)});
      }
    }
    function dash(){ const d=state.player.dash; if(d.active||!d.ready) return; d.active=true; d.ready=false; d.t=0; setTimeout(()=>d.ready=true, d.cd*1000); }
    function laser(){
      const l=state.player.laser; if(l.active||!l.ready) return; const aim=findAim(); l.dirX=aim.dx; l.dirY=aim.dy; l.active=true; l.t=0; l.ready=false; 
      // 플레이어 레이저 빔 생성(비적대)
      const p=state.player; const far=H*1.2; state.beams.push({
        x1:p.x, y1:p.y - p.r*0.3, x2:p.x + l.dirX*far, y2:p.y + l.dirY*far, t:l.dur, hostile:false, didHit:false
      });
      setTimeout(()=>l.ready=true, l.cd*1000);
    }
    function findAim(){ let best=null, bd=1e9; const p=state.player; for(const e of state.enemies){ const d=hypot(e.x-p.x,e.y-p.y); if(d<bd){bd=d; best=e;} } for(const u of state.ufo){ const d=hypot(u.x-p.x,u.y-p.y); if(d<bd){bd=d; best=u;} } let dx=0,dy=-1; if(best){ dx=best.x-p.x; dy=best.y-p.y; const m=hypot(dx,dy)||1; dx/=m; dy/=m; } return {dx,dy}; }

    // ===== Update & Draw =====
    function step(dt){
      shootClock+=dt;
      const p=state.player; const sp=p.speed*(p.dash.active?2.0:1.0);
      if(!state.dragging){ if(keys['ArrowLeft']||keys['KeyA']) state.target.x-=sp*dt; if(keys['ArrowRight']||keys['KeyD']) state.target.x+=sp*dt; if(keys['ArrowUp']||keys['KeyW']) state.target.y-=sp*dt; if(keys['ArrowDown']||keys['KeyS']) state.target.y+=sp*dt; }
      if(keys.shoot) shoot(false);
      state.target.x=clamp(state.target.x, p.r, W-p.r); state.target.y=clamp(state.target.y, p.r, H-p.r);
      const dx=state.target.x-p.x, dy=state.target.y-p.y, dist=hypot(dx,dy)||1; p.vx = lerp(p.vx, dx/dist*sp, Math.min(1, dt*6)); p.vy = lerp(p.vy, dy/dist*sp, Math.min(1, dt*6)); p.x = clamp(p.x + p.vx*dt, p.r, W-p.r); p.y = clamp(p.y + p.vy*dt, p.r, H-p.r);
      if(p.dash.active){ p.dash.t+=dt; if(p.dash.t>p.dash.dur){ p.dash.t=0; p.dash.active=false; }}

      state.stageClock+=dt; const P=stageBalancing(state.stage);
      if(state.enemies.length<P.maxEnemies && Math.random()<P.enemySpawnProb) spawnAlien();
      if(state.ufo.length<P.maxUfo && Math.random()<P.ufoSpawnProb) spawnUfo();

      // bullets
      for(let i=state.bullets.length-1;i>=0;i--){ const b=state.bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt*0.8; if(b.y<-20 || b.life<=0){ state.bullets.splice(i,1); continue; }
        for(let j=state.enemies.length-1;j>=0;j--){ const e=state.enemies[j]; if(hypot(b.x-e.x,b.y-e.y)<(b.r+e.r*0.8)){
            e.hp-=b.dmg; state.bullets.splice(i,1); if(e.hp<=0){ state.enemies.splice(j,1); gainXP(10); } break; }
        }
        for(let j=state.ufo.length-1;j>=0;j--){ const u=state.ufo[j]; if(hypot(b.x-u.x,b.y-u.y)<(b.r+u.r*0.8)){
            u.hp-=b.dmg; state.bullets.splice(i,1); if(u.hp<=0){ state.ufo.splice(j,1); gainXP(20); } break; }
        }
      }

      // enemies wander
      for(const e of state.enemies){
        // 간단한 종족별 모션
        if(e.kind==='wisp'){ e.x+=Math.cos(e.phase+=dt*2.0)*20*dt; e.y+=Math.sin(e.phase*1.3)*14*dt; }
        else if(e.kind==='crystal'){ e.x+=e.vx*dt; e.y+=e.vy*dt; e.vx*= (e.x<20||e.x>W-20)?-1:1; e.vy*=(e.y<20||e.y>H*0.6)?-1:1; }
        else { e.x+=e.vx*dt; e.y+=e.vy*dt; if(e.x<20||e.x>W-20) e.vx*=-1; if(e.y<20||e.y>H*0.6) e.vy*=-1; }
      }

      // ufo move & shoot (stage < 6: no lasers)
      for(let i=state.ufo.length-1;i>=0;i--){ const u=state.ufo[i]; u.x+=u.vx*dt; if(u.x<-120||u.x>W+120){ state.ufo.splice(i,1); continue; } u.shoot=(u.shoot||0)+dt; if(state.stage>=6 && u.shoot>1.7){ u.shoot=0; const dx=p.x-u.x, dy=p.y-u.y; const m=hypot(dx,dy)||1; state.beams.push({x1:u.x,y1:u.y, x2:u.x+dx/m*H, y2:u.y+dy/m*H, t:0.22, hostile:true, didHit:false}); } }

      // beams: single-hit(적) + 플레이어 빔 도트데미지
      for(let i=state.beams.length-1;i>=0;i--){ const bm=state.beams[i]; bm.t-=dt; if(bm.t<=0){ state.beams.splice(i,1); continue; }
        if(bm.hostile && !bm.didHit){ if(lineHitCircle(bm.x1,bm.y1,bm.x2,bm.y2, p.x,p.y, p.r*0.85)){ p.hp=Math.max(0, p.hp-4); ui.hp.textContent=p.hp; bm.didHit=true; if(p.hp<=0){ reset(); return; } } }
        if(!bm.hostile){ // 플레이어 레이저: 도트 데미지 (온건)
          const dps=28; // 초당 데미지(총량 낮음)
          for(let j=state.enemies.length-1;j>=0;j--){ const e=state.enemies[j]; if(lineHitCircle(bm.x1,bm.y1,bm.x2,bm.y2,e.x,e.y,e.r*0.85)){ e.hp-=dps*dt; if(e.hp<=0){ state.enemies.splice(j,1); gainXP(10); } } }
          for(let j=state.ufo.length-1;j>=0;j--){ const u=state.ufo[j]; if(lineHitCircle(bm.x1,bm.y1,bm.x2,bm.y2,u.x,u.y,u.r*0.85)){ u.hp-=dps*dt*0.6; if(u.hp<=0){ state.ufo.splice(j,1); gainXP(20); } } }
        }
      }

      if(state.stageClock>25){ state.stageClock=0; state.stage=Math.min(state.maxStage, state.stage+1); ui.stage.textContent=state.stage; state.theme = Math.min(5, Math.floor((state.stage-1)/5)); }
    }

    function lineHitCircle(x1,y1,x2,y2,cx,cy,r){ const vx=x2-x1, vy=y2-y1; const wx=cx-x1, wy=cy-y1; const vv=vx*vx+vy*vy||1; let t=(vx*wx+vy*wy)/vv; if(t<0) t=0; if(t>1) t=1; const px=x1+vx*t, py=y1+vy*t; const dx=cx-px, dy=cy-py; return (dx*dx+dy*dy) <= r*r; }

    function draw(){
      drawBackground((state.last||0)/1000);
      drawAstronaut(state.player);
      for(const e of state.enemies) drawAlien(e);
      for(const u of state.ufo) drawUfo(u);
      // bullets with level palette
      for(const b of state.bullets){
        const len=18; const tx=b.x; const ty=b.y+len; const g=ctx.createLinearGradient(b.x,b.y,tx,ty); g.addColorStop(0, b.col.head); g.addColorStop(1, 'transparent');
        ctx.strokeStyle=g; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(tx,ty); ctx.stroke();
        ctx.fillStyle=b.col.tail; ctx.beginPath(); ctx.arc(b.x,b.y,2.6,0,Math.PI*2); ctx.fill();
      }
      drawBeams();
    }

    function reset(){ state.player.x=W*0.5; state.player.y=H*0.78; state.player.hp=100; ui.hp.textContent=100; state.enemies.length=0; state.ufo.length=0; state.bullets.length=0; state.beams.length=0; state.stage=1; ui.stage.textContent=1; state.theme=0; state.lv=1; state.xp=0; state.xpNext=20; ui.lv.textContent=1; ui.weapon.textContent='Lv.'+state.player.weapon.lvl; }

    function gainXP(v){ state.xp+=v; while(state.xp>=state.xpNext){ state.xp-=state.xpNext; state.lv++; ui.lv.textContent=state.lv; state.xpNext=Math.floor(state.xpNext*1.25+10);
        if(state.player.weapon.lvl<6 && state.lv%2===0){ state.player.weapon.lvl++; ui.weapon.textContent='Lv.'+state.player.weapon.lvl; state.player.weapon.fireRate+=0.5; state.player.weapon.dmg+=0.5; }
      }
    }

    // ===== Main loop =====
    function loop(ts){ if(!state.last) state.last=ts; const dt=Math.min(0.033,(ts-state.last)/1000); state.last=ts; if(!state.paused) step(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // ===== Quick self-tests =====
    function runTests(){
      // 존재/상수
      console.assert(typeof stageBalancing==='function' && typeof enemyHPFor==='function' && typeof enemyKindPool==='function','밸런싱/HP 함수 누락');
      console.assert(typeof drawBeams==='function' && typeof drawPlanet==='function' && typeof drawBackground==='function','draw 함수 누락');
      // 1) 사격 즉시 동작
      const prev=state.bullets.length; const sc=shootClock; shootClock=999; shoot(true); console.assert(state.bullets.length>prev,'발사 실패'); shootClock=sc;
      // 2) 초반 레이저 금지(적)
      state.stage=1; const u0={x:100,y:80,vx:0,r:26,hp:90,shoot:2}; state.ufo.push(u0); const beamsPrev=state.beams.length; step(0.02); console.assert(state.beams.length===beamsPrev,'초반 레이저 금지 실패'); state.ufo.length=0;
      // 3) HP 차등 적용
      const hp1 = enemyHPFor('jelly',1,16); const hp10= enemyHPFor('jelly',10,16); const hpCrystal= enemyHPFor('crystal',10,16);
      console.assert(hp10>hp1,'스테이지 HP 증가 실패'); console.assert(hpCrystal>hp10*1.05,'종족별 HP 가중치 실패');
      // 4) 플레이어 레이저 생성 테스트
      const beams0=state.beams.length; laser(); console.assert(state.beams.length===beams0+1,'플레이어 레이저 생성 실패');
      // 5) drawBackground 실행 검증 (예외 없어야 함)
      try{ drawBackground(0.1); } catch(e){ console.assert(false, 'drawBackground 실행 에러: '+e.message); }
      console.log('%cSELF-TEST PASS','color:#16a34a;font-weight:bold');
    }
    runTests();

  })();
  </script>
</body>
</html>
