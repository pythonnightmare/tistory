<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>2048 (Stable Canvas)</title>
<style>
  body{margin:0;background:#0b1220;color:#e5e7eb;font-family:system-ui,Apple SD Gothic Neo,Segoe UI,Roboto}
  .wrap{max-width:900px;margin:0 auto;padding:16px}
  .card{background:#111827;border:1px solid #1f2937;border-radius:14px;padding:16px}
  h1{margin:0 0 10px;font-size:18px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badge{padding:6px 10px;border:1px solid #334155;border-radius:999px;background:#0f172a}
  .btn{border:0;background:#22c55e;color:#0b1220;font-weight:800;border-radius:10px;padding:10px 14px;cursor:pointer}
  canvas{display:block;width:520px;max-width:100%;aspect-ratio:1/1;border-radius:12px;border:1px solid #243042;background:#0f172a;margin-top:12px}
  small{color:#93c5fd}
</style>

<div class="wrap"><div class="card">
  <h1>2048 (Fast)</h1>
  <div class="row">
    <span class="badge">점수: <b id="score">0</b></span>
    <span class="badge">최고: <b id="best">0</b></span>
    <button class="btn" id="new">새 게임</button>
  </div>
  <canvas id="cv" width="520" height="520"></canvas>
  <small>방향키 / 스와이프 지원</small>
</div></div>

<script>
(()=> {
  const B=4, PAD=10, BG='#0f172a', CELL='#131c2c';
  const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
  const scoreEl=document.getElementById('score'), bestEl=document.getElementById('best');
  let best=+localStorage.getItem('best2048')||0; bestEl.textContent=best;
  let g, score=0;

  // 셀 크기
  const S = () => (cv.width - PAD*5)/4;

  // 색 팔레트(가독성↑)
  function tileColor(v){
    const m={2:'#f7ead5',4:'#f3ddb7',8:'#f2b179',16:'#f59563',32:'#f67c5f',64:'#f65e3b',
             128:'#edcf72',256:'#edcc61',512:'#edc850',1024:'#edc53f',2048:'#edc22e'};
    return m[v] || '#3f8cff';
  }

  // --- 그리기 ---
  function drawGrid(){
    ctx.fillStyle=BG; ctx.fillRect(0,0,cv.width,cv.height);
    const s=S();
    for(let y=0;y<B;y++)for(let x=0;x<B;x++){
      const X=PAD+(s+PAD)*x, Y=PAD+(s+PAD)*y;
      ctx.fillStyle=CELL; ctx.fillRect(X,Y,s,s);
    }
  }
  function drawTiles(){
    const s=S();
    ctx.textAlign='center'; ctx.textBaseline='middle';
    for(let y=0;y<B;y++)for(let x=0;x<B;x++){
      const v=g[y][x]; if(!v) continue;
      const X=PAD+(s+PAD)*x, Y=PAD+(s+PAD)*y;

      // 타일 본체 + 테두리(브라우저마다 확실히 보이도록)
      ctx.fillStyle=tileColor(v); ctx.fillRect(X,Y,s,s);
      ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.strokeRect(X+0.5,Y+0.5,s-1,s-1);

      // 숫자 (윤곽선 + 본문)
      let f=28; if(v>=128) f=24; if(v>=1024) f=20;
      ctx.font=`900 ${f}px system-ui,Segoe UI,Apple SD Gothic Neo`;
      ctx.lineWidth=4; ctx.strokeStyle='rgba(0,0,0,.35)';
      ctx.strokeText(v, X+s/2, Y+s/2);
      ctx.fillStyle=(v<=4)?'#1b1b1b':'#fff';
      ctx.fillText(v, X+s/2, Y+s/2);
    }
  }
  function render(){
    drawGrid(); drawTiles();
    scoreEl.textContent=score;
    if(score>best){ best=score; localStorage.setItem('best2048',best); }
    bestEl.textContent=best;
  }

  // --- 로직 ---
  function add(){
    const z=[]; for(let y=0;y<B;y++)for(let x=0;x<B;x++) if(!g[y][x]) z.push([x,y]);
    if(!z.length) return;
    const [x,y]=z[(Math.random()*z.length)|0];
    g[y][x]=(Math.random()<.9?2:4);
  }
  function newGame(){
    g=[...Array(B)].map(()=>Array(B).fill(0)); score=0;
    // 초기 2칸은 "고정"으로 찍고, 그 다음 랜덤 1칸 추가 → 반드시 보임
    g[0][0]=2; g[0][1]=2; add();
    // 혹시 모를 지연 대비 즉시/지연 렌더 두 번
    render(); setTimeout(render,0);
  }
  function line(a){
    a=a.filter(v=>v);
    for(let i=0;i<a.length-1;i++) if(a[i]===a[i+1]){ a[i]*=2; score+=a[i]; a.splice(i+1,1); }
    while(a.length<B) a.push(0);
    return a;
  }
  function move(dir){
    let moved=false;
    if(dir==='left'){
      for(let y=0;y<B;y++){ const before=[...g[y]]; g[y]=line(g[y]); if(!moved) moved=g[y].some((v,i)=>v!==before[i]); }
    }else if(dir==='right'){
      for(let y=0;y<B;y++){ const before=[...g[y]].reverse(); const after=line(before).reverse();
        if(!moved) moved=after.some((v,i)=>v!==g[y][i]); g[y]=after; }
    }else if(dir==='up'){
      for(let x=0;x<B;x++){ const col=g.map(r=>r[x]); const before=[...col]; const after=line(col);
        if(!moved) moved=after.some((v,i)=>v!==before[i]); for(let y=0;y<B;y++) g[y][x]=after[y]; }
    }else if(dir==='down'){
      for(let x=0;x<B;x++){ const col=g.map(r=>r[x]).reverse(); const after=line(col).reverse();
        if(!moved) moved=after.some((v,i)=>v!==g.map(r=>r[x])[i]); for(let y=0;y<B;y++) g[y][x]=after[y]; }
    }
    if(moved){ add(); render(); checkOver(); }
  }
  function checkOver(){
    for(let y=0;y<B;y++)for(let x=0;x<B;x++){
      if(!g[y][x]) return;
      const v=g[y][x];
      if(x<B-1 && g[y][x+1]===v) return;
      if(y<B-1 && g[y+1][x]===v) return;
    }
    alert('게임 종료!');
  }

  // --- 입력 ---
  addEventListener('keydown',e=>{
    const m={ArrowLeft:'left',ArrowRight:'right',ArrowUp:'up',ArrowDown:'down'}[e.key];
    if(m){ e.preventDefault(); move(m); }
  });
  let sx=0,sy=0;
  cv.addEventListener('touchstart',e=>{const t=e.touches[0]; sx=t.clientX; sy=t.clientY;},{passive:true});
  cv.addEventListener('touchend',e=>{
    const t=e.changedTouches[0], dx=t.clientX-sx, dy=t.clientY-sy;
    if(Math.abs(dx)>Math.abs(dy)) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
  },{passive:true});

  new.onclick=newGame;
  newGame();
})();
</script>
