<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Vector Drift 3D — CC0 Arcade (Locked Cam / Track-Left Steering)</title>
<style>
  :root{ --bg:#070a16; --bg2:#0b1230; --ink:#eaf2ff; --muted:#9aa9c6 }
  html,body{height:100%;margin:0;background:radial-gradient(1000px 520px at 80% -10%,#182555 0%,transparent 52%),linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;user-select:none;-webkit-user-select:none;overscroll-behavior:none}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .card{position:relative;border:1px solid rgba(255,255,255,.1);border-radius:18px;background:rgba(255,255,255,.04);box-shadow:0 12px 48px rgba(0,0,0,.45);overflow:hidden}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  .title{display:flex;gap:10px;align-items:center;font-weight:800}
  .stats{display:flex;gap:16px;align-items:center}
  .stat{font-variant-numeric:tabular-nums}
  .stat .label{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn,.select{appearance:none;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);padding:7px 10px;border-radius:10px;font-weight:800;cursor:pointer}
  .view{position:relative;width:100%;height:min(56.25vw,700px);background:#050812;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(10,14,34,.78);border:1px solid rgba(255,255,255,.14);border-radius:18px;padding:18px;max-width:560px;text-align:center;box-shadow:0 16px 70px rgba(0,0,0,.5);animation:pop .14s ease-out}
  .panel h1{margin:0 0 6px;font-size:22px}
  .panel p{margin:0 0 10px;color:var(--muted)}
  @keyframes pop{from{opacity:0;transform:scale(.97)}to{opacity:1;transform:scale(1)}}
  .help{position:absolute;left:10px;bottom:10px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hud">
      <div class="title">🚗 VECTOR DRIFT 3D <span style="color:var(--muted);font-size:12px">· CC0</span></div>
      <div class="stats">
        <div class="stat" id="uiSpeed"><span class="label">SPEED</span> <b class="val">0</b></div>
        <div class="stat" id="uiLap"><span class="label">LAP</span> <b class="val">—</b></div>
        <div class="stat" id="uiDrift"><span class="label">DRIFT</span> <b class="val">0</b></div>
        <div class="stat" id="uiBest"><span class="label">BEST</span> <b class="val">—</b></div>
        <div class="stat" id="uiMission"><span class="label">MISSION</span> <b class="val">Collect 12</b></div>
        <div class="stat" id="uiScore"><span class="label">SCORE</span> <b class="val">0</b></div>
      </div>
      <div class="controls">
        <button class="btn" id="btnPlay">▶ 시작</button>
        <button class="btn" id="btnPause">⏸ 일시정지</button>
        <button class="btn" id="btnReset">↻ 리셋</button>
        <button class="btn" id="btnReroll">🎲 새 트랙</button>
        <button class="btn" id="btnShape">🛣 트랙: RANDOM</button>
        <label style="font-size:12px;color:var(--muted)">테마</label>
        <select class="select" id="selTheme">
          <option value="SPACE">SPACE</option>
          <option value="CYBERPUNK">CYBERPUNK</option>
          <option value="XMAS">XMAS</option>
          <option value="NEON">NEON</option>
          <option value="VOLCANO">VOLCANO</option>
        </select>
      </div>
    </div>
    <div class="view" id="view">
      <canvas id="gl"></canvas>
      <div class="overlay" id="overlay"></div>
      <div class="help">←/→ 좌우(트랙 기준) · ↑ 가속 · ↓ 브레이크 · SPACE 드리프트 | R 리셋 · P 일시정지</div>
    </div>
  </div>
</div>

<script>
(()=>{
// ====== 기본 유틸 ======
const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const now=()=>performance.now();
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
const saveKey='vector_drift_3d_lock_v2';
const store={get(){try{return JSON.parse(localStorage.getItem(saveKey)||'{}')}catch(e){return{}}},set(v){localStorage.setItem(saveKey,JSON.stringify(v))}};
const cfg=Object.assign({seed:(Math.random()*1e9)|0,best:null,theme:'SPACE',shape:'RANDOM'},store.get());
const hashStr=(s)=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;};

// ====== 입력 (1P) ======
const input={L:false,R:false,ACC:false,BR:false,DR:false,stickX:0,pointer:null};
addEventListener('keydown',e=>{
  if(e.repeat) return;
  const b=['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyA','KeyD','KeyW','KeyS','KeyR','KeyP']; if(b.includes(e.code)) e.preventDefault();
  if(e.code==='ArrowLeft'||e.code==='KeyA') input.L=true;
  if(e.code==='ArrowRight'||e.code==='KeyD') input.R=true;
  if(e.code==='ArrowUp'||e.code==='KeyW') input.ACC=true;
  if(e.code==='ArrowDown'||e.code==='KeyS') input.BR=true;
  if(e.code==='Space') input.DR=true;
  if(e.key==='p'||e.key==='P') togglePause();
  if(e.key==='r'||e.key==='R') reset();
});
addEventListener('keyup',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') input.L=false;
  if(e.code==='ArrowRight'||e.code==='KeyD') input.R=false;
  if(e.code==='ArrowUp'||e.code==='KeyW') input.ACC=false;
  if(e.code==='ArrowDown'||e.code==='KeyS') input.BR=false;
  if(e.code==='Space') input.DR=false;
});
const view=document.getElementById('view');
view.addEventListener('pointerdown',e=>{
  if(e.button===0){ view.setPointerCapture(e.pointerId); input.pointer={id:e.pointerId}; if(state===S.MENU) start(); }
});
view.addEventListener('pointermove',e=>{
  if(!input.pointer||e.pointerId!==input.pointer.id) return;
  const rect=view.getBoundingClientRect();
  input.stickX = clamp(((e.clientX-rect.left)/rect.width)*2-1,-1,1);
});
view.addEventListener('pointerup',e=>{ if(!input.pointer||e.pointerId!==input.pointer.id) return; input.pointer=null; input.stickX=0; });

// ====== HUD ======
function setHUD(id,val){ const el=document.querySelector('#'+id+' .val'); if(el) el.textContent=val; }

// ====== WebGL ======
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
let CW=2,CH=2;
function applyViewport(){ const r=view.getBoundingClientRect(); CW=(r.width*DPR)|0; CH=(r.height*DPR)|0; canvas.width=Math.max(2,CW); canvas.height=Math.max(2,CH); gl.viewport(0,0,CW,CH); }
applyViewport(); new ResizeObserver(applyViewport).observe(view);
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
gl.clearDepth(1); gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);
function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s;}
function prog(vs,fs){const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p;}

// ====== 수학 ======
const M={mul:(a,b)=>{const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];} return o;},
T:(x,y,z)=>[1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1],
RfromBasis:(x,y,z)=>[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1],
look:(eye,at,up)=>{const zx=eye[0]-at[0],zy=eye[1]-at[1],zz=eye[2]-at[2]; const zL=Math.hypot(zx,zy,zz)||1; const z=[zx/zL,zy/zL,zz/zL]; let x=[up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]]; const xL=Math.hypot(x[0],x[1],x[2])||1; x=[x[0]/xL,x[1]/xL,x[2]/xL]; const y=[z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]]; const RT=[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1]; return M.mul(RT,M.T(-eye[0],-eye[1],-eye[2]));}};
const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
const norm=v=>{const l=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l];};
const add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]];
const scale=(v,s)=>[v[0]*s,v[1]*s,v[2]*s];

// ====== 지오 도우미 ======
function pushTri(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,c,g){ out.pos.push(x1,y1,z1,x2,y2,z2,x3,y3,z3); out.col.push(c[0],c[1],c[2], c[0],c[1],c[2], c[0],c[1],c[2]); out.glow.push(g,g,g); }
function pushQuad(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,c,g){ pushTri(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,c,g); pushTri(out,x1,y1,z1,x3,y3,z3,x4,y4,z4,c,g); }
function pushBox(out,cx,cy,cz,sx,sy,sz,ct,cs,g=0.25){const x=sx/2,y=sy/2,z=sz/2;pushQuad(out,cx-x,cy+y,cz-z,cx+x,cy+y,cz-z,cx+x,cy+y,cz+z,cx-x,cy+y,cz+z,ct,g);pushQuad(out,cx-x,cy-y,cz+z,cx+x,cy-y,cz+z,cx+x,cy-y,cz-z,cx-x,cy-y,cz-z,cs,g*0.8);pushQuad(out,cx-x,cy-y,cz-z,cx-x,cy+y,cz-z,cx-x,cy+y,cz+z,cx-x,cy-y,cz+z,cs,g);pushQuad(out,cx+x,cy-y,cz+z,cx+x,cy+y,cz+z,cx+x,cy+y,cz-z,cx+x,cy-y,cz-z,cs,g);pushQuad(out,cx-x,cy-y,cz+z,cx-x,cy+y,cz+z,cx+x,cy+y,cz+z,cx+x,cy-y,cz+z,cs,g);pushQuad(out,cx+x,cy-y,cz-z,cx+x,cy+y,cz-z,cx-x,cy+y,cz-z,cx-x,cy-y,cz-z,cs,g);}
const makeGeo=()=>({pos:[],col:[],glow:[]});
function makeBuffer(data,itemSize,type=gl.FLOAT){const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW); return {b,itemSize,type};}
function bindBuffer(buf,attrib){ gl.bindBuffer(gl.ARRAY_BUFFER,buf.b); gl.enableVertexAttribArray(attrib); gl.vertexAttribPointer(attrib,buf.itemSize,buf.type,false,0,0); }

// ====== 트랙 ======
let samples=1100, trackW=6, trackMaxR=140;
let CP=[],centerline=[],bufRibbon=null,bufRail=null,verts=0,railVerts=0;
const WORLD_UP=[0,1,0];
const SHAPES=['RANDOM','OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY'];
const catmull=(p0,p1,p2,p3,t)=>{const t2=t*t,t3=t2*t;return[
0.5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
0.5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3),
0.5*((2*p1[2])+(-p0[2]+p2[2])*t+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3)
];};
const catmullTangent=(p0,p1,p2,p3,t)=>{const t2=t*t;return[
0.5*((-p0[0]+p2[0])+2*(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t+3*(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t2),
0.5*((-p0[1]+p2[1])+2*(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t+3*(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t2),
0.5*((-p0[2]+p2[2])+2*(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t+3*(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t2)
];};
let samplesPerLap=samples; const getCenter=i=>{const N=samplesPerLap; i=(i+N)%N; return [centerline[i*3],centerline[i*3+1],centerline[i*3+2]]};
const basisAt=i=>{
  const p0=getCenter(i), p1=getCenter(i+1);
  const T=norm(sub(p1,p0));
  let R=norm(cross(T,WORLD_UP)); if(!isFinite(R[0])) R=[1,0,0];
  const B=norm(cross(R,T));
  return {T,R,B};
};
function computeTrackMaxR(){ let m=0; for(let i=0;i<centerline.length;i+=3){const x=centerline[i],z=centerline[i+2]; m=Math.max(m,Math.hypot(x,z));} trackMaxR=m; }

function genCP(seed,shape,yAmp,baseY){
  const rng=mulberry32(seed|0), rand=(a,b)=>a+(b-a)*rng();
  if(shape==='RANDOM'){ shape=SHAPES[1+((rng()* (SHAPES.length-1))|0)]; }
  const arr=[]; const N=36; const R=120; const ph=rand(0,Math.PI*2);
  for(let i=0;i<N;i++){
    const t=i/N*2*Math.PI; let x=0,z=0;
    if(shape==='OVAL'){ const rx=R*(1.1+0.2*Math.sin(3*t+ph)), rz=R*(0.8+0.15*Math.sin(2*t+ph)); x=rx*Math.cos(t); z=rz*Math.sin(t); }
    else if(shape==='FIG8'){ x=R*0.9*Math.sin(2*t); z=R*0.7*Math.sin(t); x+=18*Math.sin(3*t+ph); }
    else if(shape==='CLOVER'){ const rad=R*(1+0.35*Math.sin(3*t+ph)); x=rad*Math.cos(t); z=rad*Math.sin(t); }
    else if(shape==='S_BEND'){ x=R*1.1*Math.cos(t)+30*Math.sin(2*t); z=R*0.8*Math.sin(t); }
    else if(shape==='ISLAND'){ const rad=R*(0.9+0.18*Math.sin(3*t+ph))*(0.94+rand(0,0.16)); x=rad*Math.cos(t); z=rad*Math.sin(t); }
    else if(shape==='LEMNISCATE'){ const a=R*0.9; const s=Math.sin(t), c=Math.cos(t); x=(a*Math.sqrt(2)*c)/(1+s*s); z=(a*Math.sqrt(2)*c*s)/(1+s*s); }
    else if(shape==='WAVY'){ const rx=R*(1+0.25*Math.sin(4*t+ph)), rz=R*(1+0.25*Math.cos(3*t+ph)); x=rx*Math.cos(t); z=rz*Math.sin(t); }
    const y=baseY + rand(-yAmp,yAmp)*(0.6+0.4*Math.sin(2*t+ph));
    arr.push([x,y,z]);
  }
  arr.push(arr[0],arr[1],arr[2]); return arr;
}

function buildTrack(themeKey){
  const T=THEMES[themeKey];
  const seed2=(cfg.seed ^ hashStr(themeKey) ^ hashStr(cfg.shape))>>>0;
  trackW=T.trackW; CP=genCP(seed2,cfg.shape,T.yAmp,T.baseY);
  const pos=[],col=[],glow=[]; const railPos=[],railCol=[],railGlow=[]; centerline=[]; verts=0; railVerts=0;
  const Ls=CP.length-3, maxSeg=Ls-1e-6;
  for(let i=0;i<samples;i++){
    const seg=(i/(samples-1))*maxSeg; const j=Math.floor(seg); const t=seg-j;
    const p=catmull(CP[j],CP[j+1],CP[j+2],CP[j+3],t);
    const d=norm(catmullTangent(CP[j],CP[j+1],CP[j+2],CP[j+3],t));
    let Rv=norm(cross(d,WORLD_UP)); if(!isFinite(Rv[0])) Rv=[1,0,0];
    centerline.push(p[0],p[1],p[2]);
    if(i<samples-1){
      const L=add(p,scale(Rv,-trackW*0.5)), Rr=add(p,scale(Rv,trackW*0.5));
      pos.push(L[0],L[1],L[2], Rr[0],Rr[1],Rr[2]); col.push(...T.trackC1,...T.trackC2); glow.push(0.5,0.5); verts+=2;
      railPos.push(L[0],L[1]+0.12,L[2], Rr[0],Rr[1]+0.12,Rr[2]); railCol.push(...T.rail, ...T.rail); railGlow.push(1.4,1.4); railVerts+=2;
    }
  }
  computeTrackMaxR();
  bufRibbon={pos:makeBuffer(new Float32Array(pos),3),col:makeBuffer(new Float32Array(col),3),glow:makeBuffer(new Float32Array(glow),1)};
  bufRail  ={pos:makeBuffer(new Float32Array(railPos),3),col:makeBuffer(new Float32Array(railCol),3),glow:makeBuffer(new Float32Array(railGlow),1)};
  gl.clearColor(T.fog[0],T.fog[1],T.fog[2],1);
  buildCollect(themeKey,seed2); buildBoost(themeKey,seed2);
  buildEnv(themeKey,seed2); buildCharacters(themeKey,seed2); buildTunnels(themeKey,seed2);
  setHUD('uiMission', orbs && orbs.length ? `Collect ${orbs.filter(o=>!o.taken).length}` : 'Mission ✓');
}

// ====== 차량 & 카메라(완전 고정 +Z) ======
function makeCarGeom(theme){ const t=THEMES[theme]; const hw=0.72,hh=0.26,hl=1.28,nose=0.55,c=t.car;
  const P=[-hw,hh,-hl, hw,hh,-hl, 0,hh+nose,-hl*0.2, -hw,hh,hl*0.2, 0,hh+nose,-hl*0.2, hw,hh,hl*0.2,
  -hw,-hh,-hl, -hw,hh,-hl, -hw,hh,hl*0.2, -hw,-hh,-hl, -hw,hh,hl*0.2, -hw,-hh,hl*0.2,
   hw,-hh,-hl,  hw,hh,hl*0.2,  hw,hh,-hl,  hw,-hh,-hl,  hw,-hh,hl*0.2,  hw,hh,hl*0.2,
  -hw,-hh,hl*0.2, hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,-hl];
  const cols=[]; for(let i=0;i<P.length/3;i++) cols.push(c[0],c[1],c[2]);
  const glow=new Float32Array(P.length/3).fill(t.carGlow);
  return {pos:makeBuffer(new Float32Array(P),3),col:makeBuffer(new Float32Array(cols),3),glow:makeBuffer(glow,1),verts:P.length/3};
}
let carGeom=null;

function makeCar(inputRef){ return {
  s:0,v:0,off:0,offV:0,steer:0,drift:0,lapStart:null,score:0,
  update(dt){
    // 입력: 왼쪽=-1 / 오른쪽=+1 (트랙 로컬 기준)
    let steerRaw=(inputRef.L?-1:0)+(inputRef.R?1:0);
    if(steerRaw===0) steerRaw=clamp(inputRef.stickX,-1,1);
    const ACC=inputRef.ACC||(inputRef.pointer!=null);
    const BR=inputRef.BR, DR=inputRef.DR;

    // 속도/감속 (아케이드 강화)
    const maxV=90;
    const acc=ACC?(DR?52:42):0, dec=BR?34:8.5;
    this.v=acc>0?clamp(this.v+acc*dt,0,maxV):Math.max(0,this.v-dec*dt);

    // 조향 스무딩
    const k=1-Math.pow(0.0001,dt*22);
    this.steer+= (steerRaw - this.steer)*k;

    // 트랙 로컬 R축에 직접 적용 (화면 기준 보정 없음) → 왼쪽키=트랙 왼쪽(-R)
    const latBase=(20+this.v*0.85)*(DR?1.9:1.0);
    const targetOffV = this.steer * latBase;

    // 오프셋 속도 스프링/감쇠
    const f=1-Math.pow(0.0001,dt*(DR?16:22));
    this.offV+= (targetOffV - this.offV)*f;
    const spring=-this.off*(DR?0.7:1.15); this.offV+=spring*dt; this.offV*=(DR?0.90:0.935);
    this.off=clamp(this.off+this.offV*dt,-trackW*0.48,trackW*0.48);

    // 진행
    this.s=(this.s+this.v*dt)%samplesPerLap;

    // 드리프트 점수/속도 소모
    const slip=Math.abs(this.offV)/(trackW*0.7);
    this.v*=(1-clamp(slip*(DR?0.03:0.065),0,0.1));
    const gain=Math.max(0,(Math.abs(this.offV)*0.032+Math.abs(this.steer)*this.v*0.013)*(DR?2.0:1.0));
    this.drift=Math.max(0,this.drift+(gain-0.36*dt));

    // 랩
    if(this.lapStart==null) this.lapStart=performance.now();
    const tNow=performance.now();
    if(this.s<2 && this.v>12 && (tNow-this.lapStart)>2000){
      const lap=(tNow-this.lapStart)/1000; this.lapStart=tNow; setHUD('uiLap',lap.toFixed(2)+'s');
      if(cfg.best==null||lap<cfg.best){ cfg.best=lap; store.set(cfg); setHUD('uiBest',cfg.best.toFixed(2)+'s'); }
    }
    collectItems(this); boostPads(this);
  },
  world(){ const i=Math.floor(this.s)|0; const t=this.s-i; const p=getCenter(i), n=getCenter(i+1);
    const pos=[lerp(p[0],n[0],t), lerp(p[1],n[1],t), lerp(p[2],n[2],t)];
    const {T,R,B}=basisAt(i);
    const posOff=add(pos, scale(R, this.off)); // this.off<0 → -R(트랙 왼쪽)
    return {pos:posOff, T, R, B};
  }
};}
const car=makeCar(input);

// 카메라 — **완전 고정(+Z)**: 입력/차량방향/롤/야오 완전 무시
const cam={ eye:[0,3.2,-9], at:[0,0.9,5], up:[0,1,0], fovBase:64*(Math.PI/180), fov:64*(Math.PI/180),
  update(dt){
    const w=car.world(); const sp=clamp(car.v,0,90);
    this.fov=this.fovBase + (sp*0.55)*(Math.PI/180); // 속도감
    const height=3.2, dist=9.0, lead=5.0;
    const a=[ w.pos[0], w.pos[1]+0.9, w.pos[2]+lead ];
    const e=[ w.pos[0], w.pos[1]+height, w.pos[2]-dist ];
    const k=1-Math.pow(0.0001,dt*7);
    this.eye=[lerp(this.eye[0],e[0],k), lerp(this.eye[1],e[1],k), lerp(this.eye[2],e[2],k)];
    this.at =[lerp(this.at[0],a[0],k),  lerp(this.at[1],a[1],k),  lerp(this.at[2],a[2],k)];
    this.up=[0,1,0];
  },
  snap(){ const w=car.world(); this.at=[w.pos[0],w.pos[1]+0.9,w.pos[2]+5.0]; this.eye=[w.pos[0],w.pos[1]+3.2,w.pos[2]-9.0]; this.up=[0,1,0]; },
  VP(aspect=CW/CH){
    const V=M.look(this.eye,this.at,this.up);
    const P=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
    const f=1/Math.tan(this.fov/2), near=0.1, far=900, nf=1/(near-far);
    P[0]=f/(aspect>0?aspect:1); P[5]=f; P[10]=(far+near)*nf; P[11]=-1; P[14]=(2*far*near)*nf; P[15]=0;
    return M.mul(P,V);
  }
};

// ====== 환경 / 캐릭터 / 터널 ======
let envBuf=null,envVerts=0,propBuf=null,propVerts=0,geoBuf=null,geoVerts=0,charBuf=null,charVerts=0,tunnelBuf=null,tunnelVerts=0;

function buildEnv(themeKey,seed2){
  envBuf=propBuf=geoBuf=null; envVerts=propVerts=geoVerts=0;
  const pts=[],cols=[],glows=[], p2=[],c2=[],g2=[], GEO=makeGeo();
  const pushP=(x,y,z,c,g)=>{pts.push(x,y,z); cols.push(c[0],c[1],c[2]); glows.push(g);};
  const push2=(x,y,z,c,g)=>{p2.push(x,y,z); c2.push(c[0],c[1],c[2]); g2.push(g);};
  const rng=mulberry32(seed2), t=THEMES[themeKey], groundY=0, ringR=trackMaxR+26;

  if(themeKey==='SPACE'){
    // 별/성운
    const rngS=mulberry32(seed2^0x55aa);
    for(let i=0;i<2600;i++){ const rr=ringR+40+rngS()*300; const aa=rngS()*Math.PI*2; const rx=Math.cos(aa)*rr, rz=Math.sin(aa)*rr, ry=(rngS()*2-1)*240+40; pushP(rx,ry,rz,[0.82+rngS()*0.18,0.88+rngS()*0.12,1],0.07); }
    // 소행성 대(帶)
    for(let i=0;i<520;i++){ const rr=ringR+30+rng()*260; const aa=rng()*Math.PI*2; const x=Math.cos(aa)*rr, z=Math.sin(aa)*rr, s=1.0+rng()*4.0; pushBox(GEO,x,5+rng()*18,z, s, s*0.7, s, [0.6,0.65,0.75],[0.45,0.5,0.62],0.25); }
    // 행성(구체) + 고리
    const sphere=(cx,cy,cz,R,lat,lon,col,gl)=>{for(let i=0;i<lat;i++){const v0=i/lat*Math.PI,v1=(i+1)/lat*Math.PI;for(let j=0;j<lon;j++){const u0=j/lon*2*Math.PI,u1=(j+1)/lon*2*Math.PI;
      const p=(v,u)=>[cx+R*Math.sin(v)*Math.cos(u), cy+R*Math.cos(v), cz+R*Math.sin(v)*Math.sin(u)];
      const a=p(v0,u0), b=p(v0,u1), c=p(v1,u1), d=p(v1,u0); pushQuad(GEO,a[0],a[1],a[2], b[0],b[1],b[2], c[0],c[1],c[2], d[0],d[1],d[2], col, gl); }}};
    const bigR=ringR+90;
    sphere(Math.cos(0.8)*bigR, 24, Math.sin(0.8)*bigR, 18, 14, 28, [0.55,0.8,1.0],0.55);
    sphere(Math.cos(2.1)*bigR*0.8, -10, Math.sin(2.1)*bigR*0.8, 12, 12, 20, [1.0,0.6,0.25],0.5);
    const ring=(cx,cy,cz,R,rMinor,seg=96,col=[0.6,0.9,1],gl=0.6)=>{
      for(let i=0;i<seg;i++){const a0=i/seg*2*Math.PI, a1=(i+1)/seg*2*Math.PI;
        const p0=[cx+Math.cos(a0)*R, cy, cz+Math.sin(a0)*R], p1=[cx+Math.cos(a1)*R, cy, cz+Math.sin(a1)*R];
        pushQuad(GEO, p0[0],cy-rMinor,p0[2], p1[0],cy-rMinor,p1[2], p1[0],cy+rMinor,p1[2], p0[0],cy+rMinor,p0[2], col, gl);
      }
    };
    ring(Math.cos(0.8)*bigR,24,Math.sin(0.8)*bigR, 30, 0.9, 120, [0.6,0.85,1.0],0.7);
    // 유성(포인트)
    for(let i=0;i<220;i++){ const rr=ringR+20+rng()*320; const aa=rng()*Math.PI*2; const rx=Math.cos(aa)*rr, rz=Math.sin(aa)*rr, ry=(rng()*2-1)*180+30; push2(rx,ry,rz,[0.9,0.95,1],0.9); }
  } else {
    // 지상형 테마: 트랙 반경(ringR) 밖에만 배치 → 침범 방지
    if(t.ground){
      const rad=ringR+90, step=10; const baseCol=(themeKey==='XMAS')?[0.92,0.97,1]: (themeKey==='VOLCANO')?[0.25,0.08,0.06]: (themeKey==='CYBERPUNK')?[0.08,0.08,0.12]: [0.06,0.08,0.12];
      for(let x=-rad;x<rad;x+=step){ for(let z=-rad;z<rad;z+=step){
        if(Math.hypot(x,z) < ringR-6) continue;
        const c=[ baseCol[0]*(0.94+0.12*rng()), baseCol[1]*(0.94+0.12*rng()), baseCol[2]*(0.94+0.12*rng()) ];
        pushQuad(GEO,x,groundY,z, x+step,groundY,z, x+step,groundY,z+step, x,groundY,z+step, c, 0.13);
      }}
    }
    if(themeKey==='CYBERPUNK'){
      for(let i=0;i<360;i++){ const r=ringR+8+rng()*220; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; const sy=12+rng()*60; pushBox(GEO,x,sy/2,z, 4+rng()*22,sy,4+rng()*22, [0.2,0.9,0.9],[0.6,0.2,1],0.4); }
      // 네온 빌보드
      for(let i=0;i<120;i++){ const r=ringR+30+rng()*200; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; pushQuad(GEO,x,6,z, x+4,6,z, x+4,10,z, x,10,z, [1,0.3,0.9], 0.9); }
      // 드론
      for(let i=0;i<180;i++){ const r=ringR+20+rng()*240; const a=rng()*Math.PI*2; push2(Math.cos(a)*r, 8+rng()*42, Math.sin(a)*r, [0.3,1,1], 0.85); }
    } else if(themeKey==='XMAS'){
      for(let i=0;i<300;i++){ const r=ringR+10+rng()*160; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r;
        if(rng()<0.55){ const sx=6+rng()*6, sz=6+rng()*6, sy=4+rng()*3; pushBox(GEO,x,sy/2,z,sx,sy,sz,[1,0.2,0.2],[0.9,0.9,0.95],0.35); pushBox(GEO,x,sy+1.2,z,sx*0.9,1.2,sz*0.9,[0.9,0.1,0.1],[0.9,0.1,0.1],0.4); }
        else{ pushBox(GEO,x,1.3,z, 0.9,2.6,0.9,[0.5,0.3,0.2],[0.5,0.3,0.2]); pushBox(GEO,x,3.6,z, 3.6,2.0,3.6,[0.1,0.6,0.2],[0.1,0.5,0.2]); pushBox(GEO,x,5.9,z, 3.0,1.8,3.0,[0.1,0.7,0.2],[0.1,0.6,0.2]); pushBox(GEO,x,7.9,z, 2.4,1.6,2.4,[0.1,0.8,0.2],[0.1,0.7,0.2]); }
      }
      // 가로등
      for(let i=0;i<120;i++){ const r=ringR+8+rng()*180; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; pushBox(GEO,x,2.6,z,0.6,5.2,0.6,[1,1,1],[1,0.2,0.2],0.7); }
      // 눈
      for(let i=0;i<2200;i++){ const r=ringR+5+rng()*180; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r; pushP(rx, groundY+100, rz, [1,1,1], -(0.5+rng()*0.5)); }
    } else if(themeKey==='NEON'){
      const baseR=ringR+12;
      for(let i=0;i<18;i++){ const r=baseR+i*9; for(let a=0;a<Math.PI;a+=Math.PI/28){ const x=Math.cos(a)*r, y=Math.sin(a)*26+4, z=0; pushQuad(GEO,x,y,z,x+1.2,y,z,x+1.2,y+1.2,z,x,y+1.2,z,[0.2,0.8,1],0.6);} }
      for(let i=0;i<420;i++){ const r=baseR+rng()*260; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r; push2(rx, -7, rz, [0.3,0.9,1], 0.85); }
    } else if(themeKey==='VOLCANO'){
      for(let i=0;i<260;i++){ const r=ringR+4+rng()*240; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; const sy=7+rng()*28; pushBox(GEO,x,sy/2,z,5,sy,5,[1,0.5,0.2],[1,0.35,0.15],0.44); }
      for(let i=0;i<1500;i++){ const r=ringR+10+rng()*260; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r, ry=rng()*90+6; pushP(rx,ry,rz,[1,0.5+rng()*0.3,0.2],0.45); }
    }
  }

  if(pts.length){envBuf={pos:makeBuffer(new Float32Array(pts),3),col:makeBuffer(new Float32Array(cols),3),glow:makeBuffer(new Float32Array(glows),1)}; envVerts=pts.length/3;}
  if(p2.length){propBuf={pos:makeBuffer(new Float32Array(p2),3),col:makeBuffer(new Float32Array(c2),3),glow:makeBuffer(new Float32Array(g2),1)}; propVerts=p2.length/3;}
  if(GEO.pos.length){geoBuf={pos:makeBuffer(new Float32Array(GEO.pos),3),col:makeBuffer(new Float32Array(GEO.col),3),glow:makeBuffer(new Float32Array(GEO.glow),1)}; geoVerts=GEO.pos.length/3;}
}

function buildCharacters(themeKey,seed2){
  charBuf=null; charVerts=0; const G=makeGeo(); const rng=mulberry32(seed2^0xABCD); const ringR=trackMaxR+28;
  const bot=(x,y,z,s,c1,c2)=>{ pushBox(G,x,y+2*s,z,1.2*s,1.8*s,0.8*s,c1,c1,0.4); pushBox(G,x,y+3.2*s,z,0.9*s,0.9*s,0.9*s,c2,c2,0.7); pushBox(G,x-0.9*s,y+2*s,z,0.4*s,1.2*s,0.4*s,c1,c1,0.4); pushBox(G,x+0.9*s,y+2*s,z,0.4*s,1.2*s,0.4*s,c1,c1,0.4); };
  const snow=(x,y,z,s)=>{ pushBox(G,x,y+0.7*s,z,1.0*s,1.0*s,1.0*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+1.6*s,z,0.8*s,0.8*s,0.8*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+2.3*s,z,0.6*s,0.6*s,0.6*s,[1,1,1],[1,1,1],0.9); };
  const dancer=(x,y,z,s,c)=>{ pushBox(G,x,y+1.6*s,z,0.9*s,1.6*s,0.6*s,c,c,0.85); pushBox(G,x,y+2.6*s,z,0.6*s,0.6*s,0.6*s,c,c,0.9); };
  const golem=(x,y,z,s)=>{ pushBox(G,x,y+1.6*s,z,1.2*s,1.6*s,1.0*s,[1,0.45,0.15],[1,0.35,0.12],0.85); pushBox(G,x,y+2.6*s,z,1.0*s,0.8*s,1.0*s,[1,0.5,0.2],[1,0.35,0.15],0.85); };
  const astro=(x,y,z,s)=>{ pushBox(G,x,y+1.9*s,z,1.0*s,1.6*s,0.8*s,[0.9,0.95,1],[0.8,0.9,1],0.7); pushBox(G,x,y+2.8*s,z,0.8*s,0.8*s,0.8*s,[0.6,0.8,1],[0.6,0.8,1],0.9); };
  const ship=(x,y,z,s)=>{ pushBox(G,x,y+0.6*s,z,2.2*s,0.6*s,1.2*s,[0.7,0.9,1],[0.5,0.7,1],0.9); pushBox(G,x,y+1.3*s,z,1.0*s,0.5*s,0.5*s,[0.9,1,1],[0.7,0.9,1],0.8); };

  const N=200;
  for(let i=0;i<N;i++){
    const r=ringR+10+rng()*100, a=rng()*Math.PI*2, x=Math.cos(a)*r, z=Math.sin(a)*r, s=0.9+rng()*0.9, h=0;
    if(themeKey==='SPACE'){ if(rng()<0.4) astro(x,h,z,s); else ship(x,h+2,z,0.7*s); }
    else if(themeKey==='CYBERPUNK') bot(x,h,z,s,[0.2,0.9,0.9],[1,0.3,0.9]);
    else if(themeKey==='XMAS') snow(x,h,z,1.2*s);
    else if(themeKey==='NEON') dancer(x,h,z,s,[0.3,1,1]);
    else if(themeKey==='VOLCANO') golem(x,h,z,s);
  }
  if(G.pos.length){ charBuf={pos:makeBuffer(new Float32Array(G.pos),3),col:makeBuffer(new Float32Array(G.col),3),glow:makeBuffer(new Float32Array(G.glow),1)}; charVerts=G.pos.length/3; }
}

function buildTunnels(themeKey,seed2){
  tunnelBuf=null; tunnelVerts=0; const G=makeGeo(); const rng=mulberry32(seed2^0xFACE); const T=THEMES[themeKey];
  function tube(centerIndex,radius,length,radial=28,axial=6){
    const {R,B}=basisAt(centerIndex); const C0=getCenter(centerIndex), C1=getCenter(centerIndex+Math.floor(length));
    for(let j=0;j<axial;j++){
      const s0=j/axial,s1=(j+1)/axial; const C=[lerp(C0[0],C1[0],s0),lerp(C0[1],C1[1],s0),lerp(C0[2],C1[2],s0)], D=[lerp(C0[0],C1[0],s1),lerp(C0[1],C1[1],s1),lerp(C0[2],C1[2],s1)];
      for(let i=0;i<radial;i++){
        const t0=i/radial*2*Math.PI,t1=(i+1)/radial*2*Math.PI;
        const a0=add(C, add(scale(R,Math.cos(t0)*radius), scale(B,Math.sin(t0)*radius)));
        const a1=add(C, add(scale(R,Math.cos(t1)*radius), scale(B,Math.sin(t1)*radius)));
        const b1=add(D, add(scale(R,Math.cos(t1)*radius), scale(B,Math.sin(t1)*radius)));
        const b0=add(D, add(scale(R,Math.cos(t0)*radius), scale(B,Math.sin(t0)*radius)));
        pushQuad(G,a0[0],a0[1],a0[2], a1[0],a1[1],a1[2], b1[0],b1[1],b1[2], b0[0],b0[1],b0[2], T.trackC2, 0.7);
      }
    }
  }
  function hollowSphere(centerIndex, radius, lat=10, lon=18, col=[0.7,0.9,1], glow=0.55){
    const C=getCenter(centerIndex);
    for(let i=0;i<lat;i++){ const v0=i/lat*Math.PI, v1=(i+1)/lat*Math.PI;
      for(let j=0;j<lon;j++){ const u0=j/lon*2*Math.PI, u1=(j+1)/lon*2*Math.PI;
        const p=(v,u)=>[ C[0]+radius*Math.sin(v)*Math.cos(u), C[1]+radius*Math.cos(v), C[2]+radius*Math.sin(v)*Math.sin(u) ];
        const a=p(v0,u0), b=p(v0,u1), c=p(v1,u1), d=p(v1,u0);
        pushQuad(G,a[0],a[1],a[2], b[0],b[1],b[2], c[0],c[1],c[2], d[0],d[1],d[2], col, glow);
      }
    }
  }
  const n=3+(rng()*3|0);
  for(let k=0;k<n;k++){ const i=80+(rng()*(samples-160)|0); tube(i,Math.max(3.2,trackW*0.7),18+(rng()*12|0),30,6); }
  if(themeKey==='SPACE'){ const m=1+(rng()*2|0); for(let k=0;k<m;k++){ const i=120+(rng()*(samples-240)|0); hollowSphere(i, Math.max(14,trackW*2.0), 10, 18, [0.6,0.85,1.0], 0.6); } }
  if(G.pos.length){ tunnelBuf={pos:makeBuffer(new Float32Array(G.pos),3),col:makeBuffer(new Float32Array(G.col),3),glow:makeBuffer(new Float32Array(G.glow),1)}; tunnelVerts=G.pos.length/3; }
}

// ====== 수집/부스트 ======
let orbBuf=null,orbVerts=0,orbs=[]; let boostBuf=null,boostVerts=0,boosts=[]; let missionDone=false;
function buildCollect(theme,seed2){
  orbs=[]; const pos=[],col=[],glow=[]; const rng=mulberry32(seed2^0x333);
  for(let i=30;i<samples; i+=Math.floor(44+rng()*52)){
    const {R}=basisAt(i); const C=getCenter(i); const lateral=(rng()*2-1)*trackW*0.42;
    const p=[ C[0]+R[0]*lateral, C[1]+1.0, C[2]+R[2]*lateral ];
    orbs.push({i,pos:p,r:0.9,taken:false}); pos.push(p[0],p[1],p[2]); col.push(1,1,1); glow.push(1.6);
  }
  orbBuf={pos:makeBuffer(new Float32Array(pos),3),col:makeBuffer(new Float32Array(col),3),glow:makeBuffer(new Float32Array(glow),1)}; orbVerts=pos.length/3;
}
function buildBoost(theme,seed2){
  boosts=[]; const pos=[],col=[],glow=[]; const rng=mulberry32(seed2^0x999);
  for(let i=60;i<samples;i+=Math.floor(120+rng()*90)){ const C=getCenter(i); const p=[C[0],C[1]+0.2,C[2]]; boosts.push({i,pos:p,r:1.8}); pos.push(p[0],p[1],p[2]); col.push(0.3,1,0.8); glow.push(1.5); }
  boostBuf={pos:makeBuffer(new Float32Array(pos),3),col:makeBuffer(new Float32Array(col),3),glow:makeBuffer(new Float32Array(glow),1)}; boostVerts=pos.length/3;
}
function boostPads(car){ for(const b of boosts){ const d=Math.hypot(car.world().pos[0]-b.pos[0],car.world().pos[1]-b.pos[1],car.world().pos[2]-b.pos[2]); if(d<b.r){ car.v=Math.min(car.v+24,90); } } }
function collectItems(car){
  let got=0;
  for(const orb of orbs){ if(orb.taken) continue; const w=car.world(); const d=Math.hypot(w.pos[0]-orb.pos[0], w.pos[1]-orb.pos[1], w.pos[2]-orb.pos[2]); if(d<orb.r){ orb.taken=true; car.score+=120; got++; } }
  if(got>0){
    setHUD('uiScore',String(car.score));
    const remain=orbs.filter(o=>!o.taken).length; setHUD('uiMission',remain>0?`Collect ${remain}`:'Mission ✓');
    if(remain===0 && !missionDone){ missionDone=true; const col=THEMES[cfg.theme].trackC1; const hex='#'+col.map(v=>('0'+((v*255)|0).toString(16)).slice(-2)).join(''); const overlay=document.getElementById('overlay'); overlay.innerHTML=`<div class="panel" style="border-color:${hex}80;background:linear-gradient(180deg,${hex}22,rgba(10,14,34,.78))"><h1>MISSION COMPLETE</h1><p style="margin:4px 0 0">+5000</p></div>`; setTimeout(()=>overlay.innerHTML='',1600); car.score+=5000; setHUD('uiScore',String(car.score)); }
  }
}

// ====== 셰이더/렌더 ======
const VS=`attribute vec3 aPos; attribute vec3 aCol; attribute float aGlow; uniform mat4 uVP; varying vec3 vCol; varying float vGlow; void main(){ vCol=aCol; vGlow=aGlow; gl_Position=uVP*vec4(aPos,1.0); gl_PointSize=3.0+11.0*clamp(vGlow,0.0,2.5);} `;
const FS=`precision mediump float; varying vec3 vCol; varying float vGlow; void main(){ float a=min(0.08+vGlow*0.9,1.0); gl_FragColor=vec4(vCol,a);} `;
const program=prog(VS,FS); gl.useProgram(program);
const loc={aPos:gl.getAttribLocation(program,'aPos'),aCol:gl.getAttribLocation(program,'aCol'),aGlow:gl.getAttribLocation(program,'aGlow'),uVP:gl.getUniformLocation(program,'uVP')};
function drawBuf(buf,count,mode){ if(!buf||!count) return; bindBuffer(buf.pos,loc.aPos); bindBuffer(buf.col,loc.aCol); bindBuffer(buf.glow,loc.aGlow); gl.drawArrays(mode,0,count); }
function drawCar(){ bindBuffer(carGeom.pos,loc.aPos); bindBuffer(carGeom.col,loc.aCol); bindBuffer(carGeom.glow,loc.aGlow); gl.drawArrays(gl.TRIANGLES,0,carGeom.verts); }
function carModelMatrix(){ const w=car.world(); return M.mul(M.T(w.pos[0],w.pos[1]+0.35,w.pos[2]), M.RfromBasis(w.R,[0,1,0],w.T)); }
function render(){
  gl.viewport(0,0,CW,CH); // 1P 전체
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const VP=cam.VP(CW/CH);
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VP));

  if(geoBuf)   drawBuf(geoBuf,geoVerts,gl.TRIANGLES);
  if(envBuf){  gl.disable(gl.DEPTH_TEST); drawBuf(envBuf,envVerts,gl.POINTS); gl.enable(gl.DEPTH_TEST); }
  if(propBuf)  drawBuf(propBuf,propVerts,gl.POINTS);
  if(tunnelBuf)drawBuf(tunnelBuf,tunnelVerts,gl.TRIANGLES);
  drawBuf(bufRail,railVerts,gl.POINTS);
  drawBuf(bufRibbon,verts,gl.TRIANGLE_STRIP);
  if(charBuf)  drawBuf(charBuf,charVerts,gl.TRIANGLES);
  drawBuf(orbBuf,orbVerts,gl.POINTS);
  drawBuf(boostBuf,boostVerts,gl.POINTS);

  const VPcar=M.mul(VP,carModelMatrix()); gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VPcar)); drawCar();
  setHUD('uiSpeed',Math.round(car.v*3.6)+''); setHUD('uiDrift',Math.floor(car.drift)+''); if(cfg.best!=null) setHUD('uiBest',cfg.best.toFixed(2)+'s');
}

// ====== 루프 ======
const S={MENU:0,PLAY:1,PAUSE:2}; let state=S.MENU; let last=now(), acc=0; const dt=1/60;
function frame(){ const t=now(); let d=(t-last)/1000; last=t; d=Math.min(d,0.2); acc+=d; if(state===S.PLAY){ while(acc>=dt){ pollGamepad(); car.update(dt); cam.update(dt); acc-=dt; } render(); requestAnimationFrame(frame); } }
function pollGamepad(){ const gp=(navigator.getGamepads&&navigator.getGamepads()[0])||null; if(!gp) return; const x=Math.abs(gp.axes[0])>0.08?gp.axes[0]:0; input.stickX=x; input.ACC=gp.buttons[0]?.pressed||false; input.BR=gp.buttons[1]?.pressed||false; }

// ====== UI ======
const overlay=document.getElementById('overlay');
function showMenu(){ overlay.innerHTML=`<div class="panel"><h1>VECTOR DRIFT 3D</h1><p>카메라 고정(+Z) · 트랙 기준 조향 · 다양한 트랙/배경 · 터널/행성</p><p style="font-size:12px;color:#9aa9c6">←/→/↑/↓ + SPACE · R 리셋 · P 일시정지</p><div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap"><button class='btn' id='start'>▶ 시작</button><button class='btn' id='reroll'>🎲 새 트랙</button><button class='btn' id='clear'>↻ 기록 삭제</button></div></div>`; overlay.querySelector('#start').onclick=()=>start(); overlay.querySelector('#reroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); rebuild(); }; overlay.querySelector('#clear').onclick=()=>{ cfg.best=null; store.set(cfg); location.reload(); }; }
function clearOverlay(){ overlay.innerHTML=''; }
function start(){ clearOverlay(); if(state!==S.PLAY){ state=S.PLAY; last=now(); acc=0; cam.snap(); frame(); } }
function togglePause(){ if(state===S.PLAY){ state=S.PAUSE; overlay.innerHTML=`<div class='panel'><h1>⏸ 일시정지</h1><div style='display:flex;gap:8px;justify-content:center'><button class='btn' id='res'>▶ 계속</button><button class='btn' id='menu'>메뉴</button></div></div>`; overlay.querySelector('#res').onclick=()=>{ clearOverlay(); state=S.PLAY; last=now(); acc=0; frame(); }; overlay.querySelector('#menu').onclick=()=>{ state=S.MENU; showMenu(); }; } else if(state===S.MENU){ start(); } }
function reset(){ state=S.MENU; car.s=0;car.v=0;car.off=0;car.offV=0;car.steer=0;car.drift=0;car.score=0; missionDone=false; setHUD('uiScore','0'); setHUD('uiMission', orbs && orbs.length ? `Collect ${orbs.filter(o=>!o.taken).length}` : 'Mission ✓'); showMenu(); render(); }
function rebuild(){ applyThemeCSS(cfg.theme); carGeom=makeCarGeom(cfg.theme); buildTrack(cfg.theme); samplesPerLap=samples; cam.snap(); render(); }

// ====== 테마 ======
const THEMES={
  SPACE:{ bg:()=>`radial-gradient(1200px 700px at 70% -10%, #0b1740 0%, transparent 55%), linear-gradient(180deg,#030616,#071531)`, trackC1:[0.58,0.82,1.0], trackC2:[0.62,0.4,1.0], rail:[0.9,0.95,1], env:'stars', trackW:6.2, baseY:1.6, yAmp:6, car:[0.9,0.95,1], carGlow:0.9, fog:[0.02,0.04,0.09], ground:false },
  CYBERPUNK:{ bg:()=>`radial-gradient(800px 500px at 80% -10%, #461058 0%, transparent 50%), linear-gradient(180deg,#16061e,#090a18)`, trackC1:[1.0,0.2,0.8], trackC2:[0.2,1.0,0.9], rail:[1,0.7,1], env:'city', trackW:6.8, baseY:0.6, yAmp:2.2, car:[1.0,0.3,0.9], carGlow:1.0, fog:[0.06,0.02,0.10], ground:true },
  XMAS:{ bg:()=>`radial-gradient(1000px 600px at 60% -10%, #0e1b3a 0%, transparent 52%), linear-gradient(180deg,#081226,#0a1a33)`, trackC1:[0.0,0.9,0.3], trackC2:[1.0,0.1,0.1], rail:[1,1,1], env:'village', trackW:7.0, baseY:0.6, yAmp:0.9, car:[0.9,0.1,0.1], carGlow:0.9, fog:[0.03,0.05,0.08], ground:true },
  NEON:{ bg:()=>`radial-gradient(900px 540px at 85% -10%, #103b6b 0%, transparent 52%), linear-gradient(180deg,#081022,#0a0f28)`, trackC1:[0.2,0.9,1.0], trackC2:[1.0,0.5,0.2], rail:[0.8,1,1], env:'scan', trackW:6.0, baseY:1.0, yAmp:3.2, car:[0.2,0.9,1.0], carGlow:0.95, fog:[0.02,0.05,0.12], ground:true },
  VOLCANO:{ bg:()=>`radial-gradient(900px 540px at 85% -10%, #3b0f0f 0%, transparent 52%), linear-gradient(180deg,#140606,#230a0a)`, trackC1:[1.0,0.5,0.0], trackC2:[0.9,0.2,0.1], rail:[1,0.85,0.7], env:'ash', trackW:7.2, baseY:0.4, yAmp:1.8, car:[1.0,0.4,0.05], carGlow:0.9, fog:[0.06,0.02,0.02], ground:true }
};
function applyThemeCSS(key){ const t=THEMES[key]; if(!t) return; document.body.style.background=t.bg(); }
function applyTheme(key){ if(!THEMES[key]) return; cfg.theme=key; store.set(cfg); rebuild(); }

// ====== 시작 ======
document.getElementById('selTheme').value=cfg.theme; applyThemeCSS(cfg.theme); carGeom=makeCarGeom(cfg.theme); buildTrack(cfg.theme); cam.snap(); showMenu(); render();
document.getElementById('btnPlay').onclick=()=>{ if(state!==S.PLAY) start(); };
document.getElementById('btnPause').onclick=togglePause;
document.getElementById('btnReset').onclick=reset;
document.getElementById('btnReroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); rebuild(); };
document.getElementById('btnShape').onclick=()=>{ const idx=(SHAPES.indexOf(cfg.shape)+1)%SHAPES.length; cfg.shape=SHAPES[idx]; store.set(cfg); document.getElementById('btnShape').textContent=`🛣 트랙: ${cfg.shape}`; rebuild(); };
document.getElementById('selTheme').onchange=(e)=>applyTheme(e.target.value);
})();
</script>
</body>
</html>
