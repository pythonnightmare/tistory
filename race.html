<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>벡터 레이싱1.1v</title>
<style>
  :root{ --bg:#070a16; --bg2:#0b1230; --ink:#eaf2ff; --muted:#9aa9c6; --glass:rgba(10,14,34,.82) }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1000px 520px at 80% -10%,#182555 0%,transparent 52%),linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;user-select:none;-webkit-user-select:none;overscroll-behavior:none}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .card{position:relative;border:1px solid rgba(255,255,255,.1);border-radius:18px;background:rgba(255,255,255,.04);box-shadow:0 12px 48px rgba(0,0,0,.45);overflow:hidden}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  .title{display:flex;gap:10px;align-items:center;font-weight:800}
  .stats{display:flex;gap:16px;align-items:center}
  .stat{font-variant-numeric:tabular-nums}
  .stat .label{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn,.select{appearance:none;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);padding:7px 10px;border-radius:10px;font-weight:800;cursor:pointer}
  .view{position:relative;width:100%;height:min(56.25vw,700px);background:#050812;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .panel{pointer-events:auto;background:var(--glass);border:1px solid rgba(255,255,255,.16);border-radius:18px;padding:18px;max-width:760px;width:min(92%,760px);text-align:center;box-shadow:0 16px 70px rgba(0,0,0,.55)}
  .panel h1{margin:0 0 10px}
  .keys{margin-top:8px;font-size:12px;color:var(--muted)}
  .pad{position:absolute;inset:auto 0 10px 0;display:none;gap:10px;justify-content:center;pointer-events:auto}
  .pad .pbtn{min-width:60px;min-height:60px;border-radius:16px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:#fff;font-weight:900}
  .pad .pwide{min-width:100px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hud">
      <div class="title">🏁 벡터 레이싱</div>
      <div class="stats">
        <div class="stat" id="uiSpeed"><span class="label">SPEED</span> <b class="val">0</b></div>
        <div class="stat" id="uiLap"><span class="label">LAP</span> <b class="val">0/3</b></div>
        <div class="stat" id="uiPos"><span class="label">POS</span> <b class="val">Solo</b></div>
        <div class="stat" id="uiBest"><span class="label">BEST</span> <b class="val">—</b></div>
      </div>
      <div class="controls">
        <button class="btn" id="btnPlay">▶ 시작</button>
        <button class="btn" id="btnPause">⏸ 일시정지</button>
        <button class="btn" id="btnReset">↻ 리셋</button>
        <button class="btn" id="btnReroll">🎲 새 트랙</button>
        <button class="btn" id="btnShape">🛣 RANDOM</button>
        <button class="btn" id="btnAI">🤖 AI: 0</button>
        <button class="btn" id="btn2P">👥 1P</button>
        <button class="btn" id="btnMobile">📱 Mobile: OFF</button>
        <label style="font-size:12px;color:#9aa9c6">테마</label>
        <select class="select" id="selTheme">
          <option value="SPACE">SPACE</option>
          <option value="CYBERPUNK">CYBERPUNK</option>
          <option value="XMAS">XMAS</option>
          <option value="NEON">NEON</option>
          <option value="VOLCANO">VOLCANO</option>
        </select>
      </div>
    </div>
    <div class="view" id="view">
      <canvas id="gl"></canvas>
      <div class="overlay" id="overlay"></div>
      <div class="pad" id="pad">
        <button class="pbtn" data-act="L">◀</button>
        <button class="pbtn" data-act="ACC">▲</button>
        <button class="pbtn" data-act="BR">▼</button>
        <button class="pbtn" data-act="R">▶</button>
        <button class="pbtn pwide" data-act="DR">DRIFT</button>
      </div>
    </div>
  </div>
</div>

<script>
(()=>{'use strict';

/* ===== Global error catcher to screen ===== */
const overlay=document.getElementById('overlay');
function panel(html){ overlay.innerHTML=`<div class="panel">${html}</div>`; }
function clearPanel(){ overlay.innerHTML=''; }
window.addEventListener('error',e=>{ panel(`<h1>⚠ 런타임 오류</h1><div style="text-align:left;white-space:pre-wrap">${e.message||e}</div>`); });
window.addEventListener('unhandledrejection',e=>{ panel(`<h1>⚠ Promise 오류</h1><div style="text-align:left;white-space:pre-wrap">${(e.reason&&e.reason.message)||e.reason||e}</div>`); });

/* ===== Utils ===== */
const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const mulberry32=a=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296};
const hashStr=s=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;};
const saveKey='vector_racing_v10';
const store={get(){try{return JSON.parse(localStorage.getItem(saveKey)||'{}')}catch(e){return{}}},set(v){localStorage.setItem(saveKey,JSON.stringify(v))}};
const SHAPES=['RANDOM','OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY'];

/* ===== Config ===== */
const cfg=Object.assign({seed:(Math.random()*1e9)|0,theme:'SPACE',shape:'RANDOM',aiCount:0,twoP:false,mobile:false,best:null}, store.get());

/* ===== DOM ===== */
const view=document.getElementById('view'), canvas=document.getElementById('gl');
const setHUD=(id,val)=>{const el=document.querySelector('#'+id+' .val'); if(el) el.textContent=val};

/* ===== GL ===== */
const gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
if(!gl){ panel('<h1>⚠ WebGL 미지원</h1><div class="keys">브라우저 또는 GPU 설정 확인</div>'); return; }

let CW=2,CH=2;
function applyViewport(){ const r=view.getBoundingClientRect(); CW=(r.width*DPR)|0; CH=(r.height*DPR)|0; canvas.width=CW; canvas.height=CH; gl.viewport(0,0,CW,CH); }
applyViewport();
if(window.ResizeObserver){ new ResizeObserver(applyViewport).observe(view); } else { window.addEventListener('resize',applyViewport); }

gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE); gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);

function compile(type,src){
  const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    const log=gl.getShaderInfoLog(s)||'(no log)'; panel(`<h1>⚠ 셰이더 오류</h1><pre style="text-align:left;white-space:pre-wrap">${log}</pre>`); throw new Error('Shader compile failed');
  }
  return s;
}
function prog(vs,fs){
  const p=gl.createProgram(); const sv=compile(gl.VERTEX_SHADER,vs); const sf=compile(gl.FRAGMENT_SHADER,fs);
  gl.attachShader(p,sv); gl.attachShader(p,sf); gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
    const log=gl.getProgramInfoLog(p)||'(no log)'; panel(`<h1>⚠ 링크 오류</h1><pre style="text-align:left;white-space:pre-wrap">${log}</pre>`); throw new Error('Program link failed');
  }
  return p;
}
function makeBuffer(data,item=3,type=gl.FLOAT){ const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW); return {b,item,type}; }
function bind(b,loc){ gl.bindBuffer(gl.ARRAY_BUFFER,b.b); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,b.item,b.type,false,0,0); }

/* ===== Math ===== */
const M={
  mul:(a,b)=>{const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];} return o;},
  T:(x,y,z)=>[1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1],
  R:(x,y,z)=>[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1],
  look:(eye,at,up)=>{const zx=eye[0]-at[0],zy=eye[1]-at[1],zz=eye[2]-at[2]; const zL=Math.hypot(zx,zy,zz)||1; const z=[zx/zL,zy/zL,zz/zL];
    let x=[up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]];
    const xL=Math.hypot(x[0],x[1],x[2])||1; x=[x[0]/xL,x[1]/xL,x[2]/xL];
    const y=[z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]];
    const RT=[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1];
    return M.mul(RT,M.T(-eye[0],-eye[1],-eye[2]));
  }
};
const add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]], sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
const scale=(v,s)=>[v[0]*s,v[1]*s,v[2]*s], dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
const norm=v=>{const l=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l]; };

/* ===== Themes ===== */
const THEMES={
  SPACE:{bg:()=>`radial-gradient(1200px 700px at 70% -10%, #0b1740 0%, transparent 55%), linear-gradient(180deg,#030616,#071531)`,trackC1:[0.58,0.82,1.0],trackC2:[0.62,0.4,1.0],rail:[0.9,0.95,1],trackW:6.2,baseY:1.6,yAmp:6,car:[0.9,0.95,1],fog:[0.02,0.04,0.09],ground:false},
  CYBERPUNK:{bg:()=>`radial-gradient(800px 500px at 80% -10%, #461058 0%, transparent 50%), linear-gradient(180deg,#16061e,#090a18)`,trackC1:[1.0,0.2,0.8],trackC2:[0.2,1.0,0.9],rail:[1,0.7,1],trackW:6.8,baseY:0.6,yAmp:2.2,car:[1.0,0.3,0.9],fog:[0.06,0.02,0.10],ground:true},
  XMAS:{bg:()=>`radial-gradient(1000px 600px at 60% -10%, #0e1b3a 0%, transparent 52%), linear-gradient(180deg,#081226,#0a1a33)`,trackC1:[0.0,0.9,0.3],trackC2:[1.0,0.1,0.1],rail:[1,1,1],trackW:7.0,baseY:0.6,yAmp:0.9,car:[0.9,0.1,0.1],fog:[0.03,0.05,0.08],ground:true},
  NEON:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #103b6b 0%, transparent 52%), linear-gradient(180deg,#081022,#0a0f28)`,trackC1:[0.2,0.9,1.0],trackC2:[1.0,0.5,0.2],rail:[0.8,1,1],trackW:6.0,baseY:1.0,yAmp:3.2,car:[0.2,0.9,1.0],fog:[0.02,0.05,0.12],ground:true},
  VOLCANO:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #3b0f0f 0%, transparent 52%), linear-gradient(180deg,#140606,#230a0a)`,trackC1:[1.0,0.5,0.0],trackC2:[0.9,0.2,0.1],rail:[1,0.85,0.7],trackW:7.2,baseY:0.4,yAmp:1.8,car:[1.0,0.4,0.05],fog:[0.06,0.02,0.02],ground:true}
};
document.body.style.background=THEMES[cfg.theme].bg();

/* ===== Geometry helpers ===== */
const makeGeo=()=>({pos:[],col:[],glow:[]});
const pushTri=(o,a,b,c,d,e,f,g,h,i,C,G)=>{o.pos.push(a,b,c,d,e,f,g,h,i); o.col.push(C[0],C[1],C[2],C[0],C[1],C[2],C[0],C[1],C[2]); o.glow.push(G,G,G)};
const pushQuad=(o,a,b,c,d,e,f,g,h,i,j,k,l,C,G)=>{pushTri(o,a,b,c,d,e,f,g,h,i,C,G); pushTri(o,a,b,c,g,h,i,j,k,l,C,G)};
const pushBox=(o,cx,cy,cz,sx,sy,sz,ct,cs,g=0.25)=>{const x=sx/2,y=sy/2,z=sz/2;
  pushQuad(o,cx-x,cy+y,cz-z,cx+x,cy+y,cz-z,cx+x,cy+y,cz+z,cx-x,cy+y,cz+z,ct,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx+x,cy-y,cz+z,cx+x,cy-y,cz-z,cx-x,cy-y,cz-z,cs,g*0.85);
  pushQuad(o,cx-x,cy-y,cz-z,cx-x,cy+y,cz-z,cx-x,cy+y,cz+z,cx-x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz+z,cx+x,cy+y,cz+z,cx+x,cy+y,cz-z,cx+x,cy-y,cz-z,cs,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx-x,cy+y,cz+z,cx+x,cy+y,cz+z,cx+x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz-z,cx+x,cy+y,cz-z,cx-x,cy+y,cz-z,cx-x,cy-y,cz-z,cs,g);
};

/* ===== Track ===== */
let samples=1600, trackW=6, CP=[], centerline=[], bufRibbon=null, bufRail=null, verts=0, railVerts=0, trackMaxR=140;
const WORLD_UP=[0,1,0];
const getCenter=i=>{const N=samples; const idx=((i%N)+N)%N; return [centerline[idx*3],centerline[idx*3+1],centerline[idx*3+2]]};
function catmull(p0,p1,p2,p3,t){const t2=t*t,t3=t2*t;
  return [
    0.5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
    0.5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3),
    0.5*((2*p1[2])+(-p0[2]+p2[2])*t+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3)
  ];
}
function catmullTangent(p0,p1,p2,p3,t){const t2=t*t;
  return [
    0.5*((-p0[0]+p2[0])+2*(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t+3*(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t2),
    0.5*((-p0[1]+p2[1])+2*(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t+3*(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t2),
    0.5*((-p0[2]+p2[2])+2*(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t+3*(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t2)
  ];
}
function basisAt(i){const p0=getCenter(i), p1=getCenter(i+1); const T=norm(sub(p1,p0)); let R=norm(cross(T,WORLD_UP)); if(!isFinite(R[0])) R=[1,0,0]; const B=norm(cross(R,T)); return {T,R,B};}
function computeTrackMaxR(){ let m=0; for(let i=0;i<centerline.length;i+=3){m=Math.max(m,Math.hypot(centerline[i],centerline[i+2]));} trackMaxR=m;}
function genCP(seed,shape,yAmp,baseY){const rng=mulberry32(seed|0),rand=(a,b)=>a+(b-a)*rng(); let arr=[],N=48,R=140,ph=rand(0,Math.PI*2);
  if(shape==='RANDOM'){const list=['OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY']; shape=list[(rng()*list.length)|0];}
  for(let i=0;i<N;i++){const t=i/N*2*Math.PI; let x=0,z=0;
    if(shape==='OVAL'){const rx=R*(1.2+0.22*Math.sin(3*t+ph)), rz=R*(0.9+0.18*Math.sin(2*t+ph)); x=rx*Math.cos(t); z=rz*Math.sin(t);}
    else if(shape==='FIG8'){x=R*0.95*Math.sin(2*t); z=R*0.75*Math.sin(t); x+=20*Math.sin(3*t+ph);}
    else if(shape==='CLOVER'){const rad=R*(1+0.35*Math.sin(3*t+ph)); x=rad*Math.cos(t); z=rad*Math.sin(t);}
    else if(shape==='S_BEND'){x=R*1.15*Math.cos(t)+34*Math.sin(2*t); z=R*0.85*Math.sin(t);}
    else if(shape==='ISLAND'){const rad2=R*(0.92+0.22*Math.sin(3*t+ph))*(0.94+rand(0,0.18)); x=rad2*Math.cos(t); z=rad2*Math.sin(t);}
    else if(shape==='LEMNISCATE'){const a=R*0.95,s=Math.sin(t),c=Math.cos(t); x=(a*Math.sqrt(2)*c)/(1+s*s); z=(a*Math.sqrt(2)*c*s)/(1+s*s);}
    else if(shape==='WAVY'){const rx2=R*(1+0.28*Math.sin(4*t+ph)), rz2=R*(1+0.28*Math.cos(3*t+ph)); x=rx2*Math.cos(t); z=rz2*Math.sin(t);}
    const y=baseY+rand(-yAmp,yAmp)*(0.6+0.4*Math.sin(2*t+ph)); arr.push([x,y,z]); }
  arr.push(arr[0],arr[1],arr[2]); return arr;
}

/* ===== Buffers ===== */
let envBuf=null,envVerts=0,propBuf=null,propVerts=0,geoBuf=null,geoVerts=0,charBuf=null,charVerts=0,tunnelBuf=null,tunnelVerts=0,snowBuf=null,snowVerts=0,ashBuf=null,ashVerts=0,centerBuf=null,centerVerts=0,tracksideBuf=null,tracksideVerts=0, skyBuf=null, skyVerts=0;

/* ===== Env build ===== */
function buildTrack(theme){
  const T=THEMES[theme], seed2=(cfg.seed^hashStr(theme)^hashStr(cfg.shape))>>>0;
  trackW=T.trackW*2.0;
  CP=genCP(seed2,cfg.shape,T.yAmp,T.baseY); centerline=[]; verts=0; railVerts=0;
  const p=[],c=[],g=[], rp=[],rc=[],rg=[]; const Ls=CP.length-3,maxSeg=Ls-1e-6;
  for(let i=0;i<samples;i++){
    const seg=i/(samples-1)*maxSeg,j=Math.floor(seg),t=seg-j;
    const P=catmull(CP[j],CP[j+1],CP[j+2],CP[j+3],t), d=norm(catmullTangent(CP[j],CP[j+1],CP[j+2],CP[j+3],t));
    let R=norm(cross(d,WORLD_UP)); if(!isFinite(R[0])) R=[1,0,0];
    centerline.push(P[0],P[1],P[2]);
    if(i<samples-1){
      const L=add(P,scale(R,-trackW*0.5)), Rr=add(P,scale(R,trackW*0.5));
      p.push(L[0],L[1],L[2], Rr[0],Rr[1],Rr[2]); c.push(...T.trackC1, ...T.trackC2); g.push(0.55,0.55); verts+=2;
      rp.push(L[0],L[1]+0.12,L[2], Rr[0],Rr[1]+0.12,Rr[2]); rc.push(...T.rail, ...T.rail); rg.push(1.4,1.4); railVerts+=2;
    }
  }
  gl.clearColor(T.fog[0],T.fog[1],T.fog[2],1);
  bufRibbon={pos:makeBuffer(new Float32Array(p),3),col:makeBuffer(new Float32Array(c),3),glow:makeBuffer(new Float32Array(g),1)};
  bufRail  ={pos:makeBuffer(new Float32Array(rp),3),col:makeBuffer(new Float32Array(rc),3),glow:makeBuffer(new Float32Array(rg),1)};
  computeTrackMaxR();
  buildEnv(theme,seed2); buildCharacters(theme,seed2); buildTunnels(theme,seed2); buildCenterpiece(theme,seed2); buildTrackside(theme,seed2); buildSky(theme,seed2);
  buildBoost(seed2);
}

function buildEnv(theme,seed2){
  envBuf=propBuf=geoBuf=snowBuf=ashBuf=null; envVerts=propVerts=geoVerts=snowVerts=ashVerts=0;
  const pts=[],cols=[],glows=[], p2=[],c2=[],g2=[], GEO=makeGeo();
  const rng=mulberry32(seed2), t=THEMES[theme], ringR=trackMaxR+trackW*2.8, groundY=0;
  const pushP=(x,y,z,c,g)=>{pts.push(x,y,z); cols.push(c[0],c[1],c[2]); glows.push(g);}
  const push2=(x,y,z,c,g)=>{p2.push(x,y,z); c2.push(c[0],c[1],c[2]); g2.push(g);}
  if(t.ground){
    const rad=ringR+140, step=10;
    const baseCol=(theme==='XMAS')?[0.95,0.98,1]:(theme==='VOLCANO')?[0.25,0.08,0.06]:(theme==='CYBERPUNK')?[0.08,0.08,0.12]:[0.06,0.08,0.12];
    for(let x=-rad;x<rad;x+=step) for(let z=-rad;z<rad;z+=step){
      if(Math.hypot(x,z)<ringR-12) continue;
      const c0=[baseCol[0]*(0.94+0.12*rng()), baseCol[1]*(0.94+0.12*rng()), baseCol[2]*(0.94+0.12*rng())];
      pushQuad(GEO,x,groundY,z, x+step,groundY,z, x+step,groundY,z+step, x,groundY,z+step, c0,0.13);
    }
  }
  if(theme==='SPACE'){
    const rngS=mulberry32(seed2^0x55aa);
    const starCount= cfg.mobile?1600:3000;
    for(let i=0;i<starCount;i++){const rr=ringR+20+rngS()*420,a=rngS()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=(rngS()*2-1)*320+90; pushP(rx,ry,rz,[0.82+rngS()*0.18,0.88+rngS()*0.12,1],0.06);}
    for(let j=0;j<180;j++){const rr2=ringR+40+rng()*380,a2=rng()*Math.PI*2; push2(Math.cos(a2)*rr2,(rng()*2-1)*260+60,Math.sin(a2)*rr2,[0.9,0.95,1],0.9);}
  }else if(theme==='CYBERPUNK'){
    for(let i=0;i<600;i++){const r=ringR+12+rng()*300,a=rng()*Math.PI*2,xx=Math.cos(a)*r,zz=Math.sin(a)*r,sy=16+rng()*90;
      pushBox(GEO,xx,sy/2,zz, 5+rng()*26, sy, 5+rng()*26, [0.2,0.9,0.9],[0.6,0.2,1],0.4); }
    const moonR=18, moonX=Math.cos(0.7)*(ringR+260), moonZ=Math.sin(0.7)*(ringR+260), moonY=140;
    const sphere=(cx,cy,cz,R,lat,lon,col,glw)=>{for(let a=0;a<lat;a++){const v0=a/lat*Math.PI, v1=(a+1)/lat*Math.PI; for(let b=0;b<lon;b++){const u0=b/lon*2*Math.PI,u1=(b+1)/lon*2*Math.PI;
      const p=(v,u)=>[cx+R*Math.sin(v)*Math.cos(u), cy+R*Math.cos(v), cz+R*Math.sin(v)*Math.sin(u)];
      const A=p(v0,u0),B=p(v0,u1),C=p(v1,u1),D=p(v1,u0); pushQuad(GEO,A[0],A[1],A[2],B[0],B[1],B[2],C[0],C[1],C[2],D[0],D[1],D[2],col,glw); }}};
    sphere(moonX,moonY,moonZ,moonR,12,20,[0.95,0.95,1.0],0.2);
    for(let i=0;i<1200;i++){const rr=ringR+220+rng()*420,a=rng()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=80+rng()*260; pushP(rx,ry,rz,[0.7,0.8,1],0.05);}
  }else if(theme==='XMAS'){
    const sPos=[],sCol=[],sGlow=[]; const snowCount= cfg.mobile?2600:5200;
    for(let i=0;i<snowCount;i++){const rr=ringR+8+rng()*300, aa=rng()*Math.PI*2, rx=Math.cos(aa)*rr, rz=Math.sin(aa)*rr, ry=80+rng()*260; sPos.push(rx,ry,rz); sCol.push(1,1,1); sGlow.push(-0.7);}
    snowBuf={pos:makeBuffer(new Float32Array(sPos),3), col:makeBuffer(new Float32Array(sCol),3), glow:makeBuffer(new Float32Array(sGlow),1)}; snowVerts=sPos.length/3;
    for(let i=0;i<480;i++){const r=ringR+14+rng()*240,a=rng()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r;
      if(rng()<0.55){const sx=6+rng()*6,sz=6+rng()*6,sy=4+rng()*3; pushBox(GEO,x,sy/2,z, sx,sy,sz,[1,0.2,0.2],[0.9,0.9,0.95],0.35); pushBox(GEO,x,sy+1.4,z, sx*0.9,1.4,sz*0.9,[0.9,0.1,0.1],[0.9,0.1,0.1],0.4);}
      else { pushBox(GEO,x,1.3,z, 1.0,3.0,1.0,[0.5,0.3,0.2],[0.5,0.3,0.2]); pushBox(GEO,x,4.0,z, 3.8,2.2,3.8,[0.1,0.6,0.2],[0.1,0.5,0.2]); pushBox(GEO,x,6.5,z, 3.0,2.0,3.0,[0.1,0.7,0.2],[0.1,0.6,0.2]); pushBox(GEO,x,8.9,z, 2.4,1.8,2.4,[0.1,0.8,0.2],[0.1,0.7,0.2]); }
    }
  }else if(theme==='NEON'){
    const baseR=ringR+18; for(let ii=0;ii<28;ii++){const r=baseR+ii*10; for(let a=0;a<Math.PI;a+=Math.PI/28){const x=Math.cos(a)*r,y=Math.sin(a)*32+6,z=0; pushQuad(GEO,x,y,z, x+1.6,y,z, x+1.6,y+1.6,z, x,y+1.6,z, [0.2,0.8,1],0.65);}}
  }else if(theme==='VOLCANO'){
    for(let i=0;i<420;i++){const r=ringR+8+rng()*320,a=rng()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r,sy=9+rng()*40; pushBox(GEO,x,sy/2,z, 5,sy,5,[1,0.5,0.2],[1,0.35,0.15],0.44);}
    const aPos=[],aCol=[],aGlow=[]; const ashCount= cfg.mobile?2400:5200;
    for(let i=0;i<ashCount;i++){const rr=ringR+20+rng()*320,a=rng()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=120+rng()*220; aPos.push(rx,ry,rz); aCol.push(0.6,0.35,0.25); aGlow.push(-0.25); }
    ashBuf={pos:makeBuffer(new Float32Array(aPos),3), col:makeBuffer(new Float32Array(aCol),3), glow:makeBuffer(new Float32Array(aGlow),1)}; ashVerts=aPos.length/3;
  }
  if(pts.length) envBuf={pos:makeBuffer(new Float32Array(pts),3), col:makeBuffer(new Float32Array(cols),3), glow:makeBuffer(new Float32Array(glows),1)}, envVerts=pts.length/3;
  if(p2.length)  propBuf={pos:makeBuffer(new Float32Array(p2),3), col:makeBuffer(new Float32Array(c2),3), glow:makeBuffer(new Float32Array(g2),1)}, propVerts=p2.length/3;
  if(GEO.pos.length) geoBuf={pos:makeBuffer(new Float32Array(GEO.pos),3), col:makeBuffer(new Float32Array(GEO.col),3), glow:makeBuffer(new Float32Array(GEO.glow),1)}, geoVerts=GEO.pos.length/3;
}

/* Centerpiece */
function buildCenterpiece(theme,seed2){
  const G=makeGeo();
  if(theme==='XMAS'){ const s=12; pushBox(G,0,s*0.7,0, s, s, s,[1,1,1],[1,1,1],0.8); pushBox(G,0,s*1.6,0, s*0.8, s*0.8, s*0.8,[1,1,1],[1,1,1],0.85); pushBox(G,0,s*2.2,0, s*0.6, s*0.6, s*0.6,[1,1,1],[1,1,1],0.9); }
  else if(theme==='NEON'){ const h=60; pushBox(G,0,h*0.5,0, 10,h,10,[0.2,0.8,1],[0.15,0.6,1],0.9); }
  else if(theme==='CYBERPUNK'){ const h=80; pushBox(G,0,h*0.5,0, 8,h,8,[0.2,0.9,0.9],[0.6,0.2,1],0.9); }
  else if(theme==='VOLCANO'){ for(let i=0;i<8;i++){ const y=4+i*4, s=28-i*2; pushBox(G,0,y,0, s,4,s,[0.6,0.2,0.1],[0.5,0.15,0.08],0.4); } }
  else if(theme==='SPACE'){ const s=24; for(let a=0;a<14;a++){for(let b=0;b<18;b++){const v0=a/14*Math.PI,u0=b/18*2*Math.PI,v1=(a+1)/14*Math.PI,u1=(b+1)/18*2*Math.PI;
    const p=(v,u)=>[s*Math.sin(v)*Math.cos(u), s*Math.cos(v), s*Math.sin(v)*Math.sin(u)];
    const A=p(v0,u0),B=p(v0,u1),C=p(v1,u1),D=p(v1,u0); pushQuad(G,A[0],A[1],A[2],B[0],B[1],B[2],C[0],C[1],C[2],D[0],D[1],D[2],[0.55,0.8,1],0.6);
  }}}
  centerBuf=G.pos.length?{pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}:null;
  centerVerts=G.pos.length/3;
}

/* Trackside deco */
function buildTrackside(theme,seed2){
  const G=makeGeo(), rng=mulberry32(seed2^0x777), kinds=(theme==='XMAS')?['lamp','tree','banner']:(theme==='CYBERPUNK'||theme==='NEON')?['lamp','banner']:(theme==='VOLCANO')?['rock','lamp']:['lamp','banner'];
  const place=(i,off,kind)=>{const C=getCenter(i), B=basisAt(i), base=add(C, scale(B.R, off)), h=C[1];
    if(kind==='lamp'){ pushBox(G,base[0],h+3,base[2],0.5,6,0.5,[1,1,1],[1,1,1],0.8); pushBox(G,base[0],h+6.2,base[2],1.6,0.4,1.6,[0.8,1,1],[0.8,1,1],1.0); }
    else if(kind==='banner'){ pushBox(G,base[0],h+2.6,base[2],0.3,5.2,0.3,[1,1,1],[1,1,1],0.7); pushBox(G,base[0]+1.6,h+4.0,base[2],3.8,1.6,0.2,[1,0.5,1],[1,0.5,1],0.9); }
    else if(kind==='rock'){ pushBox(G,base[0],h+0.9,base[2],1.6,1.6,1.6,[0.5,0.45,0.5],[0.4,0.35,0.45],0.2); }
    else if(kind==='tree'){ pushBox(G,base[0],h+1.2,base[2],0.9,2.4,0.9,[0.45,0.3,0.2],[0.45,0.3,0.2],0.2); pushBox(G,base[0],h+3.2,base[2],2.2,2.2,2.2,[0.12,0.65,0.2],[0.1,0.55,0.2],0.4); }
  };
  const margin=trackW*0.8; const step= cfg.mobile?22:14;
  for(let i=30;i<samples-30;i+=Math.floor(step+(rng()*step))){
    const off=(Math.random()<0.5?-1:1)*(margin+1.8+Math.random()*3.5);
    const kind=kinds[(Math.random()*kinds.length)|0];
    place(i,off,kind);
  }
  tracksideBuf=G.pos.length?{pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}:null;
  tracksideVerts=G.pos.length/3;
}

/* Characters */
function buildCharacters(theme,seed2){
  const G=makeGeo(), rng=mulberry32(seed2^0xABCD), ringR=trackMaxR+trackW*2.4;
  const bot=(x,y,z,s,c1,c2)=>{pushBox(G,x,y+2*s,z,1.2*s,1.8*s,0.8*s,c1,c1,0.4); pushBox(G,x,y+3.2*s,z,0.9*s,0.9*s,0.9*s,c2,c2,0.7);};
  const snow=(x,y,z,s)=>{pushBox(G,x,y+0.7*s,z,1.0*s,1.0*s,1.0*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+1.6*s,z,0.8*s,0.8*s,0.8*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+2.3*s,z,0.6*s,0.6*s,0.6*s,[1,1,1],[1,1,1],0.9);};
  const dancer=(x,y,z,s,c)=>{pushBox(G,x,y+1.6*s,z,0.9*s,1.6*s,0.6*s,c,c,0.85); pushBox(G,x,y+2.6*s,z,0.6*s,0.6*s,0.6*s,c,c,0.9);};
  const golem=(x,y,z,s)=>{pushBox(G,x,y+1.6*s,z,1.2*s,1.6*s,1.0*s,[1,0.45,0.15],[1,0.35,0.12],0.85); pushBox(G,x,y+2.6*s,z,1.0*s,0.8*s,1.0*s,[1,0.5,0.2],[1,0.35,0.15],0.85);};
  const astro=(x,y,z,s)=>{pushBox(G,x,y+1.9*s,z,1.0*s,1.6*s,0.8*s,[0.9,0.95,1],[0.8,0.9,1],0.7); pushBox(G,x,y+2.8*s,z,0.8*s,0.8*s,0.8*s,[0.6,0.8,1],[0.6,0.8,1],0.9);};
  const ship=(x,y,z,s)=>{pushBox(G,x,y+0.6*s,z,2.2*s,0.6*s,1.2*s,[0.7,0.9,1],[0.5,0.7,1],0.9); pushBox(G,x,y+1.3*s,z,1.0*s,0.5*s,0.5*s,[0.9,1,1],[0.7,0.9,1],0.8);};
  const count= cfg.mobile?160:260;
  for(let i=0;i<count;i++){const r=ringR+14+rng()*140,a=rng()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r,s=0.9+rng()*0.9;
    if(theme==='SPACE'){ if(rng()<0.4) astro(x,0,z,s); else ship(x,2,z,0.7*s); }
    else if(theme==='CYBERPUNK') bot(x,0,z,s,[0.2,0.9,0.9],[1,0.3,0.9]);
    else if(theme==='XMAS') snow(x,0,z,1.2*s);
    else if(theme==='NEON') dancer(x,0,z,s,[0.3,1,1]);
    else if(theme==='VOLCANO') golem(x,0,z,s);
  }
  charBuf = G.pos.length?{pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}:null;
  charVerts=G.pos.length/3;
}

/* Sky special (NEON RUN sign) */
function buildSky(theme,seed2){
  if(theme!=='NEON'){ skyBuf=null; skyVerts=0; return; }
  const G=makeGeo();
  const glyph=(_x,_y,_z,w,h,strokes)=>{
    const thick=1.6;
    const bar=(x,y,z,wx,hx)=>{ pushBox(G,_x+x,_y+y,_z+z, wx, thick, hx, [0.2,0.9,1],[0.2,0.9,1],1.2); };
    strokes.forEach(s=>bar(s[0],s[1],0,s[2],s[3]));
  };
  const y=120, z=-(trackMaxR+260);
  glyph(-40,y,z,12,30,[[-14,0,4,40],[0,18,26,4],[10,32,4,16],[10,10,4,16],[0,0,26,4]]);
  glyph(0,y,z,12,30,[[-12,0,4,40],[12,0,4,40],[0,-14,28,4]]);
  glyph(38,y,z,12,30,[[-12,0,4,40],[12,0,4,40],[0,0,4,44]]);
  skyBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)};
  skyVerts=G.pos.length/3;
}

/* Tunnels */
function buildTunnels(theme,seed2){
  const G=makeGeo(), rng=mulberry32(seed2^0xFACE), T=THEMES[theme];
  const tube=(ci,rad,len,radial=40,axial=12)=>{
    const C0=getCenter(ci), C1=getCenter(ci+Math.floor(len));
    const base=basisAt(ci), R=base.R,B=base.B;
    for(let j=0;j<axial;j++){
      const s0=j/axial, s1=(j+1)/axial, C=[C0[0]*(1-s0)+C1[0]*s0, C0[1]*(1-s0)+C1[1]*s0, C0[2]*(1-s0)+C1[2]*s0], D=[C0[0]*(1-s1)+C1[0]*s1, C0[1]*(1-s1)+C1[1]*s1, C0[2]*(1-s1)+C1[2]*s1];
      for(let i=0;i<radial;i++){const t0=i/radial*2*Math.PI,t1=(i+1)/radial*2*Math.PI;
        const a0=add(C,add(scale(R,Math.cos(t0)*rad),scale(B,Math.sin(t0)*rad)));
        const a1=add(C,add(scale(R,Math.cos(t1)*rad),scale(B,Math.sin(t1)*rad)));
        const b1=add(D,add(scale(R,Math.cos(t1)*rad),scale(B,Math.sin(t1)*rad)));
        const b0=add(D,add(scale(R,Math.cos(t0)*rad),scale(B,Math.sin(t0)*rad)));
        pushQuad(G,a0[0],a0[1],a0[2], a1[0],a1[1],a1[2], b1[0],b1[1],b1[2], b0[0],b0[1],b0[2], T.trackC2, 0.8);
      }
    }
  };
  const tubes= cfg.mobile?3:6;
  for(let k=0;k<tubes;k++){const i=80+((rng()*(samples-240))|0); tube(i,Math.max(4.0,trackW*1.7), 28+((rng()*22)|0), 46, 12);}
  tunnelBuf = G.pos.length?{pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}:null;
  tunnelVerts=G.pos.length/3;
}

/* Boost pads */
let boostBuf=null,boostVerts=0,boosts=[];
function buildBoost(seed2){
  boosts=[]; const pos=[],col=[],glow=[]; const rng=mulberry32(seed2^0x999);
  for(let i=120;i<samples;i+=Math.floor(160+rng()*120)){const C=getCenter(i), p=[C[0],C[1]+0.2,C[2]]; boosts.push({i,pos:p,r:2.2}); pos.push(p[0],p[1],p[2]); col.push(0.3,1,0.8); glow.push(1.5);}
  boostBuf={pos:makeBuffer(new Float32Array(pos),3), col:makeBuffer(new Float32Array(col),3), glow:makeBuffer(new Float32Array(glow),1)}; boostVerts=pos.length/3;
}

/* ===== Shader ===== */
const VS=`
attribute vec3 aPos; attribute vec3 aCol; attribute float aGlow;
uniform mat4 uVP; uniform float uTime;
varying vec3 vCol; varying float vGlow;
float n2(vec2 p){return fract(sin(dot(p, vec2(12.9898,78.233)))*43758.5453);}
void main(){
  vCol=aCol; float g=aGlow; vec3 p=aPos;
  if(g<0.0){
    float n=n2(p.xz);
    float speed = mix(0.05, 0.22, n);
    if(g<-0.3) speed*=0.7;
    float ph=fract(n*7.13);
    float t=fract(uTime*speed+ph);
    float fall = 200.0 + 180.0*n;
    p.y = p.y - t*fall;
    g = 0.45 + 0.35*n;
  }
  vGlow=g;
  gl_Position = uVP * vec4(p,1.0);
  gl_PointSize = 1.0 + 1.8*clamp(vGlow,0.0,2.0);
}`;
const FS=`precision mediump float; varying vec3 vCol; varying float vGlow; void main(){ float a=min(0.08+vGlow*0.9,1.0); gl_FragColor=vec4(vCol,a);} `;
const program=prog(VS,FS);
gl.useProgram(program);
const loc={aPos:gl.getAttribLocation(program,'aPos'),aCol:gl.getAttribLocation(program,'aCol'),aGlow:gl.getAttribLocation(program,'aGlow'),uVP:gl.getUniformLocation(program,'uVP'),uTime:gl.getUniformLocation(program,'uTime')};
function drawBuf(buf,count,mode){ if(!buf||!count) return; bind(buf.pos,loc.aPos); bind(buf.col,loc.aCol); bind(buf.glow,loc.aGlow); gl.drawArrays(mode,0,count); }

/* ===== Car Meshes ===== */
function makeCarGeom(col,glow=1.0,beacon=false){
  const hw=0.72,hh=0.26,hl=1.28,nose=0.55,c=col;
  const P=[-hw,hh,-hl, hw,hh,-hl, 0,hh+nose,-hl*0.2, -hw,hh,hl*0.2, 0,hh+nose,-hl*0.2, hw,hh,hl*0.2, -hw,-hh,-hl, -hw,hh,-hl, -hw,hh,hl*0.2, -hw,-hh,-hl, -hw,hh,hl*0.2, -hw,-hh,hl*0.2, hw,-hh,-hl, hw,hh,hl*0.2, hw,hh,-hl, hw,-hh,-hl, hw,-hh,hl*0.2, hw,hh,hl*0.2, -hw,-hh,hl*0.2, hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,-hl];
  const cols=[], glowArr=new Float32Array(P.length/3).fill(glow);
  for(let i=0;i<P.length/3;i++) cols.push(c[0],c[1],c[2]);
  const pos=makeBuffer(new Float32Array(P),3), colB=makeBuffer(new Float32Array(cols),3), glowB=makeBuffer(new Float32Array(glowArr),1);
  return {pos:pos,col:colB,glow:glowB,verts:P.length/3};
}
const aiPalette=[[1.00,0.40,0.25],[0.25,1.00,0.75],[1.00,0.85,0.30],[0.35,0.70,1.00]];
let geomP1=null, geomP2=null, geomAI=[];

/* ===== Camera (strictly fixed behind) ===== */
function makeCam(targetCar){ return {
  eye:[0,3.6,-11], at:[0,1.0,5], up:[0,1,0], fovBase:66*(Math.PI/180), fov:66*(Math.PI/180),
  update(dt){ const w=targetCar.world(); const speed=Math.min(120,targetCar.v); const k=1-Math.pow(0.0001,dt*10);
    const h=3.6-0.5*targetCar.shake, lead=6.2-0.8*targetCar.shake, back=11.0-1.1*targetCar.shake;
    const a=[w.pos[0]+w.T[0]*lead, w.pos[1]+0.9, w.pos[2]+w.T[2]*lead];
    const e=[a[0]-w.T[0]*back, a[1]+h, a[2]-w.T[2]*back];
    this.eye=[lerp(this.eye[0],e[0],k), lerp(this.eye[1],e[1],k), lerp(this.eye[2],e[2],k)];
    this.at=[lerp(this.at[0],a[0],k), lerp(this.at[1],a[1],k), lerp(this.at[2],a[2],k)];
    this.up=[0,1,0]; this.fov=this.fovBase+(speed*0.6)*(Math.PI/180);
  },
  snap(){ const w=targetCar.world(); const a=[w.pos[0]+w.T[0]*6.2,w.pos[1]+0.9,w.pos[2]+w.T[2]*6.2]; const e=[a[0]-w.T[0]*11.0,a[1]+3.6,a[2]-w.T[2]*11.0]; this.at=a.slice(0); this.eye=e.slice(0); this.up=[0,1,0]; },
  VP(aspect){ const V=M.look(this.eye,this.at,this.up); const P=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]; const f=1/Math.tan(this.fov/2), near=0.1, far=1600, nf=1/(near-far); P[0]=f/(aspect>0?aspect:1); P[5]=f; P[10]=(far+near)*nf; P[11]=-1; P[14]=(2*far*near)*nf; P[15]=0; return M.mul(P,V); }
};}

/* ===== Input ===== */
const mkInput=()=>({L:false,R:false,ACC:false,BR:false,DR:false,stickX:0});
const inP1=mkInput(), inP2=mkInput();
addEventListener('keydown',e=>{
  if(e.repeat) return;
  const stop=['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Slash','KeyW','KeyA','KeyS','KeyD','Space','KeyR','KeyP']; if(stop.includes(e.code)) e.preventDefault();
  if(e.code==='KeyA') inP1.L=true; if(e.code==='KeyD') inP1.R=true; if(e.code==='KeyW') inP1.ACC=true; if(e.code==='KeyS') inP1.BR=true; if(e.code==='Space') inP1.DR=true;
  if(e.code==='ArrowLeft') inP2.L=true; if(e.code==='ArrowRight') inP2.R=true; if(e.code==='ArrowUp') inP2.ACC=true; if(e.code==='ArrowDown') inP2.BR=true; if(e.code==='Slash') inP2.DR=true;
  if(e.key==='p'||e.key==='P') togglePause(); if(e.key==='r'||e.key==='R') reset();
});
addEventListener('keyup',e=>{
  if(e.code==='KeyA') inP1.L=false; if(e.code==='KeyD') inP1.R=false; if(e.code==='KeyW') inP1.ACC=false; if(e.code==='KeyS') inP1.BR=false; if(e.code==='Space') inP1.DR=false;
  if(e.code==='ArrowLeft') inP2.L=false; if(e.code==='ArrowRight') inP2.R=false; if(e.code==='ArrowUp') inP2.ACC=false; if(e.code==='ArrowDown') inP2.BR=false; if(e.code==='Slash') inP2.DR=false;
});

/* ===== Mobile pad ===== */
const pad=document.getElementById('pad');
function bindPad(){
  pad.querySelectorAll('.pbtn').forEach(btn=>{
    const act=btn.getAttribute('data-act');
    const set=(v)=>{ inP1[act]=v; };
    const on=(e)=>{e.preventDefault(); set(true);};
    const off=(e)=>{e.preventDefault(); set(false);};
    btn.addEventListener('pointerdown',on); btn.addEventListener('pointerup',off); btn.addEventListener('pointerleave',off); btn.addEventListener('pointercancel',off);
    btn.addEventListener('touchstart',on,{passive:false}); btn.addEventListener('touchend',off); btn.addEventListener('touchcancel',off);
  });
}
bindPad();

/* ===== Car & AI ===== */
function makeCar(inputRef){ return {
  s:0,v:0,off:0,offV:0,steer:0,drift:0,shake:0,lap:0,finished:false,finishTime:null,lapStart:null,
  update(dt){
    const steerRaw=(inputRef.L?-1:0)+(inputRef.R?1:0);
    const ACC=inputRef.ACC, BR=inputRef.BR, DR=inputRef.DR;
    const speedScale=0.9;
    const maxV=120*speedScale, acc=ACC?(DR?64:52)*speedScale:0, dec=BR?90*speedScale:12*speedScale;
    this.v = acc>0 ? Math.min(maxV, this.v+acc*dt) : Math.max(0,this.v-dec*dt);
    const smooth=1-Math.pow(0.0001,dt*28); this.steer += ((steerRaw||0)-this.steer)*smooth;
    const latBase=(7+this.v*0.6)*(DR?1.2:0.6);
    const targetOffV=this.steer*latBase;
    const f=1-Math.pow(0.0001,dt*(DR?16:22)); this.offV+=(targetOffV-this.offV)*f;
    const spring=-this.off*(DR?0.7:1.2); this.offV+=spring*dt; this.offV*=(DR?0.90:0.94);
    this.off=clamp(this.off+this.offV*dt,-trackW*0.35,trackW*0.35);
    const prevS=this.s; this.s=(this.s+this.v*dt)%samples;
    const slip=Math.abs(this.offV)/(trackW*0.8); this.v*=(1-clamp(slip*(DR?0.024:0.05),0,0.12));
    const gain=Math.max(0,(Math.abs(this.offV)*0.03+Math.abs(this.steer)*this.v*0.014)*(DR?2.0:1.0)); this.drift=Math.max(0,this.drift+(gain-0.36*dt));
    if(BR) this.shake=Math.min(this.shake+6*dt,1); else this.shake=Math.max(0,this.shake-2.6*dt);
    if(this.lapStart==null) this.lapStart=performance.now();
    if(prevS>this.s && !this.finished){
      this.lap++; setHUD('uiLap', `${Math.min(this.lap, raceLaps)}/${raceLaps}`);
      if(this.lap>=1){ const now=performance.now(), lapSec=(now-this.lapStart)/1000; this.lapStart=now; if(cfg.best==null||lapSec<cfg.best){ cfg.best=lapSec; store.set(cfg); setHUD('uiBest', cfg.best.toFixed(2)+'s'); } }
      if(this.lap>=raceLaps){ this.finished=true; this.finishTime=performance.now()-raceStartTime; results.push({name: this===car1?'P1':(this===car2?'P2':'AI'), time:this.finishTime}); if(this===car1|| (cfg.twoP && this===car2)) showResults(); }
    }
    boostPads(this);
  },
  world(){ const i=(this.s|0), t=this.s-i; const p=getCenter(i), n=getCenter(i+1);
    const pos=[lerp(p[0],n[0],t), lerp(p[1],n[1],t), lerp(p[2],n[2],t)]; const B=basisAt(i);
    return {pos:add(pos,scale(B.R,this.off)), T:B.T, R:B.R, B:B.B}; }
};}
function makeAI(seed,idx){
  const rng=mulberry32(seed+idx*101);
  return { s:30+rng()*50, v:0, off:(rng()*2-1)*trackW*0.2, offV:0, lap:0, finished:false, finishTime:null,
    update(dt){
      if(this.finished) return;
      const aim=0, diff=aim-this.off;
      const steer=clamp(diff*0.6 + this.offV*-0.05 + Math.sin(this.s*0.01+idx)*0.2, -1, 1);
      const speedScale=0.9; const maxV=112*speedScale, targetV=maxV*(0.86+0.12*Math.sin((this.s|0)*0.03+idx)); this.v+=clamp(targetV-this.v,-34*dt,42*dt);
      const lat=(6+this.v*0.5), targetOffV=steer*lat; this.offV+=(targetOffV-this.offV)*(1-Math.pow(0.0001,dt*20));
      this.offV+=(-this.off*1.0)*dt; this.offV*=0.94; this.off=clamp(this.off+this.offV*dt,-trackW*0.35,trackW*0.35);
      const prevS=this.s; this.s=(this.s+this.v*dt)%samples;
      if(prevS>this.s){ this.lap++; if(this.lap>=raceLaps){ this.finished=true; this.finishTime=performance.now()-raceStartTime; results.push({name:'AI', time:this.finishTime}); if(playerFinished()) showResults(); } }
    },
    world(){ const i=(this.s|0), t=this.s-i; const p=getCenter(i), n=getCenter(i+1); const pos=[lerp(p[0],n[0],t), lerp(p[1],n[1],t), lerp(p[2],n[2],t)]; const B=basisAt(i); return {pos:add(pos,scale(B.R,this.off)), T:B.T, R:B.R, B:B.B}; }
  };
}
let car1,car2,aiCars=[];
function ensureAI(seed){ const need=Math.max(0,Math.min(4,cfg.aiCount)); while(aiCars.length<need) aiCars.push(makeAI(seed,aiCars.length)); aiCars=aiCars.slice(0,need); }

/* ===== Model & Cameras ===== */
function carModelMatrix(c,dy=0){ const w=c.world(); const cos=Math.cos(dy), sin=Math.sin(dy), R=w.R, T=w.T; const R2=[R[0]*cos+T[0]*sin,R[1]*cos+T[1]*sin,R[2]*cos+T[2]*sin]; const T2=[T[0]*cos-R[0]*sin,T[1]*cos-R[1]*sin,T[2]*cos-R[2]*sin]; return M.mul(M.T(w.pos[0],w.pos[1]+0.35,w.pos[2]), M.R(R2,[0,1,0],T2)); }
function boostPads(c){ for(let b of boosts){ const w=c.world(); const d=Math.hypot(w.pos[0]-b.pos[0], w.pos[1]-b.pos[1], w.pos[2]-b.pos[2]); if(d<b.r){ c.v=Math.min(c.v+26, 130); } } }
function drawScene(VP){
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VP));
  gl.uniform1f(loc.uTime, uTime);
  if(centerBuf) drawBuf(centerBuf,centerVerts,gl.TRIANGLES);
  if(geoBuf) drawBuf(geoBuf,geoVerts,gl.TRIANGLES);
  if(envBuf){ gl.disable(gl.DEPTH_TEST); drawBuf(envBuf,envVerts,gl.POINTS); gl.enable(gl.DEPTH_TEST); }
  if(propBuf) drawBuf(propBuf,propVerts,gl.POINTS);
  if(skyBuf) drawBuf(skyBuf,skyVerts,gl.TRIANGLES);
  if(tunnelBuf) drawBuf(tunnelBuf,tunnelVerts,gl.TRIANGLES);
  if(snowBuf) drawBuf(snowBuf,snowVerts,gl.POINTS);
  if(ashBuf) drawBuf(ashBuf,ashVerts,gl.POINTS);
  if(tracksideBuf) drawBuf(tracksideBuf,tracksideVerts,gl.TRIANGLES);
  drawBuf(bufRail,railVerts,gl.POINTS);
  drawBuf(bufRibbon,verts,gl.TRIANGLE_STRIP);
  drawBuf(boostBuf,boostVerts,gl.POINTS);
}

/* ===== Cams ===== */
let cam1, cam2;

/* ===== Render cars ===== */
function renderCars(VP){
  const drawCar=(c,geo)=>{ const dy=clamp(c.offV*0.035,-0.38,0.38); const VPcar=M.mul(VP,carModelMatrix(c,dy)); gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VPcar)); bind(geo.pos,loc.aPos); bind(geo.col,loc.aCol); bind(geo.glow,loc.aGlow); gl.drawArrays(gl.TRIANGLES,0,geo.verts); };
  drawCar(car1,geomP1);
  if(cfg.twoP) drawCar(car2,geomP2);
  for(let i=0;i<aiCars.length;i++) drawCar(aiCars[i], geomAI[i]);
}

/* ===== Race & loop ===== */
const raceLaps=3;
let raceStartTime=0, results=[];
function rankText(){ const total = 1 + (cfg.twoP?1:0) + aiCars.length; if(total===1) return 'Solo';
  const arr=[]; arr.push({name:'P1',s:car1.s}); if(cfg.twoP) arr.push({name:'P2',s:car2.s}); aiCars.forEach((a,i)=>arr.push({name:'AI',s:a.s}));
  arr.sort((a,b)=>b.s-a.s); const pos=arr.findIndex(o=>o.name==='P1')+1; return pos+'/'+total;
}
let S={MENU:0,PLAY:1,PAUSE:2}, state=S.MENU, last=performance.now(), acc=0, dt=1/60, uTime=0;
function frame(){
  const t=performance.now(); let d=(t-last)/1000; last=t; if(d>0.2) d=0.2; acc+=d;
  if(state===S.PLAY){
    while(acc>=dt){ uTime=t/1000; car1.update(dt); if(cfg.twoP) car2.update(dt); for(const ai of aiCars) ai.update(dt); cam1.update(dt); if(cfg.twoP) cam2.update(dt); acc-=dt; }
    gl.viewport(0,0,CW,CH);                 /* ← 항상 전체 뷰포트로 리셋 */
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    if(!cfg.twoP){
      const VP=cam1.VP(CW/CH); drawScene(VP); renderCars(VP);
    }else{
      const half=CW>>1;
      gl.viewport(0,0,half,CH); const VP1=cam1.VP((half)/CH); drawScene(VP1); renderCars(VP1);
      gl.viewport(half,0,CW-half,CH); const VP2=cam2.VP((CW-half)/CH); drawScene(VP2); renderCars(VP2);
      gl.viewport(0,0,CW,CH);
    }
    setHUD('uiSpeed', Math.round(car1.v*3.6)+''); setHUD('uiPos', rankText()); if(cfg.best!=null) setHUD('uiBest', cfg.best.toFixed(2)+'s');
    requestAnimationFrame(frame);
  }
}

/* ===== Results ===== */
function playerFinished(){ if(!cfg.twoP) return car1.finished; return car1.finished && car2.finished; }
function showResults(){
  const list=[...results]; list.sort((a,b)=>a.time-b.time);
  const rows=list.map((r,i)=>`${i+1}. ${r.name} — ${(r.time/1000).toFixed(2)}s`).join('<br>');
  panel(`<h1>결과</h1><div style="text-align:left">${rows}</div><div class="keys" style="margin-top:8px">R 리셋 · P 재개</div>`);
}

/* ===== UI ===== */
function menu(){ panel(`<h1>벡터 레이싱</h1><div class="keys">P1: WASD / Space · P2: 방향키 / Slash</div>`); }
function start(){ clearPanel(); state=S.PLAY; last=performance.now(); acc=0; results=[]; car1.lap=0; if(car2) car2.lap=0; aiCars.forEach(a=>a.lap=0); raceStartTime=performance.now(); frame(); }
function pause(){ if(state!==S.PLAY) return; state=S.PAUSE; panel(`<h1>일시정지</h1><div class="keys">P: 재개 · R: 리셋</div>`); }
function resume(){ if(state!==S.PAUSE) return; clearPanel(); state=S.PLAY; last=performance.now(); acc=0; frame(); }
function reset(){ state=S.MENU; results=[]; car1=makeCar(inP1); car2=makeCar(inP2); aiCars.forEach((a,i)=>aiCars[i]=makeAI(cfg.seed,i)); cam1=makeCam(car1); cam2=makeCam(car2); cam1.snap(); if(cfg.twoP) cam2.snap(); setHUD('uiLap',`0/${raceLaps}`); setHUD('uiPos','—'); menu(); renderIdle(); }

document.getElementById('btnPlay').onclick=()=>{ if(state!==S.PLAY) start(); };
document.getElementById('btnPause').onclick=()=>{ if(state===S.PLAY) pause(); else if(state===S.PAUSE) resume(); };
document.getElementById('btnReset').onclick=()=>reset();
document.getElementById('btnReroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); rebuild(); };
document.getElementById('btnAI').onclick=()=>{ cfg.aiCount=(cfg.aiCount+1)%5; store.set(cfg); rebuild(false); document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount; };
document.getElementById('btn2P').onclick=()=>{ cfg.twoP=!cfg.twoP; store.set(cfg); document.getElementById('btn2P').textContent=cfg.twoP?'👥 2P':'👥 1P'; rebuild(); };
document.getElementById('btnMobile').onclick=()=>{ cfg.mobile=!cfg.mobile; store.set(cfg); document.getElementById('btnMobile').textContent='📱 Mobile: '+(cfg.mobile?'ON':'OFF'); rebuild(); };
document.getElementById('btnShape').onclick=()=>{ const idx=(SHAPES.indexOf(cfg.shape)+1)%SHAPES.length; cfg.shape=SHAPES[idx]; store.set(cfg); document.getElementById('btnShape').textContent='🛣 '+cfg.shape; rebuild(); };
const selTheme=document.getElementById('selTheme'); selTheme.value=cfg.theme; selTheme.onchange=e=>{ cfg.theme=e.target.value; store.set(cfg); rebuild(); };

/* ===== Build/reset ===== */
function applyThemeCSS(){ document.body.style.background=THEMES[cfg.theme].bg(); }
function buildAll(){
  applyThemeCSS();
  buildTrack(cfg.theme);
  ensureAI(cfg.seed);
  geomP1=makeCarGeom(THEMES[cfg.theme].car,1.0,true);
  geomP2=makeCarGeom([1,1,0.4],1.0,true);
  geomAI=[]; for(let i=0;i<4;i++) geomAI.push(makeCarGeom(aiPalette[i],1.2,true));
  car1=makeCar(inP1); car2=makeCar(inP2);
  cam1=makeCam(car1); cam2=makeCam(car2); cam1.snap(); if(cfg.twoP) cam2.snap();
  setHUD('uiLap',`0/${raceLaps}`);
  pad.style.display = cfg.mobile?'flex':'none';
}
function renderIdle(){ gl.viewport(0,0,CW,CH); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT); const VP=cam1.VP(CW/CH); drawScene(VP); renderCars(VP); }
function rebuild(resetState=true){ buildAll(); if(resetState) reset(); else { if(state===S.PLAY){ cam1.snap(); if(cfg.twoP) cam2.snap(); } renderIdle(); } document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount; document.getElementById('btn2P').textContent=cfg.twoP?'👥 2P':'👥 1P'; document.getElementById('btnMobile').textContent='📱 Mobile: '+(cfg.mobile?'ON':'OFF'); document.getElementById('btnShape').textContent='🛣 '+cfg.shape; }

buildAll(); menu(); renderIdle();
window.addEventListener('blur',()=>{ if(state===S.PLAY) pause(); });
window.togglePause=()=>{ if(state===S.PLAY) pause(); else if(state===S.PAUSE) resume(); };

})();</script>
</body>
</html>
