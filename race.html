<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Vector Drift 3D — CC0 Arcade (v6.0)</title>
<style>
  :root{ --bg:#070a16; --bg2:#0b1230; --ink:#eaf2ff; --muted:#9aa9c6 }
  html,body{height:100%;margin:0;background:radial-gradient(1000px 520px at 80% -10%,#182555 0%,transparent 52%),linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;user-select:none;-webkit-user-select:none;overscroll-behavior:none}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .card{position:relative;border:1px solid rgba(255,255,255,.1);border-radius:18px;background:rgba(255,255,255,.04);box-shadow:0 12px 48px rgba(0,0,0,.45);overflow:hidden}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  .title{display:flex;gap:10px;align-items:center;font-weight:800}
  .stats{display:flex;gap:16px;align-items:center}
  .stat{font-variant-numeric:tabular-nums}
  .stat .label{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn,.select{appearance:none;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);padding:7px 10px;border-radius:10px;font-weight:800}
  .view{position:relative;width:100%;height:min(56.25vw,700px);background:#050812;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(10,14,34,.78);border:1px solid rgba(255,255,255,.14);border-radius:18px;padding:18px;max-width:560px;text-align:center;box-shadow:0 16px 70px rgba(0,0,0,.5);animation:pop .14s ease-out}
  .panel h1{margin:0 0 6px;font-size:22px}
  .panel p{margin:0 0 10px;color:var(--muted)}
  @keyframes pop{from{opacity:0;transform:scale(.97)}to{opacity:1;transform:scale(1)}}
  .help{position:absolute;left:10px;bottom:10px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hud">
      <div class="title">🚗 VECTOR DRIFT 3D <span style="color:var(--muted);font-size:12px">· CC0</span></div>
      <div class="stats">
        <div class="stat" id="uiSpeed"><span class="label">SPEED</span> <b class="val">0</b></div>
        <div class="stat" id="uiLap"><span class="label">LAP</span> <b class="val">—</b></div>
        <div class="stat" id="uiDrift"><span class="label">DRIFT</span> <b class="val">0</b></div>
        <div class="stat" id="uiBest"><span class="label">BEST</span> <b class="val">—</b></div>
        <div class="stat" id="uiMission"><span class="label">MISSION</span> <b class="val">Collect 12</b></div>
        <div class="stat" id="uiScore"><span class="label">SCORE</span> <b class="val">0</b></div>
      </div>
      <div class="controls">
        <button class="btn" id="btnPlay">▶ 시작</button>
        <button class="btn" id="btnPause">⏸ 일시정지</button>
        <button class="btn" id="btnReset">↻ 리셋</button>
        <button class="btn" id="btnCam">📷 시점</button>
        <button class="btn" id="btn2P">👥 2인용: OFF</button>
        <button class="btn" id="btnAI">🤖 AI: OFF</button>
        <label style="font-size:12px;color:var(--muted)">테마</label>
        <select class="select" id="selTheme">
          <option value="SPACE">SPACE</option>
          <option value="CYBERPUNK">CYBERPUNK</option>
          <option value="XMAS">XMAS</option>
          <option value="NEON">NEON</option>
          <option value="VOLCANO">VOLCANO</option>
        </select>
      </div>
    </div>
    <div class="view" id="view">
      <canvas id="gl"></canvas>
      <div class="overlay" id="overlay"></div>
      <div class="help">P1: ←/→ 조향 · ↑ 가속 · ↓ 브레이크 · SPACE 드리프트 | P2: J/L · I · K · O 드리프트</div>
    </div>
  </div>
</div>

<script>
(()=>{
// ====== 유틸/상수 & 저장 ======
const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const now=()=>performance.now();
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
const saveKey='vector_drift_3d_arcade_v6_0';
const store={ get(){try{return JSON.parse(localStorage.getItem(saveKey)||'{}')}catch(e){return {}}}, set(v){localStorage.setItem(saveKey,JSON.stringify(v))} };
const cfg=Object.assign({seed:12345,best:null,camMode:'CHASE',theme:'SPACE',twoP:false,ai:false}, store.get());
const hashStr=(s)=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;};

// ====== 입력 ======
const input1={L:false,R:false,ACC:false,BR:false,DRIFT:false,stickX:0,pointer:null};
const input2={L:false,R:false,ACC:false,BR:false,DRIFT:false,stickX:0};
addEventListener('keydown',e=>{
  if(e.repeat) return;
  const b=['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyJ','KeyL','KeyI','KeyK','KeyO']; if(b.includes(e.code)) e.preventDefault();
  if(e.code==='ArrowLeft'||e.code==='KeyA') input1.L=true;
  if(e.code==='ArrowRight'||e.code==='KeyD') input1.R=true;
  if(e.code==='ArrowUp'||e.code==='KeyW') input1.ACC=true;
  if(e.code==='ArrowDown'||e.code==='KeyS') input1.BR=true;
  if(e.code==='Space') input1.DRIFT=true;
  if(!cfg.ai){ if(e.code==='KeyJ') input2.L=true; if(e.code==='KeyL') input2.R=true; if(e.code==='KeyI') input2.ACC=true; if(e.code==='KeyK') input2.BR=true; if(e.code==='KeyO') input2.DRIFT=true; }
  if(e.key==='p'||e.key==='P') togglePause();
  if(e.key==='r'||e.key==='R') reset();
});
addEventListener('keyup',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') input1.L=false;
  if(e.code==='ArrowRight'||e.code==='KeyD') input1.R=false;
  if(e.code==='ArrowUp'||e.code==='KeyW') input1.ACC=false;
  if(e.code==='ArrowDown'||e.code==='KeyS') input1.BR=false;
  if(e.code==='Space') input1.DRIFT=false;
  if(!cfg.ai){ if(e.code==='KeyJ') input2.L=false; if(e.code==='KeyL') input2.R=false; if(e.code==='KeyI') input2.ACC=false; if(e.code==='KeyK') input2.BR=false; if(e.code==='KeyO') input2.DRIFT=false; }
});
const view=document.getElementById('view');
view.addEventListener('pointerdown',e=>{
  if(e.button===0){ view.setPointerCapture(e.pointerId); input1.pointer={id:e.pointerId,x:e.clientX,y:e.clientY,acc:true}; if(state===S.MENU) start(); }
});
view.addEventListener('pointermove',e=>{
  if(!input1.pointer||e.pointerId!==input1.pointer.id) return;
  const rect=view.getBoundingClientRect();
  input1.stickX = clamp(((e.clientX-rect.left)/rect.width)*2-1,-1,1);
});
view.addEventListener('pointerup',e=>{ if(!input1.pointer||e.pointerId!==input1.pointer.id) return; input1.pointer=null; input1.stickX=0; });

// ====== HUD ======
function setHUD(id,val){ const el=document.querySelector('#'+id+' .val'); if(el) el.textContent = val; }

// ====== WebGL ======
const canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
let CW=2,CH=2;
function applyViewport(){ const r=view.getBoundingClientRect(); CW=(r.width*DPR)|0; CH=(r.height*DPR)|0; canvas.width=Math.max(2,CW); canvas.height=Math.max(2,CH); gl.viewport(0,0,CW,CH); }
applyViewport(); new ResizeObserver(applyViewport).observe(view);
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
gl.clearDepth(1); gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);
function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s;}
function prog(vs,fs){const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p;}

// ====== 수학 ======
const M={
  mul:(a,b)=>{const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];} return o;},
  T:(x,y,z)=>[1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1],
  RfromBasis:(x,y,z)=>[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1],
  look:(eye,at,up)=>{const zx=eye[0]-at[0], zy=eye[1]-at[1], zz=eye[2]-at[2]; const zL=Math.hypot(zx,zy,zz)||1; const z=[zx/zL,zy/zL,zz/zL]; let x=[up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]]; const xL=Math.hypot(x[0],x[1],x[2])||1; x=[x[0]/xL,x[1]/xL,x[2]/xL]; const y=[z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]]; const RT=[ x[0],x[1],x[2],0,  y[0],y[1],y[2],0,  z[0],z[1],z[2],0,  0,0,0,1 ]; return M.mul(RT, M.T(-eye[0],-eye[1],-eye[2]));}
};
const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
const norm=v=>{const l=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l];};
const add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]];
const scale=(v,s)=>[v[0]*s,v[1]*s,v[2]*s];

// ====== 지오 빌더 ======
function pushTri(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,c,g){ out.pos.push(x1,y1,z1,x2,y2,z2,x3,y3,z3); out.col.push(c[0],c[1],c[2], c[0],c[1],c[2], c[0],c[1],c[2]); out.glow.push(g,g,g); }
function pushQuad(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,c,g){ pushTri(out,x1,y1,z1,x2,y2,z2,x3,y3,z3,c,g); pushTri(out,x1,y1,z1,x3,y3,z3,x4,y4,z4,c,g); }
function pushBox(out, cx,cy,cz, sx,sy,sz, colTop, colSide, glow=0.25){ const x=sx/2,y=sy/2,z=sz/2; const t=colTop, s=colSide;
  pushQuad(out, cx-x,cy+y,cz-z, cx+x,cy+y,cz-z, cx+x,cy+y,cz+z, cx-x,cy+y,cz+z, t, glow);
  pushQuad(out, cx-x,cy-y,cz+z, cx+x,cy-y,cz+z, cx+x,cy-y,cz-z, cx-x,cy-y,cz-z, s, glow*0.8);
  pushQuad(out, cx-x,cy-y,cz-z, cx-x,cy+y,cz-z, cx-x,cy+y,cz+z, cx-x,cy-y,cz+z, s, glow);
  pushQuad(out, cx+x,cy-y,cz+z, cx+x,cy+y,cz+z, cx+x,cy+y,cz-z, cx+x,cy-y,cz-z, s, glow);
  pushQuad(out, cx-x,cy-y,cz+z, cx-x,cy+y,cz+z, cx+x,cy+y,cz+z, cx+x,cy-y,cz+z, s, glow);
  pushQuad(out, cx+x,cy-y,cz-z, cx+x,cy+y,cz-z, cx-x,cy+y,cz-z, cx-x,cy-y,cz-z, s, glow);
}
const makeGeo=()=>({pos:[],col:[],glow:[]});
function makeBuffer(data, itemSize, type=gl.FLOAT){ const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); return {b,itemSize,type}; }
function bindBuffer(buf, attrib){ gl.bindBuffer(gl.ARRAY_BUFFER, buf.b); gl.enableVertexAttribArray(attrib); gl.vertexAttribPointer(attrib, buf.itemSize, buf.type, false, 0, 0); }

// ====== 트랙 ======
let samples=1020; let trackW=6; const WORLD_UP=[0,1,0];
let CP=[], centerline=[], bufRibbon=null, bufRail=null, verts=0, railVerts=0, trackMaxR=140;
const catmull=(p0,p1,p2,p3,t)=>{const t2=t*t,t3=t2*t; return [
  0.5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
  0.5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3),
  0.5*((2*p1[2])+(-p0[2]+p2[2])*t+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3)
];};
const catmullTangent=(p0,p1,p2,p3,t)=>{const t2=t*t; return [
  0.5*((-p0[0]+p2[0])+2*(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t+3*(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t2),
  0.5*((-p0[1]+p2[1])+2*(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t+3*(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t2),
  0.5*((-p0[2]+p2[2])+2*(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t+3*(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t2)
];};
let samplesPerLap=samples; const getCenter=i=>{const N=samplesPerLap; i=(i+N)%N; return [centerline[i*3],centerline[i*3+1],centerline[i*3+2]]};
const basisAt=i=>{ const p0=getCenter(i), p1=getCenter(i+1); const d=norm(sub(p1,p0)); let r=[d[2],0,-d[0]]; const rl=Math.hypot(r[0],r[1],r[2])||1; r=[r[0]/rl,r[1]/rl,r[2]/rl]; const b=cross(d,r); return {T:d,R:r,B:b}; };

function genCP(seed, yAmp, baseY){
  const rng = mulberry32(seed|0), rand=(a,b)=>a+(b-a)*rng(); const arr=[]; const R=120; const N=28; const ph=rand(0,Math.PI*2);
  for(let i=0;i<N;i++){ const ang=i/N*Math.PI*2; const rad=R*(0.9+0.25*Math.sin(ang*3.0+ph))*(0.94+rand(0,0.18)); arr.push([Math.cos(ang)*rad, baseY+rand(-yAmp,yAmp), Math.sin(ang)*rad]); }
  arr.push(arr[0],arr[1],arr[2]); return arr;
}
function computeTrackMaxR(){ let maxR=0; for(let i=0;i<centerline.length;i+=3){ const x=centerline[i], z=centerline[i+2]; const r=Math.hypot(x,z); if(r>maxR) maxR=r; } trackMaxR = maxR; }

function buildTrack(themeKey){
  const T=THEMES[themeKey]; const seed2=(cfg.seed ^ hashStr(themeKey) ^ (cfg.twoP?0x9e3779b1:0))>>>0;
  trackW=T.trackW + (cfg.twoP?2.6:0); CP=genCP(seed2, T.yAmp, T.baseY);
  const pos=[], col=[], glow=[]; const railPos=[], railCol=[], railGlow=[]; centerline=[]; verts=0; railVerts=0;
  const Ls=CP.length-3, maxSeg=Ls-1e-6;
  for(let i=0;i<samples;i++){
    const seg=(i/(samples-1))*maxSeg; const j=Math.floor(seg); const t=seg-j;
    const p=catmull(CP[j],CP[j+1],CP[j+2],CP[j+3],t);
    const d=norm(catmullTangent(CP[j],CP[j+1],CP[j+2],CP[j+3],t));
    let right=[d[2],0,-d[0]]; const rl=Math.hypot(right[0],right[1],right[2])||1; right=[right[0]/rl,right[1]/rl,right[2]/rl];
    centerline.push(p[0],p[1],p[2]);
    if(i<samples-1){
      const L=add(p,scale(right,-trackW*0.5)), Rr=add(p,scale(right,trackW*0.5));
      pos.push(L[0],L[1],L[2], Rr[0],Rr[1],Rr[2]); col.push(...T.trackC1,...T.trackC2); glow.push(0.45,0.45); verts+=2;
      railPos.push(L[0],L[1]+0.12,L[2], Rr[0],Rr[1]+0.12,Rr[2]); railCol.push(...T.rail, ...T.rail); railGlow.push(1.6,1.6); railVerts+=2;
    }
  }
  computeTrackMaxR();
  bufRibbon={ pos:makeBuffer(new Float32Array(pos),3), col:makeBuffer(new Float32Array(col),3), glow:makeBuffer(new Float32Array(glow),1) };
  bufRail  ={ pos:makeBuffer(new Float32Array(railPos),3), col:makeBuffer(new Float32Array(railCol),3), glow:makeBuffer(new Float32Array(railGlow),1) };
  gl.clearColor(T.fog[0],T.fog[1],T.fog[2],1);

  buildCollect(themeKey, seed2);
  buildBoost(themeKey, seed2);
  buildEnv(themeKey, seed2);     // 반지름 기반으로 침범 방지
  buildCharacters(themeKey, seed2);

  setHUD('uiMission', orbs && orbs.length ? `Collect ${orbs.filter(o=>!o.taken).length}` : 'Mission ✓');
}

// ====== 차량 & 카메라 ======
function makeCarGeom(theme){ const t=THEMES[theme]; const hw=0.72, hh=0.26, hl=1.28; const nose=0.55; const color=t.car; const P=[
  -hw,hh,-hl,  hw,hh,-hl,  0,hh+nose,-hl*0.2,
  -hw,hh, hl*0.2, 0,hh+nose,-hl*0.2,  hw,hh, hl*0.2,
  -hw,-hh,-hl, -hw,hh,-hl, -hw,hh,hl*0.2,
  -hw,-hh,-hl, -hw,hh,hl*0.2, -hw,-hh,hl*0.2,
   hw,-hh,-hl,  hw,hh,hl*0.2,  hw,hh,-hl,
   hw,-hh,-hl,  hw,-hh,hl*0.2,  hw,hh,hl*0.2,
  -hw,-hh,hl*0.2, hw,-hh,hl*0.2, hw,-hh,-hl,
  -hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,-hl
];
  const cols=[]; for(let i=0;i<P.length/3;i++){ cols.push(color[0],color[1],color[2]); }
  const glow=new Float32Array(P.length/3).fill(t.carGlow);
  return { pos:makeBuffer(new Float32Array(P),3), col:makeBuffer(new Float32Array(cols),3), glow:makeBuffer(glow,1), verts:P.length/3 };
}
let carGeom=null;

function makeCar(inputRef){ return {
  s:0,v:0,off:0, offV:0, steer:0, drift:0, lapStart:null, score:0,
  update(dt){
    // 입력: 키가 우선, 없으면 포인터
    let steerRaw = (inputRef.L? -1 : 0) + (inputRef.R? 1 : 0);
    if(steerRaw===0) steerRaw = clamp(inputRef.stickX,-1,1);

    // 아케이드 가속/감속
    const ACC=inputRef.ACC||((inputRef===input1)&&input1.pointer!=null);
    const BR=inputRef.BR; const DR=inputRef.DRIFT;
    const maxV=58; const acc=ACC?(DR?28:26):0; const dec=BR?34:8.5;
    this.v = acc>0? clamp(this.v+acc*dt,0,maxV):Math.max(0,this.v-dec*dt);

    // 좌/우: 즉시성 ↑ + 약간 스무스
    const steerSnap = 1-Math.pow(0.0001, dt*18);
    this.steer += (steerRaw - this.steer)*steerSnap;

    // 횡가속: 속도에 비례 + 드리프트 시 배가
    const latBase = (10 + this.v*0.55) * (DR?1.6:1.0);
    const targetOffV = this.steer * latBase;
    const follow = 1-Math.pow(0.0001, dt*(DR?12:18));
    this.offV += (targetOffV - this.offV) * follow;
    // 그립감: 드리프트 중 감쇠 약화
    const damp = DR? 0.85 : 0.92;
    this.offV *= damp;
    this.off = clamp(this.off + this.offV*dt, -trackW*0.48, trackW*0.48);

    // 진행
    this.s=(this.s+this.v*dt)%samplesPerLap;

    // 드리프트 스코어 & 속도 페널티 약화
    const slip = Math.abs(this.offV)/(trackW*0.7);
    this.v *= (1-clamp(slip*(DR?0.05:0.10),0,0.12));
    const driftGain = Math.max(0, (Math.abs(this.offV)*0.03 + Math.abs(this.steer)*this.v*0.015) * (DR?2.0:1.0));
    this.drift = Math.max(0, this.drift + (driftGain - 0.40*dt));

    // 랩타임
    if(this.lapStart==null) this.lapStart=performance.now();
    const tNow=performance.now();
    if(this.s<2 && this.v>12 && (tNow-this.lapStart)>2000){
      const lap=(tNow-this.lapStart)/1000; this.lapStart=tNow; setHUD('uiLap',lap.toFixed(2)+'s');
      if(cfg.best==null||lap<cfg.best){ cfg.best=lap; store.set(cfg); setHUD('uiBest',cfg.best.toFixed(2)+'s'); }
    }

    // 수집/부스트
    collectItems(this); boostPads(this);
  },
  world(){ const i=Math.floor(this.s)|0; const t=this.s-i; const p=getCenter(i), n=getCenter(i+1);
    const pos=[lerp(p[0],n[0],t), lerp(p[1],n[1],t), lerp(p[2],n[2],t)]; const {T,R,B}=basisAt(i);
    return {pos:[pos[0]+R[0]*this.off,pos[1]+R[1]*this.off,pos[2]+R[2]*this.off], T,R,B};
  }
};}
const car1=makeCar(input1), car2=makeCar(input2);

function makeCam(carRef){ return {
  mode:cfg.camMode||'CHASE', eye:[0,8,-8], at:[0,0,0], up:[0,1,0], fovBase:62*(Math.PI/180),
  update(dt){
    const w=carRef.world();
    const lead=(this.mode==='TOP')?0:4.2, height=(this.mode==='TOP')?28:3.0, dist=(this.mode==='TOP')?0:7.8;
    const a=[ w.pos[0]+w.T[0]*lead, w.pos[1]+0.9, w.pos[2]+w.T[2]*lead ];
    let e=(this.mode==='TOP')?[ w.pos[0], w.pos[1]+height, w.pos[2] ]:[ w.pos[0]-w.T[0]*dist, w.pos[1]+height, w.pos[2]-w.T[2]*dist ];

    // 속도감: FOV + 미세 셰이크
    const sp=clamp(carRef.v,0,58);
    this.fov = this.fovBase + (sp*0.6)*(Math.PI/180);
    const t=performance.now()*0.001;
    const shake=(sp/58)*0.12;
    e[0]+= (Math.sin(t*19.7)+Math.cos(t*13.3))*0.5*shake;
    e[1]+= (Math.sin(t*23.1))*0.6*shake;

    // 스무스
    const k=1-Math.pow(0.0001,dt*6);
    this.eye=[lerp(this.eye[0],e[0],k), lerp(this.eye[1],e[1],k), lerp(this.eye[2],e[2],k)];
    this.at=[lerp(this.at[0],a[0],k), lerp(this.at[1],a[1],k), lerp(this.at[2],a[2],k)];
    this.up=[0,1,0];
  },
  snap(){ const w=carRef.world(); const lead=(this.mode==='TOP')?0:4.2; const h=(this.mode==='TOP')?28:3.0; const d=(this.mode==='TOP')?0:7.8; this.at=[ w.pos[0]+w.T[0]*lead, w.pos[1]+0.9, w.pos[2]+w.T[2]*lead ]; this.eye=(this.mode==='TOP')?[ w.pos[0], w.pos[1]+h, w.pos[2] ]:[ w.pos[0]-w.T[0]*d, w.pos[1]+h, w.pos[2]-w.T[2]*d ]; this.up=[0,1,0]; },
  VP(aspect=CW/CH){
    const V=M.look(this.eye,this.at,this.up);
    const fov=this.fov||this.fovBase; const P=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
    { const f=1/Math.tan(fov/2); const near=0.1, far=900; const nf=1/(near-far); P[0]=f/(aspect>0?aspect:1); P[5]=f; P[10]=(far+near)*nf; P[11]=-1; P[14]=(2*far*near)*nf; P[15]=0; }
    return M.mul(P,V);
  }
};}
const cam1=makeCam(car1), cam2=makeCam(car2);

// ====== ENV / PROPS / CHARACTERS ======
let envBuf=null, envVerts=0, propBuf=null, propVerts=0, geoBuf=null, geoVerts=0, charGeoBuf=null, charGeoVerts=0;
function buildEnv(themeKey, seed2){
  envBuf=propBuf=geoBuf=null; envVerts=propVerts=geoVerts=0;
  const pts=[], cols=[], glows=[]; const p2=[], c2=[], g2=[]; const GEO=makeGeo();
  const pushP=(x,y,z,c,g)=>{ pts.push(x,y,z); cols.push(c[0],c[1],c[2]); glows.push(g); };
  const push2=(x,y,z,c,g)=>{ p2.push(x,y,z); c2.push(c[0],c[1],c[2]); g2.push(g); };
  const rng=mulberry32(seed2); const t=THEMES[themeKey]; const groundY=0;
  const ringR = trackMaxR + 20; // 트랙 외곽 마진

  if(t.ground){
    const rad=ringR+60, step=10; const baseCol=(themeKey==='XMAS')?[0.9,0.96,1]: (themeKey==='VOLCANO')?[0.25,0.08,0.06]: (themeKey==='CYBERPUNK')?[0.08,0.08,0.12]: [0.06,0.08,0.12];
    for(let x=-(rad);x<rad;x+=step){ for(let z=-(rad);z<rad;z+=step){
      if(Math.hypot(x,z) < ringR-3) continue; // 트랙 내부 채우지 않음
      const c=[ baseCol[0]*(0.94+0.12*rng()), baseCol[1]*(0.94+0.12*rng()), baseCol[2]*(0.94+0.12*rng()) ];
      pushQuad(GEO,x,groundY,z, x+step,groundY,z, x+step,groundY,z+step, x,groundY,z+step, c, 0.13);
    }}
  }
  if(t.env==='stars'){
    const rngS=mulberry32(seed2+999);
    for(let i=0;i<1400;i++){ const r=ringR+20 + rngS()*220; const a=rngS()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r, ry=(rngS()*2-1)*160+30; pushP(rx,ry,rz,[0.86+rngS()*0.14,0.9+rngS()*0.08,1], 0.06); }
  } else if(t.env==='village'){
    for(let i=0;i<220;i++){ const r=ringR+10 + rng()*140; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r;
      if(rng()<0.6){ const sx=6+rng()*6, sz=6+rng()*6, sy=4+rng()*3; pushBox(GEO,x,groundY+sy/2,z, sx,sy,sz, [1,0.2,0.2],[0.9,0.9,0.95],0.35); pushBox(GEO,x,groundY+sy+1.2,z, sx*0.9,1.2,sz*0.9, [0.9,0.1,0.1],[0.9,0.1,0.1],0.4); }
      else{ pushBox(GEO,x,groundY+1.2,z, 0.9,2.6,0.9, [0.5,0.3,0.2],[0.5,0.3,0.2]); pushBox(GEO,x,groundY+3.5,z, 3.6,2.0,3.6, [0.1,0.6,0.2],[0.1,0.5,0.2]); pushBox(GEO,x,groundY+5.8,z, 3.0,1.8,3.0, [0.1,0.7,0.2],[0.1,0.6,0.2]); pushBox(GEO,x,groundY+7.8,z, 2.4,1.6,2.4, [0.1,0.8,0.2],[0.1,0.7,0.2]); }
    }
    for(let i=0;i<1600;i++){ const r=ringR+5 + rng()*160; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r; pushP(rx, groundY+90, rz, [1,1,1], -(0.5+rng()*0.5)); }
  } else if(t.env==='city'){
    for(let i=0;i<260;i++){ const r=ringR+8 + rng()*180; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; const sy=12+rng()*46;
      pushBox(GEO,x,sy/2,z, 4+rng()*18,sy,4+rng()*18, [0.2,0.9,0.9],[0.6,0.2,1], 0.38);
    }
    for(let i=0;i<200;i++){ const r=ringR+4 + rng()*190; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; push2(x, 6+rng()*40, z, [1,0.3,0.9], 0.8); }
  } else if(t.env==='scan'){
    const baseR=ringR+10; for(let i=0;i<16;i++){ const r=baseR+i*8; for(let a=0;a<Math.PI; a+=Math.PI/28){ const x=Math.cos(a)*r, y=Math.sin(a)*24+4, z=0; const c=[0.2,0.8,1]; pushQuad(GEO, x,y,z, x+1.2,y,z, x+1.2,y+1.2,z, x,y+1.2,z, c, 0.55);} }
    for(let i=0;i<300;i++){ const r=baseR + rng()*220; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r; push2(rx, -7, rz, [0.3,0.9,1], 0.8); }
  } else if(t.env==='ash'){
    for(let i=0;i<200;i++){ const r=ringR+4 + rng()*200; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; const sy=6+rng()*24; pushBox(GEO,x,sy/2,z, 5,sy,5, [1,0.5,0.2],[1,0.35,0.15], 0.42); }
    for(let i=0;i<1100;i++){ const r=ringR+10 + rng()*220; const a=rng()*Math.PI*2; const rx=Math.cos(a)*r, rz=Math.sin(a)*r, ry=rng()*80+6; pushP(rx,ry,rz,[1,0.5+rng()*0.3,0.2], 0.45); }
  }

  if(pts.length){ envBuf={ pos:makeBuffer(new Float32Array(pts),3), col:makeBuffer(new Float32Array(cols),3), glow:makeBuffer(new Float32Array(glows),1) }; envVerts=pts.length/3; }
  if(p2.length){ propBuf={ pos:makeBuffer(new Float32Array(p2),3), col:makeBuffer(new Float32Array(c2),3), glow:makeBuffer(new Float32Array(g2),1) }; propVerts=p2.length/3; }
  if(GEO.pos.length){ geoBuf={ pos:makeBuffer(new Float32Array(GEO.pos),3), col:makeBuffer(new Float32Array(GEO.col),3), glow:makeBuffer(new Float32Array(GEO.glow),1) }; geoVerts=GEO.pos.length/3; }
}

// 캐릭터(로우폴리 메쉬)
function buildCharacters(themeKey, seed2){
  charGeoBuf=null; charGeoVerts=0; const G=makeGeo(); const rng=mulberry32(seed2^0xABCD); const ringR=trackMaxR+8;
  const putRobot=(x,y,z,s,c1,c2)=>{ // 몸통/머리/팔/다리
    pushBox(G,x,y+2.0*s,z, 1.2*s,1.8*s,0.8*s, c1,c1,0.4);
    pushBox(G,x,y+3.2*s,z, 0.9*s,0.9*s,0.9*s, c2,c2,0.6);
    pushBox(G,x-0.9*s,y+2.0*s,z, 0.4*s,1.2*s,0.4*s, c1,c1,0.4);
    pushBox(G,x+0.9*s,y+2.0*s,z, 0.4*s,1.2*s,0.4*s, c1,c1,0.4);
    pushBox(G,x-0.35*s,y+1.0*s,z, 0.5*s,1.0*s,0.5*s, c1,c1,0.4);
    pushBox(G,x+0.35*s,y+1.0*s,z, 0.5*s,1.0*s,0.5*s, c1,c1,0.4);
  };
  const putSnowman=(x,y,z,s)=>{ pushBox(G,x,y+0.7*s,z, 1.0*s,1.0*s,1.0*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+1.6*s,z, 0.8*s,0.8*s,0.8*s,[1,1,1],[1,1,1],0.8); pushBox(G,x,y+2.3*s,z, 0.6*s,0.6*s,0.6*s,[1,1,1],[1,1,1],0.9); };
  const putDancer=(x,y,z,s,c)=>{ pushBox(G,x,y+1.6*s,z, 0.9*s,1.6*s,0.6*s,c,c,0.8); pushBox(G,x,y+2.6*s,z, 0.6*s,0.6*s,0.6*s,c,c,0.9); };
  const putGolem=(x,y,z,s)=>{ pushBox(G,x,y+1.6*s,z, 1.2*s,1.6*s,1.0*s,[1,0.45,0.15],[1,0.35,0.12],0.8); pushBox(G,x,y+2.6*s,z, 1.0*s,0.8*s,1.0*s,[1,0.5,0.2],[1,0.35,0.15],0.8); };
  const putAstronaut=(x,y,z,s)=>{ pushBox(G,x,y+1.9*s,z, 1.0*s,1.6*s,0.8*s,[0.9,0.95,1],[0.8,0.9,1],0.7); pushBox(G,x,y+2.8*s,z, 0.8*s,0.8*s,0.8*s,[0.6,0.8,1],[0.6,0.8,1],0.9); };

  const N=110;
  for(let i=0;i<N;i++){
    const r=ringR + 10 + rng()*90; const a=rng()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r; const s=0.9 + rng()*0.8; const h=0;
    if(themeKey==='SPACE') putAstronaut(x,h,z,s);
    else if(themeKey==='CYBERPUNK') putRobot(x,h,z,s,[0.2,0.9,0.9],[1,0.3,0.9]);
    else if(themeKey==='XMAS') putSnowman(x,h,z,1.2*s);
    else if(themeKey==='NEON') putDancer(x,h,z,s,[0.3,1,1]);
    else if(themeKey==='VOLCANO') putGolem(x,h,z,s);
  }
  if(G.pos.length){ charGeoBuf={ pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1) }; charGeoVerts=G.pos.length/3; }
}

// ====== 수집/부스트 ======
let orbBuf=null, orbVerts=0, orbs=[]; let boostBuf=null, boostVerts=0, boosts=[]; let missionDone=false;
function buildCollect(theme, seed2){
  orbs=[]; const pos=[], col=[], glow=[]; const rng=mulberry32(seed2^0x333);
  for(let i=30;i<samples; i+=Math.floor(44+rng()*52)){
    const {R}=basisAt(i); const C=getCenter(i); const lateral=(rng()*2-1)*trackW*0.42;
    const p=[ C[0]+R[0]*lateral, C[1]+1.0, C[2]+R[2]*lateral ];
    orbs.push({i,pos:p,r:0.9,taken:false}); pos.push(p[0],p[1],p[2]); col.push(1,1,1); glow.push(1.6);
  }
  orbBuf={ pos:makeBuffer(new Float32Array(pos),3), col:makeBuffer(new Float32Array(col),3), glow:makeBuffer(new Float32Array(glow),1) }; orbVerts=pos.length/3;
}
function buildBoost(theme, seed2){
  boosts=[]; const pos=[], col=[], glow=[]; const rng=mulberry32(seed2^0x999);
  for(let i=60;i<samples; i+=Math.floor(120+rng()*90)){ const C=getCenter(i); const p=[ C[0], C[1]+0.2, C[2] ]; boosts.push({i,pos:p,r:1.8}); pos.push(p[0],p[1],p[2]); col.push(0.3,1,0.8); glow.push(1.5); }
  boostBuf={ pos:makeBuffer(new Float32Array(pos),3), col:makeBuffer(new Float32Array(col),3), glow:makeBuffer(new Float32Array(glow),1) }; boostVerts=pos.length/3;
}
function boostPads(car){ for(const b of boosts){ const d=Math.hypot(car.world().pos[0]-b.pos[0], car.world().pos[1]-b.pos[1], car.world().pos[2]-b.pos[2]); if(d<b.r){ car.v=Math.min(car.v+20, 58); } } }

function collectItems(car){
  let got=0;
  for(const orb of orbs){ if(orb.taken) continue;
    const w=car.world(); const d=Math.hypot(w.pos[0]-orb.pos[0], w.pos[1]-orb.pos[1], w.pos[2]-orb.pos[2]);
    if(d<orb.r){ orb.taken=true; car.score+=120; got++; }
  }
  if(got>0){
    setHUD('uiScore', String(car.score));
    const remain=orbs.filter(o=>!o.taken).length;
    setHUD('uiMission', remain>0?`Collect ${remain}`:'Mission ✓');
    if(remain===0 && !missionDone){ missionDone=true; // 테마색 토스트
      const hex=((c)=>'#'+['0','0','0'].map((_,i)=>('0'+((c[i]*255)|0).toString(16)).slice(-2)).join(''))(THEMES[cfg.theme].trackC1);
      const overlay=document.getElementById('overlay'); overlay.innerHTML=`<div class="panel" style="border-color:${hex}80;background:linear-gradient(180deg,${hex}22,rgba(10,14,34,.78))"><h1>MISSION COMPLETE</h1><p style="margin:4px 0 0">+5000</p></div>`;
      setTimeout(()=>overlay.innerHTML='', 1600);
      car.score+=5000; setHUD('uiScore', String(car.score));
    }
  }
}

// ====== 셰이더 ======
const VS=`
attribute vec3 aPos; attribute vec3 aCol; attribute float aGlow;
uniform mat4 uVP; uniform float uTime;
varying vec3 vCol; varying float vGlow;
void main(){
  vCol=aCol; vGlow=aGlow; gl_Position = uVP * vec4(aPos,1.0);
  gl_PointSize = 3.0 + 11.0*clamp(vGlow,0.0,2.5);
}`;
const FS=`
precision mediump float; varying vec3 vCol; varying float vGlow;
void main(){ float a = min(0.08 + vGlow*0.9, 1.0); gl_FragColor = vec4(vCol, a); }`;
const program=prog(VS,FS); gl.useProgram(program);
const loc={ aPos:gl.getAttribLocation(program,'aPos'), aCol:gl.getAttribLocation(program,'aCol'), aGlow:gl.getAttribLocation(program,'aGlow'), uVP:gl.getUniformLocation(program,'uVP'), uTime:gl.getUniformLocation(program,'uTime') };

// ====== 드로잉 ======
function drawBuf(buf, count, mode){ if(!buf||!count) return; bindBuffer(buf.pos,loc.aPos); bindBuffer(buf.col,loc.aCol); bindBuffer(buf.glow,loc.aGlow); gl.drawArrays(mode,0,count); }
function drawCar(){ bindBuffer(carGeom.pos, loc.aPos); bindBuffer(carGeom.col, loc.aCol); bindBuffer(carGeom.glow, loc.aGlow); gl.drawArrays(gl.TRIANGLES, 0, carGeom.verts); }
function carModelMatrix(carRef){ const w=carRef.world(); return M.mul(M.T(w.pos[0],w.pos[1]+0.35,w.pos[2]), M.RfromBasis(w.R,[0,1,0],w.T)); }
function renderScene(VP, time, carRef){
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VP)); gl.uniform1f(loc.uTime, time);
  if(geoBuf){ drawBuf(geoBuf, geoVerts, gl.TRIANGLES); }
  if(envBuf){ gl.disable(gl.DEPTH_TEST); drawBuf(envBuf, envVerts, gl.POINTS); gl.enable(gl.DEPTH_TEST); }
  drawBuf(propBuf, propVerts, gl.POINTS);
  drawBuf(bufRail, railVerts, gl.POINTS);
  drawBuf(bufRibbon, verts, gl.TRIANGLE_STRIP);
  if(charGeoBuf){ drawBuf(charGeoBuf, charGeoVerts, gl.TRIANGLES); }
  drawBuf(orbBuf, orbVerts, gl.POINTS);
  drawBuf(boostBuf, boostVerts, gl.POINTS);
  const VPcar=M.mul(VP,carModelMatrix(carRef)); gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VPcar)); gl.uniform1f(loc.uTime, time); drawCar();
}
function render(){
  gl.disable(gl.SCISSOR_TEST);
  gl.viewport(0,0,CW,CH);
  const tSec=performance.now()/1000;
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  if(!cfg.twoP){
    const VP=cam1.VP();
    renderScene(VP, tSec, car1);
  } else {
    const half=CW>>1;
    gl.viewport(0,0,half,CH); renderScene(cam1.VP( (half)/CH ), tSec, car1);
    gl.viewport(half,0,CW-half,CH); renderScene(cam2.VP( (CW-half)/CH ), tSec, car2);
    gl.viewport(0,0,CW,CH);
  }

  setHUD('uiSpeed',Math.round(car1.v*3.6)+'');
  setHUD('uiDrift',Math.floor(car1.drift)+'');
  if(cfg.best!=null) setHUD('uiBest',cfg.best.toFixed(2)+'s');
}

// ====== 고스트/포인터락 등 불필요 기능 제거됨 ======

// ====== AI ======
const aiCtx={enabled:!!cfg.ai, t:0};
function aiTick(dt){ if(!aiCtx.enabled) return; aiCtx.t+=dt;
  const look=28; const iAhead=Math.floor(car2.s+look);
  let desiredOff=Math.sin(aiCtx.t*0.6)*trackW*0.18;
  desiredOff=clamp(desiredOff, -trackW*0.48, trackW*0.48);
  input2.stickX = clamp((desiredOff - car2.off)/(trackW*0.22), -1, 1);
  input2.L = input2.stickX < -0.25; input2.R = input2.stickX > 0.25;
  input2.ACC = car2.v < 52; input2.BR=false; input2.DRIFT = Math.abs(input2.stickX)>0.5;
}

// ====== 루프/상태 ======
const S={MENU:0,PLAY:1,PAUSE:2}; let state=S.MENU; let last=now(); let acc=0; const dt=1/60;
function frame(){ const t=now(); let d=(t-last)/1000; last=t; d=Math.min(d,0.2); acc+=d; if(state===S.PLAY){
  while(acc>=dt){
    pollGamepad(); if(aiCtx.enabled){ aiTick(dt); }
    car1.update(dt); cam1.update(dt);
    if(cfg.twoP){ car2.update(dt); cam2.update(dt); }
    acc-=dt;
  }
  render(); requestAnimationFrame(frame);
}}
function pollGamepad(){ const gp=(navigator.getGamepads&&navigator.getGamepads()[0])||null; if(!gp) return; const x=Math.abs(gp.axes[0])>0.08?gp.axes[0]:0; input1.stickX=x; input1.ACC=gp.buttons[0]?.pressed||false; input1.BR=gp.buttons[1]?.pressed||false; }

// ====== 오버레이/버튼 ======
const overlay=document.getElementById('overlay');
function showMenu(){ overlay.innerHTML=`<div class="panel"><h1>VECTOR DRIFT 3D</h1><p>아케이드 튜닝 · 카메라 고정 추적 · 테마 캐릭터</p><p style="font-size:12px;color:#9aa9c6">P1: ←/→/↑/↓ + SPACE · P2: J/L/I/K + O</p><div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap"><button class='btn' id='start'>▶ 시작</button><button class='btn' id='reroll'>🎲 새 트랙</button><button class='btn' id='clear'>↻ 기록 삭제</button></div></div>`; overlay.querySelector('#start').onclick=()=>start(); overlay.querySelector('#reroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); rebuild(); }; overlay.querySelector('#clear').onclick=()=>{ cfg.best=null; store.set(cfg); location.reload(); }; }
function clearOverlay(){ overlay.innerHTML=''; }
function start(){ clearOverlay(); if(state!==S.PLAY){ state=S.PLAY; last=now(); acc=0; cam1.snap(); if(cfg.twoP) cam2.snap(); frame(); } }
function togglePause(){ if(state===S.PLAY){ state=S.PAUSE; overlay.innerHTML=`<div class='panel'><h1>⏸ 일시정지</h1><div style='display:flex;gap:8px;justify-content:center'><button class='btn' id='res'>▶ 계속</button><button class='btn' id='menu'>메뉴</button></div></div>`; overlay.querySelector('#res').onclick=()=>{ clearOverlay(); state=S.PLAY; last=now(); acc=0; frame(); }; overlay.querySelector('#menu').onclick=()=>{ state=S.MENU; showMenu(); }; } else if(state===S.MENU){ start(); } }
function reset(){ state=S.MENU; for(const c of [car1,car2]){ c.s=0;c.v=0;c.off=0;c.offV=0;c.steer=0;c.drift=0;c.score=0; } missionDone=false; setHUD('uiScore','0'); setHUD('uiMission', orbs && orbs.length ? `Collect ${orbs.filter(o=>!o.taken).length}` : 'Mission ✓'); showMenu(); render(); }

function rebuild(){ applyThemeCSS(cfg.theme); carGeom=makeCarGeom(cfg.theme); buildTrack(cfg.theme); samplesPerLap=samples; cam1.snap(); if(cfg.twoP) cam2.snap(); render(); }

// ====== 테마 ======
const THEMES={
  SPACE:{ bg:()=>`radial-gradient(1200px 700px at 70% -10%, #0b1740 0%, transparent 55%), linear-gradient(180deg,#030616,#071531)`, trackC1:[0.58,0.82,1.0], trackC2:[0.62,0.4,1.0], rail:[0.9,0.95,1], env:'stars', trackW:6.2, baseY:1.6, yAmp:6, car:[0.9,0.95,1], carGlow:0.85, fog:[0.02,0.04,0.09], ground:false },
  CYBERPUNK:{ bg:()=>`radial-gradient(800px 500px at 80% -10%, #461058 0%, transparent 50%), linear-gradient(180deg,#16061e,#090a18)`, trackC1:[1.0,0.2,0.8], trackC2:[0.2,1.0,0.9], rail:[1,0.7,1], env:'city', trackW:6.8, baseY:0.6, yAmp:2.2, car:[1.0,0.3,0.9], carGlow:1.0, fog:[0.06,0.02,0.10], ground:true },
  XMAS:{ bg:()=>`radial-gradient(1000px 600px at 60% -10%, #0e1b3a 0%, transparent 52%), linear-gradient(180deg,#081226,#0a1a33)`, trackC1:[0.0,0.9,0.3], trackC2:[1.0,0.1,0.1], rail:[1,1,1], env:'village', trackW:7.0, baseY:0.6, yAmp:0.9, car:[0.9,0.1,0.1], carGlow:0.9, fog:[0.03,0.05,0.08], ground:true },
  NEON:{ bg:()=>`radial-gradient(900px 540px at 85% -10%, #103b6b 0%, transparent 52%), linear-gradient(180deg,#081022,#0a0f28)`, trackC1:[0.2,0.9,1.0], trackC2:[1.0,0.5,0.2], rail:[0.8,1,1], env:'scan', trackW:6.0, baseY:1.0, yAmp:3.2, car:[0.2,0.9,1.0], carGlow:0.95, fog:[0.02,0.05,0.12], ground:true },
  VOLCANO:{ bg:()=>`radial-gradient(900px 540px at 85% -10%, #3b0f0f 0%, transparent 52%), linear-gradient(180deg,#140606,#230a0a)`, trackC1:[1.0,0.5,0.0], trackC2:[0.9,0.2,0.1], rail:[1,0.85,0.7], env:'ash', trackW:7.2, baseY:0.4, yAmp:1.8, car:[1.0,0.4,0.05], carGlow:0.85, fog:[0.06,0.02,0.02], ground:true }
};
function applyThemeCSS(key){ const t=THEMES[key]; if(!t) return; document.body.style.background = t.bg(); }
function applyTheme(key){ if(!THEMES[key]) return; cfg.theme=key; store.set(cfg); rebuild(); }

// ====== 시작 ======
document.getElementById('selTheme').value=cfg.theme; applyThemeCSS(cfg.theme); carGeom=makeCarGeom(cfg.theme); buildTrack(cfg.theme); cam1.snap();
showMenu(); render();

document.getElementById('btnPlay').onclick=()=>{ if(state!==S.PLAY) start(); };
document.getElementById('btnPause').onclick=togglePause;
document.getElementById('btnReset').onclick=reset;
document.getElementById('btnCam').onclick=()=>{ cam1.mode = (cam1.mode==='CHASE')?'TOP':'CHASE'; cam2.mode=cam1.mode; cfg.camMode=cam1.mode; store.set(cfg); cam1.snap(); if(cfg.twoP) cam2.snap(); };
document.getElementById('btn2P').onclick=()=>{ cfg.twoP=!cfg.twoP; store.set(cfg); document.getElementById('btn2P').textContent = `👥 2인용: ${cfg.twoP?'ON':'OFF'}`; rebuild(); };
document.getElementById('btnAI').onclick=()=>{ cfg.ai=!cfg.ai; store.set(cfg); aiCtx.enabled=cfg.ai; document.getElementById('btnAI').textContent = `🤖 AI: ${cfg.ai?'ON':'OFF'}`; };
document.getElementById('selTheme').onchange=(e)=>applyTheme(e.target.value);

})();
</script>
</body>
</html>
