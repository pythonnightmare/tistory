<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>벡터 레이싱</title>
<style>
  :root{ --bg:#070a16; --bg2:#0b1230; --ink:#eaf2ff; --muted:#9aa9c6; --glass:rgba(10,14,34,.82) }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1000px 520px at 80% -10%,#182555 0%,transparent 52%),linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;user-select:none;-webkit-user-select:none;overscroll-behavior:none}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .card{position:relative;border:1px solid rgba(255,255,255,.1);border-radius:18px;background:rgba(255,255,255,.04);box-shadow:0 12px 48px rgba(0,0,0,.45);overflow:hidden}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  .title{display:flex;gap:10px;align-items:center;font-weight:800}
  .stats{display:flex;gap:16px;align-items:center}
  .stat{font-variant-numeric:tabular-nums}
  .stat .label{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn,.select{appearance:none;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);padding:7px 10px;border-radius:10px;font-weight:800;cursor:pointer}
  .view{position:relative;width:100%;height:min(56.25vw,700px);background:#050812;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .panel{pointer-events:auto;background:var(--glass);border:1px solid rgba(255,255,255,.16);border-radius:18px;padding:18px;max-width:760px;width:min(92%,760px);text-align:center;box-shadow:0 16px 70px rgba(0,0,0,.55)}
  .panel h1{margin:0 0 10px}
  .keys{margin-top:8px;font-size:12px;color:var(--muted)}
  /* 모바일 패드 */
  .padL,.padR{position:absolute;bottom:12px;gap:12px;pointer-events:auto;display:none}
  .padL{left:12px}
  .padR{right:12px;flex-direction:column;align-items:flex-end}
  .pbtn{min-width:92px;min-height:92px;border-radius:20px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.10);color:#fff;font-weight:900;font-size:18px}
  .pbtn.small{min-width:88px;min-height:66px}
  .row{display:flex;gap:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hud">
      <div class="title">🏁 벡터 레이싱(by soo)</div>
      <div class="stats">
        <div class="stat" id="uiSpeed"><span class="label">SPEED</span> <b class="val">0</b></div>
        <div class="stat" id="uiLap"><span class="label">LAP</span> <b class="val">0/3</b></div>
        <div class="stat" id="uiPos"><span class="label">POS</span> <b class="val">Solo</b></div>
        <div class="stat" id="uiBest"><span class="label">BEST</span> <b class="val">—</b></div>
      </div>
      <div class="controls">
        <button class="btn" id="btnPlay">▶ 시작</button>
        <button class="btn" id="btnPause">⏸ 일시정지</button>
        <button class="btn" id="btnReset">↻ 리셋</button>
        <button class="btn" id="btnReroll">🎲 새 트랙</button>
        <button class="btn" id="btnShape">🛣 RANDOM</button>
        <button class="btn" id="btnAI">🤖 AI: 0</button>
        <button class="btn" id="btn2P">👥 1P</button>
        <button class="btn" id="btnMobile">📱 Mobile: OFF</button>
        <label style="font-size:12px;color:#9aa9c6">테마</label>
        <select class="select" id="selTheme">
          <option value="SPACE">SPACE</option>
          <option value="CYBERPUNK">CYBERPUNK</option>
          <option value="XMAS">XMAS</option>
          <option value="NEON">NEON</option>
          <option value="VOLCANO">VOLCANO</option>
        </select>
      </div>
    </div>
    <div class="view" id="view">
      <canvas id="gl"></canvas>
      <div class="overlay" id="overlay"></div>
      <!-- 모바일: 좌측 방향키 -->
      <div class="padL" id="padL">
        <button class="pbtn" data-act="L">◀</button>
        <button class="pbtn" data-act="R">▶</button>
      </div>
      <!-- 모바일: 우측 (DRIFT 크게, 아래 가속/브레이크) -->
      <div class="padR" id="padR">
        <button class="pbtn" data-act="DR">DRIFT</button>
        <div class="row">
          <button class="pbtn small" data-act="ACC">가속</button>
          <button class="pbtn small" data-act="BR">브레이크</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(()=>{'use strict';
/* ---------- 안전: 에러 화면 ---------- */
const overlay=document.getElementById('overlay');
const panel=(html)=>overlay.innerHTML=`<div class="panel">${html}</div>`;
const clearPanel=()=>overlay.innerHTML='';
window.addEventListener('error',e=>panel(`<h1>⚠ 오류</h1><pre style="text-align:left;white-space:pre-wrap">${e.message||e}</pre>`));
window.addEventListener('unhandledrejection',e=>panel(`<h1>⚠ 오류</h1><pre style="text-align:left;white-space:pre-wrap">${(e.reason&&e.reason.message)||e.reason||e}</pre>`));

/* ---------- 유틸 ---------- */
const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const mulberry32=a=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296};
const hashStr=s=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;};
const saveKey='vector_racing_v14';
const store={get(){try{return JSON.parse(localStorage.getItem(saveKey)||'{}')}catch(e){return{}}},set(v){localStorage.setItem(saveKey,JSON.stringify(v))}};

/* ---------- 상태 ---------- */
const SHAPES=['RANDOM','OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY'];
const cfg=Object.assign({seed:(Math.random()*1e9)|0,theme:'SPACE',shape:'RANDOM',aiCount:0,twoP:false,mobile:false,best:null}, store.get());
const setHUD=(id,val)=>{const el=document.querySelector('#'+id+' .val'); if(el) el.textContent=val};
const view=document.getElementById('view'), canvas=document.getElementById('gl');

/* ---------- WebGL ---------- */
const gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
if(!gl){ panel('<h1>⚠ WebGL 미지원</h1>'); return; }
let CW=2,CH=2; function applyViewport(){const r=view.getBoundingClientRect(); CW=(r.width*DPR)|0; CH=(r.height*DPR)|0; canvas.width=CW; canvas.height=CH; gl.viewport(0,0,CW,CH);}
applyViewport(); new ResizeObserver(applyViewport).observe(view);
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE); gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);
function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||'shader'); return s;}
function prog(vs,fs){const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)||'link'); return p;}
function makeBuffer(data,item=3,type=gl.FLOAT){const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW); return {b,item,type};}
function bind(buf,loc){gl.bindBuffer(gl.ARRAY_BUFFER,buf.b); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,buf.item,buf.type,false,0,0);}
const M={mul:(a,b)=>{const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){o[c*4+r]=a[r]*b[c*4]+a[r+4]*b[c*4+1]+a[r+8]*b[c*4+2]+a[r+12]*b[c*4+3];} return o;}, T:(x,y,z)=>[1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1], R:(x,y,z)=>[x[0],x[1],x[2],0,y[0],y[1],y[2],0,z[0],z[1],z[2],0,0,0,0,1], look:(eye,at,up)=>{const zx=eye[0]-at[0],zy=eye[1]-at[1],zz=eye[2]-at[2]; const zL=Math.hypot(zx,zy,zz)||1; const z=[zx/zL,zy/zL,zz/zL]; let x=[up[1]*z[2]-up[2]*z[1], up[2]*z[0]-up[0]*z[2], up[0]*z[1]-up[1]*z[0]]; const xL=Math.hypot(x[0],x[1],x[2])||1; x=[x[0]/xL,x[1]/xL,x[2]/xL]; const y=[z[1]*x[2]-z[2]*x[1], z[2]*x[0]-z[0]*x[2], z[0]*x[1]-z[1]*x[0]]; const RT=[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1]; return M.mul(RT,M.T(-eye[0],-eye[1],-eye[2]));}};
const add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]], sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
const scale=(v,s)=>[v[0]*s,v[1]*s,v[2]*s], cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
const norm=v=>{const l=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l];};

/* ---------- 셰이더 ---------- */
const VS=`
attribute vec3 aPos; attribute vec3 aCol; attribute float aGlow;
uniform mat4 uVP; uniform float uTime;
varying vec3 vCol; varying float vGlow;
void main(){
  vCol=aCol; float g=aGlow; vec3 p=aPos;
  if(g<0.0){            // 낙하 파티클(눈/재)
    float ph = fract(abs(g));
    float t = fract(uTime*(0.08+ph*0.12) + ph);
    p.y = -12.0 + t * 220.0;
    g = 0.65 + ph*0.2;
  }
  vGlow=g;
  gl_Position = uVP * vec4(p,1.0);
  gl_PointSize = 2.0 + 10.0*abs(vGlow);
}`;
const FS=`
precision mediump float;
varying vec3 vCol; varying float vGlow;
void main(){
  float a = clamp(0.06 + abs(vGlow)*0.9, 0.0, 1.0);
  gl_FragColor = vec4(vCol, a);
}`;
const program=prog(VS,FS); gl.useProgram(program);
const loc={aPos:gl.getAttribLocation(program,'aPos'), aCol:gl.getAttribLocation(program,'aCol'), aGlow:gl.getAttribLocation(program,'aGlow'), uVP:gl.getUniformLocation(program,'uVP'), uTime:gl.getUniformLocation(program,'uTime')};

/* ---------- 지오 도우미 ---------- */
const makeGeo=()=>({pos:[],col:[],glow:[]});
const pushTri=(o,a,b,c,d,e,f,g,h,i,C,G)=>{o.pos.push(a,b,c,d,e,f,g,h,i); o.col.push(C[0],C[1],C[2],C[0],C[1],C[2],C[0],C[1],C[2]); o.glow.push(G,G,G)};
const pushQuad=(o,a,b,c,d,e,f,g,h,i,j,k,l,C,G)=>{pushTri(o,a,b,c,d,e,f,g,h,i,C,G); pushTri(o,a,b,c,g,h,i,j,k,l,C,G)};
const pushBox=(o,cx,cy,cz,sx,sy,sz,ct,cs,g=0.25)=>{const x=sx/2,y=sy/2,z=sz/2;
  pushQuad(o,cx-x,cy+y,cz-z,cx+x,cy+y,cz-z,cx+x,cy+y,cz+z,cx-x,cy+y,cz+z,ct,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx+x,cy-y,cz+z,cx+x,cy-y,cz-z,cx-x,cy-y,cz-z,cs,g*0.85);
  pushQuad(o,cx-x,cy-y,cz-z,cx-x,cy+y,cz-z,cx-x,cy+y,cz+z,cx-x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz+z,cx+x,cy+y,cz+z,cx+x,cy+y,cz-z,cx+x,cy-y,cz-z,cs,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx-x,cy+y,cz+z,cx+x,cy+y,cz+z,cx+x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz-z,cx+x,cy+y,cz-z,cx-x,cy+y,cz-z,cx-x,cy-y,cz-z,cs,g);
};

/* ---------- 테마 ---------- */
const THEMES={
  SPACE:{bg:()=>`radial-gradient(1200px 700px at 70% -10%, #0b1740 0%, transparent 55%), linear-gradient(180deg,#030616,#071531)`,trackC1:[0.58,0.82,1.0],trackC2:[0.62,0.4,1.0],rail:[0.9,0.95,1],trackW:7.4,baseY:1.6,yAmp:6,car:[0.9,0.95,1],fog:[0.02,0.04,0.09],ground:false},
  CYBERPUNK:{bg:()=>`radial-gradient(800px 500px at 80% -10%, #461058 0%, transparent 50%), linear-gradient(180deg,#16061e,#090a18)`,trackC1:[1.0,0.2,0.8],trackC2:[0.2,1.0,0.9],rail:[1,0.7,1],trackW:8.0,baseY:0.6,yAmp:2.2,car:[1.0,0.3,0.9],fog:[0.06,0.02,0.10],ground:true},
  XMAS:{bg:()=>`radial-gradient(1000px 600px at 60% -10%, #0e1b3a 0%, transparent 52%), linear-gradient(180deg,#081226,#0a1a33)`,trackC1:[0.0,0.9,0.3],trackC2:[1.0,0.1,0.1],rail:[1,1,1],trackW:8.4,baseY:0.6,yAmp:0.9,car:[0.9,0.1,0.1],fog:[0.03,0.05,0.08],ground:true},
  NEON:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #103b6b 0%, transparent 52%), linear-gradient(180deg,#081022,#0a0f28)`,trackC1:[0.2,0.9,1.0],trackC2:[1.0,0.5,0.2],rail:[0.8,1,1],trackW:7.2,baseY:1.0,yAmp:3.2,car:[0.2,0.9,1.0],fog:[0.02,0.05,0.12],ground:true},
  VOLCANO:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #3b0f0f 0%, transparent 52%), linear-gradient(180deg,#140606,#230a0a)`,trackC1:[1.0,0.5,0.0],trackC2:[0.9,0.2,0.1],rail:[1,0.85,0.7],trackW:8.6,baseY:0.4,yAmp:1.8,car:[1.0,0.4,0.05],fog:[0.06,0.02,0.02],ground:true}
};
document.body.style.background=THEMES[cfg.theme].bg();

/* ---------- 트랙 ---------- */
let samples=2200, trackW=8, CP=[], centerline=[], bufRibbon=null, bufRail=null, verts=0, railVerts=0, trackMaxR=140, trackMinR=40;
const WORLD_UP=[0,1,0];
const getCenter=i=>{const N=samples; const idx=((i%N)+N)%N; return [centerline[idx*3],centerline[idx*3+1],centerline[idx*3+2]]};
function catmull(p0,p1,p2,p3,t){const t2=t*t,t3=t2*t;
  return [0.5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
          0.5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3),
          0.5*((2*p1[2])+(-p0[2]+p2[2])*t+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3)];
}
function catmullTangent(p0,p1,p2,p3,t){const t2=t*t;
  return [0.5*((-p0[0]+p2[0])+2*(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t+3*(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t2),
          0.5*((-p0[1]+p2[1])+2*(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t+3*(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t2),
          0.5*((-p0[2]+p2[2])+2*(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t+3*(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t2)];
}
function basisAt(i){const p0=getCenter(i), p1=getCenter(i+1); const T=norm(sub(p1,p0)); let R=norm(cross(T,WORLD_UP)); if(!isFinite(R[0])) R=[1,0,0]; const B=norm(cross(R,T)); return {T,R,B};}
function computeTrackRadii(){ trackMaxR=0; trackMinR=1e9; for(let i=0;i<centerline.length;i+=3){const r=Math.hypot(centerline[i],centerline[i+2]); trackMaxR=Math.max(trackMaxR,r); trackMinR=Math.min(trackMinR,r);} }
function genCP(seed,shape,yAmp,baseY){
  const rng=mulberry32(seed|0),rand=(a,b)=>a+(b-a)*rng(); let arr=[],N=48,R=140,ph=rand(0,Math.PI*2);
  if(shape==='RANDOM'){const list=['OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY']; shape=list[(rng()*list.length)|0];}
  for(let i=0;i<N;i++){const t=i/N*2*Math.PI; let x=0,z=0;
    if(shape==='OVAL'){const rx=R*(1.3+0.18*Math.sin(3*t+ph)), rz=R*(0.95+0.18*Math.sin(2*t+ph)); x=rx*Math.cos(t); z=rz*Math.sin(t);}
    else if(shape==='FIG8'){x=R*1.0*Math.sin(2*t); z=R*0.8*Math.sin(t); x+=24*Math.sin(3*t+ph);}
    else if(shape==='CLOVER'){const rad=R*(1+0.35*Math.sin(3*t+ph)); x=rad*Math.cos(t); z=rad*Math.sin(t);}
    else if(shape==='S_BEND'){x=R*1.2*Math.cos(t)+36*Math.sin(2*t); z=R*0.9*Math.sin(t);}
    else if(shape==='ISLAND'){const rad2=R*(0.92+0.22*Math.sin(3*t+ph))*(0.94+rand(0,0.18)); x=rad2*Math.cos(t); z=rad2*Math.sin(t);}
    else if(shape==='LEMNISCATE'){const a=R*0.98,s=Math.sin(t),c=Math.cos(t); x=(a*Math.sqrt(2)*c)/(1+s*s); z=(a*Math.sqrt(2)*c*s)/(1+s*s);}
    else if(shape==='WAVY'){const rx2=R*(1+0.30*Math.sin(4*t+ph)), rz2=R*(1+0.28*Math.cos(3*t+ph)); x=rx2*Math.cos(t); z=rz2*Math.sin(t);}
    const y=baseY+rand(-yAmp,yAmp)*(0.6+0.4*Math.sin(2*t+ph)); arr.push([x,y,z]); }
  arr.push(arr[0],arr[1],arr[2]); return arr;
}

/* ---------- 버퍼들 ---------- */
let envBuf=null,envVerts=0,propBuf=null,propVerts=0,geoBuf=null,geoVerts=0,centerBuf=null,centerVerts=0,tunnelBuf=null,tunnelVerts=0,tracksideBuf=null,tracksideVerts=0,snowBuf=null,snowVerts=0,ashBuf=null,ashVerts=0;

/* ---------- 트랙 & 환경 빌드 ---------- */
function buildTrack(theme){
  const T=THEMES[theme], seed2=(cfg.seed^hashStr(theme)^hashStr(cfg.shape))>>>0;
  trackW=T.trackW*2.0;
  const CPs=genCP(seed2,cfg.shape,T.yAmp,T.baseY); CP=CPs; centerline=[]; verts=0; railVerts=0;
  const p=[],c=[],g=[], rp=[],rc=[],rg=[]; const Ls=CP.length-3,maxSeg=Ls-1e-6;
  for(let i=0;i<samples;i++){
    const seg=i/(samples-1)*maxSeg,j=Math.floor(seg),t=seg-j;
    const P=catmull(CP[j],CP[j+1],CP[j+2],CP[j+3],t), d=norm(catmullTangent(CP[j],CP[j+1],CP[j+2],CP[j+3],t));
    let R=norm(cross(d,WORLD_UP)); if(!isFinite(R[0])) R=[1,0,0];
    centerline.push(P[0],P[1],P[2]);
    if(i<samples-1){
      const L=add(P,scale(R,-trackW*0.5)), Rr=add(P,scale(R,trackW*0.5));
      p.push(L[0],L[1],L[2], Rr[0],Rr[1],Rr[2]); c.push(...T.trackC1, ...T.trackC2); g.push(0.55,0.55); verts+=2;
      rp.push(L[0],L[1]+0.10,L[2], Rr[0],Rr[1]+0.10,Rr[2]); rc.push(...T.rail, ...T.rail); rg.push(1.2,1.2); railVerts+=2;
    }
  }
  gl.clearColor(T.fog[0],T.fog[1],T.fog[2],1);
  bufRibbon={pos:makeBuffer(new Float32Array(p),3),col:makeBuffer(new Float32Array(c),3),glow:makeBuffer(new Float32Array(g),1)};
  bufRail  ={pos:makeBuffer(new Float32Array(rp),3),col:makeBuffer(new Float32Array(rc),3),glow:makeBuffer(new Float32Array(rg),1)};
  computeTrackRadii();
  buildEnv(theme,seed2); buildCenterpiece(theme,seed2); buildTunnels(theme,seed2); buildTrackside(theme,seed2);
}
function buildEnv(theme,seed2){
  envBuf=propBuf=geoBuf=snowBuf=ashBuf=null; envVerts=propVerts=geoVerts=snowVerts=ashVerts=0;
  const pts=[],cols=[],glows=[], p2=[],c2=[],g2=[], GEO=makeGeo();
  const rng=mulberry32(seed2), t=THEMES[theme], ringR=trackMaxR+trackW*2.8, groundY=0;
  const pushP=(x,y,z,c,g)=>{pts.push(x,y,z); cols.push(c[0],c[1],c[2]); glows.push(g)}
  const push2=(x,y,z,c,g)=>{p2.push(x,y,z); c2.push(c[0],c[1],c[2]); g2.push(g)}
  if(t.ground){
    const rad=ringR+160, step=12;
    const baseCol=(theme==='XMAS')?[0.95,0.98,1]:(theme==='VOLCANO')?[0.25,0.08,0.06]:(theme==='CYBERPUNK')?[0.08,0.08,0.12]:[0.06,0.08,0.12];
    for(let x=-rad;x<rad;x+=step) for(let z=-rad;z<rad;z+=step){
      if(Math.hypot(x,z)<ringR-12) continue;
      const c0=[baseCol[0]*(0.94+0.12*rng()), baseCol[1]*(0.94+0.12*rng()), baseCol[2]*(0.94+0.12*rng())];
      pushQuad(GEO,x,groundY,z, x+step,groundY,z, x+step,groundY,z+step, x,groundY,z+step, c0,0.12);
    }
  }
  if(theme==='SPACE'){
    const rngS=mulberry32(seed2^0x55aa);
    const starCount= cfg.mobile?1600:3000;
    for(let i=0;i<starCount;i++){const rr=ringR+20+rngS()*420,a=rngS()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=(rngS()*2-1)*320+90; pushP(rx,ry,rz,[0.82+rngS()*0.18,0.88+rngS()*0.12,1],0.06);}
    for(let j=0;j<260;j++){const rr2=ringR+60+rng()*380,a2=rng()*Math.PI*2; push2(Math.cos(a2)*rr2,(rng()*2-1)*260+60,Math.sin(a2)*rr2,[0.9,0.95,1],0.9);}
  }else if(theme==='CYBERPUNK'){
    const starN= cfg.mobile?1200:2400;
    for(let i=0;i<starN;i++){const rr=trackMaxR+260+Math.random()*420,a=Math.random()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=120+Math.random()*320; pushP(rx,ry,rz,[0.85+Math.random()*0.15,0.9+Math.random()*0.1,1],0.08);}
    const moonR=24, moonX=Math.cos(0.7)*(trackMaxR+300), moonZ=Math.sin(0.7)*(trackMaxR+300), moonY=160;
    const sphere=(cx,cy,cz,R,lat,lon,col,glw)=>{for(let a=0;a<lat;a++){const v0=a/lat*Math.PI, v1=(a+1)/lat*Math.PI; for(let b=0;b<lon;b++){const u0=b/lon*2*Math.PI,u1=(b+1)/lon*2*Math.PI; const p=(v,u)=>[cx+R*Math.sin(v)*Math.cos(u), cy+R*Math.cos(v), cz+R*Math.sin(v)*Math.sin(u)]; const A=p(v0,u0),B=p(v0,u1),C=p(v1,u1),D=p(v1,u0); pushQuad(GEO,A[0],A[1],A[2],B[0],B[1],B[2],C[0],C[1],C[2],D[0],D[1],D[2],col,glw); }}};
    sphere(moonX,moonY,moonZ,moonR,12,20,[0.95,0.95,1.0],0.2);
    const addWindows=(cx,sy,cz,sx,sz)=>{ const strideX=2.2,strideY=2.6,strideZ=2.2; const halfX=sx/2,halfZ=sz/2,rows=Math.max(1,Math.floor((sy-3)/strideY));
      const colsX=Math.max(1,Math.floor((sx-3)/strideX)), colsZ=Math.max(1,Math.floor((sz-3)/strideZ));
      for(let iy=0;iy<rows;iy++){const y=-sy/2+2+iy*strideY;
        for(let ix=0;ix<colsX;ix++){const u=-halfX+2+ix*strideX; pushBox(GEO,cx+u, sy/2+y, cz+halfZ+0.05, 1.4,1.2,0.05, [0.2,0.9,1],[0.2,0.9,1],1.2); pushBox(GEO,cx+u, sy/2+y, cz-halfZ-0.05, 1.4,1.2,0.05,[0.2,0.9,1],[0.2,0.9,1],1.2);}
        for(let iz=0;iz<colsZ;iz++){const u=-halfZ+2+iz*strideZ; pushBox(GEO, cx+halfX+0.05, sy/2+y, cz+u, 0.05,1.2,1.4,[1,0.3,0.9],[1,0.3,0.9],1.1); pushBox(GEO, cx-halfX-0.05, sy/2+y, cz+u, 0.05,1.2,1.4,[1,0.3,0.9],[1,0.3,0.9],1.1); }
      }
    };
    for(let i=0;i<520;i++){
      const r=trackMaxR+trackW*2.8+12+Math.random()*320,a=Math.random()*Math.PI*2,xx=Math.cos(a)*r,zz=Math.sin(a)*r,sy=26+Math.random()*140;
      const sx=6+Math.random()*32, sz=6+Math.random()*32;
      pushBox(GEO,xx,sy/2,zz, sx,sy,sz, [0.08,0.1,0.14],[0.12,0.12,0.16],0.35);
      addWindows(xx,sy,zz,sx,sz);
    }
  }else if(theme==='XMAS'){
    const sPos=[],sCol=[],sGlow=[]; const snowCount= cfg.mobile?2400:5200;
    for(let i=0;i<snowCount;i++){const rr=trackMaxR+trackW*2.6+8+Math.random()*300, aa=Math.random()*Math.PI*2, rx=Math.cos(aa)*rr, rz=Math.sin(aa)*rr, ry=120+Math.random()*280; sPos.push(rx,ry,rz); sCol.push(1,1,1); sGlow.push(-(0.4+Math.random()*0.6));}
    snowBuf={pos:makeBuffer(new Float32Array(sPos),3), col:makeBuffer(new Float32Array(sCol),3), glow:makeBuffer(new Float32Array(sGlow),1)}; snowVerts=sPos.length/3;
    for(let i=0;i<520;i++){const r=trackMaxR+trackW*2.8+14+Math.random()*260,a=Math.random()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r;
      if(Math.random()<0.55){const sx=6+Math.random()*6,sz=6+Math.random()*6,sy=4+Math.random()*3; pushBox(GEO,x,sy/2,z, sx,sy,sz,[1,0.2,0.2],[0.9,0.9,0.95],0.35); pushBox(GEO,x,sy+1.4,z, sx*0.9,1.4,sz*0.9,[0.9,0.1,0.1],[0.9,0.1,0.1],0.4);}
      else { pushBox(GEO,x,1.3,z, 1.0,3.0,1.0,[0.5,0.3,0.2],[0.5,0.3,0.2]); pushBox(GEO,x,4.0,z, 3.8,2.2,3.8,[0.1,0.6,0.2],[0.1,0.5,0.2]); pushBox(GEO,x,6.5,z, 3.0,2.0,3.0,[0.1,0.7,0.2],[0.1,0.6,0.2]); pushBox(GEO,x,8.9,z, 2.4,1.8,2.4,[0.1,0.8,0.2],[0.1,0.7,0.2]); }
    }
  }else if(theme==='NEON'){
    const baseR=trackMaxR+trackW*2.8+18;
    for(let ii=0;ii<36;ii++){const r=baseR+ii*10; for(let a=0;a<Math.PI;a+=Math.PI/28){const x=Math.cos(a)*r,y=Math.sin(a)*40+8,z=0; pushQuad(GEO,x,y,z, x+1.8,y,z, x+1.8,y+1.8,z, x,y+1.8,z, [0.2,0.8,1],0.75);}}
    for(let i=0;i<3;i++){const y=160+i*10; pushQuad(GEO,-40,y,-(trackMaxR+320), 40,y,-(trackMaxR+320), 40,y+2,-(trackMaxR+320), -40,y+2,-(trackMaxR+320), [0.3,1,1],0.9);}
  }else if(theme==='VOLCANO'){
    for(let i=0;i<420;i++){const r=trackMaxR+trackW*2.8+8+Math.random()*320,a=Math.random()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r,sy=9+Math.random()*40; pushBox(GEO,x,sy/2,z, 5,sy,5,[1,0.5,0.2],[1,0.35,0.15],0.44);}
    const aPos=[],aCol=[],aGlow=[]; const ashCount= cfg.mobile?2400:5200;
    for(let i=0;i<ashCount;i++){const rr=trackMaxR+trackW*2.8+20+Math.random()*320,a=Math.random()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=160+Math.random()*260; aPos.push(rx,ry,rz); aCol.push(0.6,0.35,0.25); aGlow.push(-(0.2+Math.random()*0.4)); }
    ashBuf={pos:makeBuffer(new Float32Array(aPos),3), col:makeBuffer(new Float32Array(aCol),3), glow:makeBuffer(new Float32Array(aGlow),1)}; ashVerts=aPos.length/3;
  }
  if(pts.length) envBuf={pos:makeBuffer(new Float32Array(pts),3), col:makeBuffer(new Float32Array(cols),3), glow:makeBuffer(new Float32Array(glows),1)}, envVerts=pts.length/3;
  if(p2.length)  propBuf={pos:makeBuffer(new Float32Array(p2),3), col:makeBuffer(new Float32Array(c2),3), glow:makeBuffer(new Float32Array(g2),1)}, propVerts=p2.length/3;
  if(GEO.pos.length) geoBuf={pos:makeBuffer(new Float32Array(GEO.pos),3), col:makeBuffer(new Float32Array(GEO.col),3), glow:makeBuffer(new Float32Array(GEO.glow),1)}, geoVerts=GEO.pos.length/3;
}
function buildCenterpiece(theme,seed2){
  const G=makeGeo();
  const scaleHalf=0.5; // 요청: 구조물 절반 크기
  const sphere=(cx,cy,cz,R,lat,lon,col,glw)=>{R*=scaleHalf; for(let a=0;a<lat;a++){const v0=a/lat*Math.PI, v1=(a+1)/lat*Math.PI; for(let b=0;b<lon;b++){const u0=b/lon*2*Math.PI,u1=(b+1)/lon*2*Math.PI; const p=(v,u)=>[cx+R*Math.sin(v)*Math.cos(u), cy+R*Math.cos(v), cz+R*Math.sin(v)*Math.sin(u)]; const A=p(v0,u0),B=p(v0,u1),C=p(v1,u1),D=p(v1,u0); pushQuad(G,A[0],A[1],A[2],B[0],B[1],B[2],C[0],C[1],C[2],D[0],D[1],D[2],col,glw); }}};
  const boxH=(cx,cy,cz,sx,sy,sz,ct,cs,g)=>pushBox(G,cx,cy,cz,sx*scaleHalf,sy*scaleHalf,sz*scaleHalf,ct,cs,g);
  const safety = trackW*0.7 + 10, safeR = Math.max(12, trackMinR - safety);
  if(theme==='XMAS'){
    const R1 = clamp(safeR*0.45, 10, 26), R2=R1*0.7, R3=R1*0.48, base=0;
    sphere(0,base+R1,0,R1,16,22,[1,1,1],0.8);
    sphere(0,base+R1*2+R2*0.2,0,R2,14,20,[1,1,1],0.85);
    sphere(0,base+R1*2+R2*0.2+R2+R3*0.3,0,R3,12,18,[1,1,1],0.9);
    boxH(-R3*0.57, base+R1*2+R2*0.2+R2+R3*0.3+R3*0.28, R3*1.1, R3*0.28, R3*0.28, 0.6,[0.05,0.05,0.08],[0.05,0.05,0.08],0.2);
    boxH( R3*0.57, base+R1*2+R2*0.2+R2+R3*0.3+R3*0.28, R3*1.1, R3*0.28, R3*0.28, 0.6,[0.05,0.05,0.08],[0.05,0.05,0.08],0.2);
    for(let i=-2;i<=2;i++){ const x=i*(R3*0.32), y=base+R1*2+R2*0.2+R2+R3*0.3-R3*0.28+Math.abs(i)*0.18*R3; boxH(x,y,R3*1.05, R3*0.18, R3*0.18, 0.5,[0.05,0.05,0.08],[0.05,0.05,0.08],0.25); }
    boxH(0,base+R1*2+R2*0.2+R2+R3*0.3, R3*0.95, R3*0.35, R3*0.35, R3*0.9, [1.0,0.45,0.1],[1.0,0.4,0.08],0.9);
  } else if(theme==='NEON'){
    const half = clamp(safeR*0.38, 10, 24), h=clamp(safeR*4.0, 90, 160);
    boxH(0,h*0.5,0, half*1.2,h,half*1.2,[0.08,0.1,0.14],[0.1,0.12,0.18],0.4);
    for(let i=-4;i<=4;i++){ boxH(i*half*0.22, h-6, 0, half*0.18,10,half*0.18,[0.2,0.9,1],[0.2,0.9,1],1.2); }
  } else if(theme==='CYBERPUNK'){
    const half=clamp(safeR*0.4, 11, 26), h=clamp(safeR*4.2, 100, 180);
    boxH(0,h*0.5,0, half*1.2,h,half*1.2,[0.08,0.1,0.14],[0.12,0.12,0.16],0.4);
    for(let y=8;y<h;y+=6){ for(let x=-half+3;x<=half-3;x+=3){ boxH(x,y, half*1.2/2+0.05, 1.6,1.2,0.2, [0.2,0.9,1],[0.2,0.9,1],1.2); boxH(x,y,-half*1.2/2-0.05, 1.6,1.2,0.2,[0.2,0.9,1],[0.2,0.9,1],1.2);} }
    for(let y=8;y<h;y+=6){ for(let z=-half+3;z<=half-3;z+=3){ boxH( half*1.2/2+0.05,y,z, 0.2,1.2,1.6,[1,0.3,0.9],[1,0.3,0.9],1.1); boxH(-half*1.2/2-0.05,y,z, 0.2,1.2,1.6,[1,0.3,0.9],[1,0.3,0.9],1.1);} }
  } else if(theme==='VOLCANO'){
    const baseW=clamp(safeR*1.2, 26, 84)*scaleHalf;
    for(let i=0;i<12;i++){ const y=6*scaleHalf+i*5*scaleHalf, s=baseW - i*5*scaleHalf; if(s<=6*scaleHalf) break; boxH(0,y,0, s,5*scaleHalf,s,[0.5,0.16,0.08],[0.4,0.14,0.07],0.35); }
  } else if(theme==='SPACE'){
    const R=clamp(safeR*0.6, 16, 36);
    sphere(0,(R+20)*scaleHalf,0,R,18,28,[0.55,0.8,1],0.6);
    const ringR=clamp(R*1.5, 0, safeR-2), ringW=Math.min(4, safeR*0.12)*scaleHalf;
    for(let a=0;a<Math.PI*2;a+=Math.PI/24){ const x0=Math.cos(a)*ringR, z0=Math.sin(a)*ringR, x1=Math.cos(a+Math.PI/24)*ringR, z1=Math.sin(a+Math.PI/24)*ringR;
      pushQuad(G, x0, (R+20)*scaleHalf, z0, x1, (R+20)*scaleHalf, z1, x1, (R+20)*scaleHalf+ringW, z1, x0, (R+20)*scaleHalf+ringW, z0, [0.6,0.9,1],[0.6,0.9,1],0.9);
    }
  }
  centerBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; centerVerts=G.pos.length/3;
}
function buildTunnels(theme,seed2){
  tunnelBuf=null; tunnelVerts=0; const G=makeGeo();
  for(let i=160;i<samples;i+=420){
    const {T,R}=basisAt(i); const C=getCenter(i);
    const h=24, w=trackW*0.9, seg=24;
    for(let s=0;s<seg;s++){
      const a0=s/seg*Math.PI, a1=(s+1)/seg*Math.PI;
      const p=(a)=>add(add(C,scale(R,Math.cos(a)*w*0.5)), [0,Math.sin(a)*h,0]);
      const A=p(a0), B=p(a1), C1=add(A,scale(T,0.8)), C2=add(B,scale(T,0.8));
      pushQuad(G, A[0],A[1],A[2], B[0],B[1],B[2], C2[0],C2[1],C2[2], C1[0],C1[1],C1[2], [0.2,0.8,1], 0.6);
    }
  }
  tunnelBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; tunnelVerts=G.pos.length/3;
}
function buildTrackside(theme,seed2){
  tracksideBuf=null; tracksideVerts=0; const G=makeGeo(); const rng=mulberry32(seed2^0x777);
  for(let i=40;i<samples;i+=Math.floor(20+rng()*26)){
    const {R}=basisAt(i); const C=getCenter(i);
    const side = (rng()<0.5?-1:1), off = side*(trackW*0.55), P=add(C,scale(R,off));
    const h=2.5+rng()*6, s=0.6+rng()*1.2;
    pushBox(G, P[0],h*0.5,P[2], s,h,s, [0.8,0.9,1],[0.2,0.9,1], 0.8);
  }
  tracksideBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; tracksideVerts=G.pos.length/3;
}

/* ---------- 차량 ---------- */
function makeCarGeom(themeCol){
  const hw=0.8, hh=0.28, hl=1.36, nose=0.55, color=themeCol;
  const P=[
    -hw,hh,-hl,  hw,hh,-hl,  0,hh+nose,-hl*0.2,
    -hw,hh, hl*0.2, 0,hh+nose,-hl*0.2,  hw,hh, hl*0.2,
    -hw,-hh,-hl, -hw,hh,-hl, -hw,hh,hl*0.2,
    -hw,-hh,-hl, -hw,hh,hl*0.2, -hw,-hh,hl*0.2,
     hw,-hh,-hl,  hw,hh,hl*0.2,  hw,hh,-hl,
     hw,-hh,-hl,  hw,-hh,hl*0.2,  hw,hh,hl*0.2,
    -hw,-hh,hl*0.2, hw,-hh,hl*0.2, hw,-hh,-hl,
    -hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,-hl
  ];
  const cols=[]; for(let i=0;i<P.length/3;i++) cols.push(color[0],color[1],color[2]);
  const glow=new Float32Array(P.length/3).fill(0.9);
  return {pos:makeBuffer(new Float32Array(P),3),col:makeBuffer(new Float32Array(cols),3),glow:makeBuffer(glow,1),verts:P.length/3};
}
let carGeom=makeCarGeom(THEMES[cfg.theme].car);
function carModelMatrix(world){ return M.mul(M.T(world.pos[0],world.pos[1]+0.35,world.pos[2]), M.R(world.R,world.B,world.T)); }

/* ---------- 입력 ---------- */
const input1={L:false,R:false,ACC:false,BR:false,DR:false, stickX:0};
const input2={L:false,R:false,ACC:false,BR:false,DR:false, stickX:0};
function setKeys(down,e){
  const code=e.code;
  // 1P: WASD + SPACE
  if(code==='KeyA') input1.L=down;
  if(code==='KeyD') input1.R=down;
  if(code==='KeyW') input1.ACC=down;
  if(code==='KeyS') input1.BR=down;
  if(code==='Space') input1.DR=down;
  // 2P: Arrows + Slash
  if(code==='ArrowLeft') input2.L=down;
  if(code==='ArrowRight') input2.R=down;
  if(code==='ArrowUp') input2.ACC=down;
  if(code==='ArrowDown') input2.BR=down;
  if(code==='Slash') input2.DR=down;
}
addEventListener('keydown',e=>{ if(e.repeat) return; const block=['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Slash','KeyA','KeyD','KeyW','KeyS']; if(block.includes(e.code)) e.preventDefault(); setKeys(true,e); });
addEventListener('keyup',e=>setKeys(false,e));
/* 모바일 버튼 */
const padL=document.getElementById('padL'), padR=document.getElementById('padR');
function bindPad(btn){ const act=btn.dataset.act; btn.addEventListener('pointerdown',e=>{e.preventDefault(); if(act==='L') input1.L=true; if(act==='R') input1.R=true; if(act==='ACC') input1.ACC=true; if(act==='BR') input1.BR=true; if(act==='DR') input1.DR=true;},{passive:false});
btn.addEventListener('pointerup',e=>{e.preventDefault(); if(act==='L') input1.L=false; if(act==='R') input1.R=false; if(act==='ACC') input1.ACC=false; if(act==='BR') input1.BR=false; if(act==='DR') input1.DR=false;},{passive:false}); }
padL.querySelectorAll('.pbtn').forEach(bindPad); padR.querySelectorAll('.pbtn').forEach(bindPad);

/* ---------- 자동차 로직(아케이드) ---------- */
function makeCar(ctrl){
  return {
    s:0, prevS:0, v:0, off:0, offV:0, drift:0, lap:0, finished:false, name:'P', lastLapTs:0,
    update(dt){
      const ACC=ctrl?.ACC, BR=ctrl?.BR, L=ctrl?.L, R=ctrl?.R, DR=ctrl?.DR;
      const maxV= (cfg.mobile?40:44);
      const acc=ACC? 24 : 0;
      const baseDec= 6.5, brakeDec = BR? 24 : 0;
      this.v = clamp(this.v + (acc - baseDec - brakeDec)*dt, 0, maxV);
      const target = (L?-1:0) + (R?1:0);
      const aim = target * (trackW*0.46);
      const spring = 6.0, damp=3.6;
      const force = (aim - this.off)*spring - this.offV*damp;
      this.offV += force*dt;
      if(DR){ this.offV*=1.02; this.v = Math.min(maxV, this.v + 10*dt); this.drift += Math.abs(this.offV)*1.2; }
      this.off += this.offV*dt;
      const limit=trackW*0.48; if(this.off<-limit){this.off=-limit; this.offV=0;} if(this.off>limit){this.off=limit; this.offV=0;}
      this.prevS = this.s;
      this.s = (this.s + this.v*dt) % samples;
    },
    world(){
      const i=Math.floor(this.s)|0; const t=this.s-i;
      const p0=getCenter(i), p1=getCenter(i+1);
      const pos=[lerp(p0[0],p1[0],t), lerp(p0[1],p1[1],t), lerp(p0[2],p1[2],t)];
      const {T,R,B}=basisAt(i);
      return {pos:[pos[0]+R[0]*this.off,pos[1]+R[1]*this.off,pos[2]+R[2]*this.off], T,R,B};
    }
  };
}

/* ---------- 카메라(고정 추적, 더 멀게/높게 + 속도 따라 약간 줌아웃) ---------- */
function chaseVP(car, aspect){
  const w=car.world();
  const backBase=12.5, upBase=4.2;
  const extra = car.v*0.08; // 속도에 따른 줌아웃
  const eye=[ w.pos[0]-w.T[0]*(backBase+extra), w.pos[1]+(upBase+extra*0.15), w.pos[2]-w.T[2]*(backBase+extra) ];
  const at =[ w.pos[0]+w.T[0]*6.0, w.pos[1]+0.8, w.pos[2]+w.T[2]*6.0 ];
  const up=[0,1,0];
  const V=M.look(eye,at,up);
  const P=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
  const fov=58*Math.PI/180, f=1/Math.tan(fov/2), near=0.1, far=1500, nf=1/(near-far);
  P[0]=f/((aspect>0)?aspect:1); P[5]=f; P[10]=(far+near)*nf; P[11]=-1; P[14]=(2*far*near)*nf; P[15]=0;
  return M.mul(P,V);
}

/* ---------- 드로우 ---------- */
function drawBuf(buf,count,mode){ if(!buf||!count) return; gl.bindBuffer(gl.ARRAY_BUFFER,buf.pos.b); gl.enableVertexAttribArray(loc.aPos); gl.vertexAttribPointer(loc.aPos,buf.pos.item,buf.pos.type,false,0,0); gl.bindBuffer(gl.ARRAY_BUFFER,buf.col.b); gl.enableVertexAttribArray(loc.aCol); gl.vertexAttribPointer(loc.aCol,buf.col.item,buf.col.type,false,0,0); gl.bindBuffer(gl.ARRAY_BUFFER,buf.glow.b); gl.enableVertexAttribArray(loc.aGlow); gl.vertexAttribPointer(loc.aGlow,buf.glow.item,buf.glow.type,false,0,0); gl.drawArrays(mode,0,count); }
function drawCar(VP,car){ const Mcar = carModelMatrix(car.world()); const VPc = M.mul(VP, Mcar); gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VPc)); gl.drawArrays(gl.TRIANGLES, 0, carGeom.verts); }

/* ---------- 게임 컨트롤 ---------- */
let car1=makeCar(input1), car2=makeCar(input2), aiCars=[];
const LAPS=3;
const START_OFFSET_FRAC=0.25; // 결승선에서 25% 떨어진 지점에 배치
function placeAtStart(c, lane=0){
  c.s = (samples*START_OFFSET_FRAC)|0;
  c.prevS = c.s; // 랩 감지 초기화
  c.off = lane;
  c.offV=0; c.v=0; c.lap=0; c.finished=false; c.lastLapTs=0;
}
function resetCars(){
  car1=makeCar(input1); car1.name='P1'; placeAtStart(car1, 0);
  car2=makeCar(input2); car2.name='P2'; if(cfg.twoP) placeAtStart(car2, trackW*0.15);
  aiCars=[]; for(let i=0;i<cfg.aiCount;i++){ const ai=makeCar(null); ai.name='AI'+(i+1); placeAtStart(ai, ((i%4)-1.5)*trackW*0.22); ai.v=20; aiCars.push(ai); }
}
function updateAI(dt){
  for(const ai of aiCars){
    ai.v=clamp(ai.v + (30 - 6.5)*dt, 0, 42);
    const aim=ai.off; // 이미 lane으로 세팅됨
    const spring=4.5,damp=3.2;
    const force=(aim - ai.off)*spring - ai.offV*damp;
    ai.offV += force*dt;
    ai.s = (ai.s + ai.v*dt) % samples;
  }
}
function positions(){
  const all=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars];
  const arr=all.map(c=>({c,progress:c.lap*samples + c.s})).sort((a,b)=>b.progress-a.progress);
  return arr.map(x=>x.c);
}

/* ---------- 빌드 & 초기화 ---------- */
function applyTheme(key){ document.body.style.background=THEMES[key].bg(); carGeom=makeCarGeom(THEMES[key].car); buildTrack(key); renderOnce(); }
function renderScene(VP, tSec){
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VP)); gl.uniform1f(loc.uTime, tSec);
  drawBuf(geoBuf, geoVerts, gl.TRIANGLES);
  drawBuf(envBuf, envVerts, gl.POINTS);
  drawBuf(propBuf, propVerts, gl.POINTS);
  drawBuf(tracksideBuf, tracksideVerts, gl.TRIANGLES);
  drawBuf(tunnelBuf, tunnelVerts, gl.TRIANGLES);
  drawBuf(bufRail, railVerts, gl.POINTS);
  drawBuf(bufRibbon, verts, gl.TRIANGLE_STRIP);
  if(snowBuf) drawBuf(snowBuf, snowVerts, gl.POINTS);
  if(ashBuf) drawBuf(ashBuf, ashVerts, gl.POINTS);
}
function renderOnce(){
  const tSec=performance.now()/1000; gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  if(!cfg.twoP){ const VP=chaseVP(car1, CW/CH); renderScene(VP,tSec); drawCar(VP,car1); for(const ai of aiCars) drawCar(VP,ai); }
  else{
    const half=CW>>1;
    gl.viewport(0,0,half,CH); const VP1=chaseVP(car1, (half)/CH); renderScene(VP1,tSec); drawCar(VP1,car1); for(const ai of aiCars) drawCar(VP1,ai);
    gl.viewport(half,0,CW-half,CH); const VP2=chaseVP(car2, (CW-half)/CH); renderScene(VP2,tSec); drawCar(VP2,car2); for(const ai of aiCars) drawCar(VP2,ai);
    gl.viewport(0,0,CW,CH);
  }
}

/* ---------- 랩/결승선 판정 ---------- */
function checkLaps(dt){
  const now=performance.now();
  const racers=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars];
  for(const c of racers){
    const wrapped = (c.prevS > samples*0.75) && (c.s < samples*0.25); // 큰값 → 작은값으로 넘어가면 랩 완료
    if(wrapped && now - c.lastLapTs > 2000 && c.v>6){ // 쿨다운 + 최소 속도
      c.lap++; c.lastLapTs = now;
      if(c===car1) setHUD('uiLap', `${Math.min(c.lap,LAPS)}/${LAPS}`);
      if(c.lap>=LAPS) c.finished=true;
    }
  }
}

/* ---------- 루프 ---------- */
const S={MENU:0,PLAY:1,PAUSE:2,RESULT:3}; let state=S.MENU; let last=performance.now();
function frame(){
  const now=performance.now(), dt=Math.min((now-last)/1000, 0.06); last=now; const tSec=now/1000;
  if(state===S.PLAY){
    car1.update(dt); if(cfg.twoP) car2.update(dt);
    updateAI(dt);
    checkLaps(dt);

    const ps=positions();
    const posIdx=ps.findIndex(p=>p===car1)+1;
    setHUD('uiPos', (cfg.aiCount + (cfg.twoP?1:0) + 1)>1 ? `${posIdx}/${ps.length}` : 'Solo');
    setHUD('uiSpeed', Math.round(car1.v*3.6)+'');
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    if(!cfg.twoP){ const VP=chaseVP(car1, CW/CH); renderScene(VP,tSec); drawCar(VP,car1); for(const ai of aiCars) drawCar(VP,ai); }
    else{ const half=CW>>1;
      gl.viewport(0,0,half,CH); const VP1=chaseVP(car1, (half)/CH); renderScene(VP1,tSec); drawCar(VP1,car1); for(const ai of aiCars) drawCar(VP1,ai);
      gl.viewport(half,0,CW-half,CH); const VP2=chaseVP(car2, (CW-half)/CH); renderScene(VP2,tSec); drawCar(VP2,car2); for(const ai of aiCars) drawCar(VP2,ai);
      gl.viewport(0,0,CW,CH);
    }

    const all=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars];
    if(all.every(c=>c.finished || c.lap>=LAPS)){
      state=S.RESULT;
      const order=positions();
      const rows=order.map((c,i)=>`<tr><td>${i+1}</td><td>${c.name}</td><td>${(c.lap>=LAPS)?'FINISH':'DNF'}</td></tr>`).join('');
      panel(`<h1>🏁 결과</h1><table style="width:100%;text-align:center;border-collapse:collapse"><thead><tr><th>순위</th><th>이름</th><th>상태</th></tr></thead><tbody>${rows}</tbody></table><div style="margin-top:10px"><button class="btn" id="btnAgain">다시</button></div>`);
      document.getElementById('btnAgain').onclick=()=>{clearPanel(); reset();};
    }
    requestAnimationFrame(frame);
  }
}

/* ---------- UI 버튼 ---------- */
document.getElementById('btnPlay').onclick=()=>{ if(state!==S.PLAY){ clearPanel(); state=S.PLAY; last=performance.now(); frame(); }};
document.getElementById('btnPause').onclick=()=>{ if(state===S.PLAY){ state=S.PAUSE; panel(`<h1>⏸ 일시정지</h1><div><button class="btn" id="btnResume">▶ 계속</button><button class="btn" id="btnMenu">메뉴</button></div>`); document.getElementById('btnResume').onclick=()=>{clearPanel(); state=S.PLAY; last=performance.now(); frame();}; document.getElementById('btnMenu').onclick=()=>{state=S.MENU; showMenu();}; } };
function reset(){ buildTrack(cfg.theme); resetCars(); setHUD('uiLap',`0/${LAPS}`); setHUD('uiSpeed','0'); setHUD('uiPos', cfg.aiCount>0?`1/${1+cfg.aiCount+(cfg.twoP?1:0)}`:'Solo'); renderOnce(); showMenu();}
document.getElementById('btnReset').onclick=reset;
document.getElementById('btnReroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); reset(); };
document.getElementById('btnShape').onclick=()=>{ const idx=(SHAPES.indexOf(cfg.shape)+1)%SHAPES.length; cfg.shape=SHAPES[idx]; store.set(cfg); document.getElementById('btnShape').textContent='🛣 '+cfg.shape; reset(); };
document.getElementById('btnAI').onclick=()=>{ cfg.aiCount=(cfg.aiCount+1)%5; store.set(cfg); document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount; reset(); };
document.getElementById('btn2P').onclick=()=>{ cfg.twoP=!cfg.twoP; store.set(cfg); document.getElementById('btn2P').textContent= cfg.twoP?'👥 2P':'👥 1P'; reset(); };
document.getElementById('btnMobile').onclick=()=>{ cfg.mobile=!cfg.mobile; store.set(cfg); document.getElementById('btnMobile').textContent= cfg.mobile?'📱 Mobile: ON':'📱 Mobile: OFF'; padL.style.display=padR.style.display=cfg.mobile?'flex':'none'; };
document.getElementById('selTheme').value=cfg.theme;
document.getElementById('selTheme').onchange=(e)=>{ cfg.theme=e.target.value; store.set(cfg); applyTheme(cfg.theme); resetCars(); };

/* ---------- 메뉴 ---------- */
function showMenu(){
  const help=`<div class="keys">
  <b>1P</b>: W 가속 / S 브레이크 / A◀ D▶ / Space 드리프트<br/>
  <b>2P</b>: ↑ 가속 / ↓ 브레이크 / ←◀ →▶ / / 드리프트<br/>
  모바일: 좌측 ◀▶ / 우측 DRIFT, 가속, 브레이크
  </div>`;
  panel(`<h1>🏎 시작할 준비!</h1>${help}<div style="margin-top:10px"><button class="btn" id="start">▶ 시작</button></div>`);
  document.getElementById('start').onclick=()=>{ clearPanel(); state=S.PLAY; last=performance.now(); frame(); };
}

/* ---------- 시작 ---------- */
applyTheme(cfg.theme); resetCars(); setHUD('uiLap',`0/${LAPS}`); setHUD('uiPos', cfg.aiCount>0?`1/${1+cfg.aiCount+(cfg.twoP?1:0)}`:'Solo');
document.getElementById('btnShape').textContent='🛣 '+cfg.shape;
document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount;
document.getElementById('btn2P').textContent= cfg.twoP?'👥 2P':'👥 1P';
document.getElementById('btnMobile').textContent= cfg.mobile?'📱 Mobile: ON':'📱 Mobile: OFF';
padL.style.display=padR.style.display=cfg.mobile?'flex':'none';
showMenu(); renderOnce();
})();</script>
</body>
</html>
