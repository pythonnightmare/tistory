<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>벡터 레이싱</title>
<style>
  :root{ --bg:#070a16; --bg2:#0b1230; --ink:#eaf2ff; --muted:#9aa9c6; --glass:rgba(10,14,34,.82) }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1000px 520px at 80% -10%,#182555 0%,transparent 52%),linear-gradient(180deg,var(--bg),var(--bg2));color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;user-select:none;-webkit-user-select:none;overscroll-behavior:none}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  .card{position:relative;border:1px solid rgba(255,255,255,.1);border-radius:18px;background:rgba(255,255,255,.04);box-shadow:0 12px 48px rgba(0,0,0,.45);overflow:hidden}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  .title{display:flex;gap:10px;align-items:center;font-weight:800}
  .stats{display:flex;gap:16px;align-items:center}
  .stat{font-variant-numeric:tabular-nums}
  .stat .label{font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn,.select{appearance:none;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:var(--ink);padding:7px 10px;border-radius:10px;font-weight:800;cursor:pointer}
  .view{position:relative;width:100%;height:min(56.25vw,700px);background:#050812;touch-action:none}
  canvas{display:block;width:100%;height:100%}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .panel{pointer-events:auto;background:var(--glass);border:1px solid rgba(255,255,255,.16);border-radius:18px;padding:18px;max-width:760px;width:min(92%,760px);text-align:center;box-shadow:0 16px 70px rgba(0,0,0,.55)}
  .panel h1{margin:0 0 10px}
  .keys{margin-top:8px;font-size:12px;color:var(--muted)}
  /* 모바일 패드 */
  .padL,.padR{position:absolute;bottom:12px;gap:12px;pointer-events:auto;display:none}
  .padL{left:12px}
  .padR{right:12px;flex-direction:column;align-items:flex-end}
  .pbtn{min-width:92px;min-height:92px;border-radius:20px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.10);color:#fff;font-weight:900;font-size:18px}
  .pbtn.small{min-width:88px;min-height:66px}
  .row{display:flex;gap:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="hud">
      <div class="title">🏁 벡터 레이싱 (by soo)</div>
      <div class="stats">
        <div class="stat" id="uiSpeed"><span class="label">SPEED</span> <b class="val">0</b></div>
        <div class="stat" id="uiLap"><span class="label">LAP</span> <b class="val">0/3</b></div>
        <div class="stat" id="uiPos"><span class="label">POS</span> <b class="val">Solo</b></div>
        <div class="stat" id="uiBest"><span class="label">BEST</span> <b class="val">—</b></div>
      </div>
      <div class="controls">
        <button class="btn" id="btnPlay">▶ 시작</button>
        <button class="btn" id="btnPause">⏸ 일시정지</button>
        <button class="btn" id="btnReset">↻ 리셋</button>
        <button class="btn" id="btnReroll">🎲 새 트랙</button>
        <button class="btn" id="btnShape">🛣 RANDOM</button>
        <button class="btn" id="btnAI">🤖 AI: 0</button>
        <button class="btn" id="btn2P">👥 1P</button>
        <button class="btn" id="btnMobile">📱 Mobile: OFF</button>
        <label style="font-size:12px;color:#9aa9c6">테마</label>
        <select class="select" id="selTheme">
          <option value="SPACE">SPACE</option>
          <option value="CYBERPUNK">CYBERPUNK</option>
          <option value="XMAS">XMAS</option>
          <option value="NEON">NEON</option>
          <option value="VOLCANO">VOLCANO</option>
        </select>
      </div>
    </div>

    <div class="view" id="view">
      <canvas id="gl"></canvas>
      <div class="overlay" id="overlay"></div>
      <!-- 모바일 패드 -->
      <div class="padL" id="padL">
        <button class="pbtn" data-act="L">◀</button>
        <button class="pbtn" data-act="R">▶</button>
      </div>
      <div class="padR" id="padR">
        <button class="pbtn" data-act="DR">DRIFT</button>
        <div class="row">
          <button class="pbtn small" data-act="ACC">가속</button>
          <button class="pbtn small" data-act="BR">브레이크</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(()=>{'use strict';
/* ---------- 안전 ---------- */
const overlay=document.getElementById('overlay');
const panel=(html)=>overlay.innerHTML=`<div class="panel">${html}</div>`;
const clearPanel=()=>overlay.innerHTML='';
addEventListener('error',e=>panel(`<h1>⚠ 오류</h1><pre style="text-align:left;white-space:pre-wrap">${e.message||e}</pre>`));
addEventListener('unhandledrejection',e=>panel(`<h1>⚠ 오류</h1><pre style="text-align:left;white-space:pre-wrap">${(e.reason&&e.reason.message)||e.reason||e}</pre>`));

/* ---------- 유틸 ---------- */
const DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const mixV=(a,b,t)=>[lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t)];
const mulberry32=a=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296};
const hashStr=s=>{let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;};
const saveKey='vector_racing_v24';
const store={get(){try{return JSON.parse(localStorage.getItem(saveKey)||'{}')}catch(e){return{}}},set(v){localStorage.setItem(saveKey,JSON.stringify(v))}};

/* ---------- 상태 ---------- */
const SHAPES=['RANDOM','OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY'];
const cfg=Object.assign({seed:(Math.random()*1e9)|0,theme:'SPACE',shape:'RANDOM',aiCount:1,twoP:false,mobile:false,best:null}, store.get());

/* ---------- WebGL ---------- */
const view=document.getElementById('view'), canvas=document.getElementById('gl');
const gl=canvas.getContext('webgl',{antialias:false,preserveDrawingBuffer:false});
if(!gl){ panel('<h1>⚠ WebGL 미지원</h1>'); return; }
let CW=2,CH=2;
function applyViewport(){const r=view.getBoundingClientRect(); CW=(r.width*DPR)|0; CH=(r.height*DPR)|0; canvas.width=CW; canvas.height=CH; gl.viewport(0,0,CW,CH);}
applyViewport(); new ResizeObserver(applyViewport).observe(view);
gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);

/* ---------- 셰이더 ---------- */
function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||'shader'); return s;}
function prog(vs,fs){const p=gl.createProgram(); gl.attachShader(p,compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)||'link'); return p;}
const VS=`
attribute vec3 aPos; attribute vec3 aCol; attribute float aGlow;
uniform mat4 uVP; uniform float uTime;
varying vec3 vCol; varying float vGlow;
void main(){
  vCol=aCol; float g=aGlow; vec3 p=aPos;
  if(g<0.0){ // 낙하 파티클(눈/재)
    float ph = fract(abs(g));
    float t = fract(uTime*(0.08+ph*0.12) + ph);
    p.y = -12.0 + t * 220.0;
    g = 0.65 + ph*0.2;
  }
  vGlow=g;
  gl_Position = uVP * vec4(p,1.0);
  gl_PointSize = 2.0 + 10.0*abs(vGlow);
}`;
const FS=`
precision mediump float;
varying vec3 vCol; varying float vGlow;
uniform float uPass; // 0=불투명, 1=글로우(가산)
void main(){
  float a = (uPass>0.5) ? clamp(0.06 + abs(vGlow)*0.9, 0.0, 1.0) : 1.0;
  gl_FragColor = vec4(vCol, a);
}`;
const program=prog(VS,FS); gl.useProgram(program);
const loc={aPos:gl.getAttribLocation(program,'aPos'), aCol:gl.getAttribLocation(program,'aCol'), aGlow:gl.getAttribLocation(program,'aGlow'), uVP:gl.getUniformLocation(program,'uVP'), uTime:gl.getUniformLocation(program,'uTime'), uPass:gl.getUniformLocation(program,'uPass')};

/* ---------- 매트릭스/버퍼 ---------- */
function makeBuffer(data,item=3,type=gl.FLOAT){const b=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,b); gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW); return {b,item,type};}
function bind(buf,loc){gl.bindBuffer(gl.ARRAY_BUFFER,buf.b); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,buf.item,buf.type,false,0,0);}
const M={
  mul:(a,b)=>{const o=new Array(16); for(let r=0;r<4;r++) for(let c=0;c<4;c++){o[c*4+r]=a[r]*b[c*4]+a[r+4]*b[c*4+1]+a[r+8]*b[c*4+2]+a[r+12]*b[c*4+3];} return o;},
  T:(x,y,z)=>[1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1],
  F:(R,B,T,P)=>[ R[0],R[1],R[2],0,  B[0],B[1],B[2],0,  T[0],T[1],T[2],0,  P[0],P[1],P[2],1 ],
  look:(eye,at,up, safe=false)=>{
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]];
    const norm=v=>{const l=Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l]};
    const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
    const z = norm(sub(eye, at));   // 뒤를 보는 z (표준 lookAt)
    let x = cross(up, z);
    let lx = Math.hypot(x[0],x[1],x[2]);
    if (safe && lx < 1e-3) x = [1,0,0]; else x = [x[0]/lx, x[1]/lx, x[2]/lx];
    const y = cross(z, x);
    const RT=[x[0],x[1],x[2],0, y[0],y[1],y[2],0, z[0],z[1],z[2],0, 0,0,0,1];
    return M.mul(RT, M.T(-eye[0],-eye[1],-eye[2]));
  }
};

/* ---------- 트랙/곡선 ---------- */
let samples=5200, trackW=8, CP=[], centerline=[], bufRibbon=null, bufRail=null, verts=0, railVerts=0, trackMaxR=140, trackMinR=40;
const WORLD_UP=[0,1,0];
const getCenter=i=>{const N=samples; const idx=((i%N)+N)%N; return [centerline[idx*3],centerline[idx*3+1],centerline[idx*3+2]]};
function catmull(p0,p1,p2,p3,t){const t2=t*t,t3=t2*t;
  return [0.5*((2*p1[0])+(-p0[0]+p2[0])*t+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3),
          0.5*((2*p1[1])+(-p0[1]+p2[1])*t+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3),
          0.5*((2*p1[2])+(-p0[2]+p2[2])*t+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3)];
}
function catmullTangent(p0,p1,p2,p3,t){const t2=t*t;
  return [0.5*((-p0[0]+p2[0])+2*(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t+3*(-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t2),
          0.5*((-p0[1]+p2[1])+2*(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t+3*(-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t2),
          0.5*((-p0[2]+p2[2])+2*(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t+3*(-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t2)];
}
function basisAt(i){
  const p0=getCenter(i), p1=getCenter(i+1);
  const v=[p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]]; const l=Math.hypot(v[0],v[1],v[2])||1;
  const T=[v[0]/l,v[1]/l,v[2]/l];
  let R=[T[1]*WORLD_UP[2]-T[2]*WORLD_UP[1], T[2]*WORLD_UP[0]-T[0]*WORLD_UP[2], T[0]*WORLD_UP[1]-T[1]*WORLD_UP[0]];
  const rl=Math.hypot(R[0],R[1],R[2])||1; R=[R[0]/rl,R[1]/rl,R[2]/rl];
  const B=[R[1]*T[2]-R[2]*T[1], R[2]*T[0]-R[0]*T[2], R[0]*T[1]-R[1]*T[0]];
  return {T,R,B};
}
function computeTrackRadii(){ trackMaxR=0; trackMinR=1e9; for(let i=0;i<centerline.length;i+=3){const r=Math.hypot(centerline[i],centerline[i+2]); trackMaxR=Math.max(trackMaxR,r); trackMinR=Math.min(trackMinR,r);} }
function genCP(seed,shape,yAmp,baseY){
  const rng=mulberry32(seed|0),rand=(a,b)=>a+(b-a)*rng(); let arr=[],N=60,R=155,ph=rand(0,Math.PI*2);
  if(shape==='RANDOM'){const list=['OVAL','FIG8','CLOVER','S_BEND','ISLAND','LEMNISCATE','WAVY']; shape=list[(rng()*list.length)|0];}
  for(let i=0;i<N;i++){const t=i/N*2*Math.PI; let x=0,z=0;
    if(shape==='OVAL'){const rx=R*(1.3+0.18*Math.sin(3*t+ph)), rz=R*(0.95+0.18*Math.sin(2*t+ph)); x=rx*Math.cos(t); z=rz*Math.sin(t);}
    else if(shape==='FIG8'){x=R*1.0*Math.sin(2*t); z=R*0.8*Math.sin(t); x+=24*Math.sin(3*t+ph);}
    else if(shape==='CLOVER'){const rad=R*(1+0.35*Math.sin(3*t+ph)); x=rad*Math.cos(t); z=rad*Math.sin(t);}
    else if(shape==='S_BEND'){x=R*1.2*Math.cos(t)+36*Math.sin(2*t); z=R*0.9*Math.sin(t);}
    else if(shape==='ISLAND'){const rad2=R*(0.92+0.22*Math.sin(3*t+ph))*(0.94+rand(0,0.18)); x=rad2*Math.cos(t); z=rad2*Math.sin(t);}
    else if(shape==='LEMNISCATE'){const a=R*0.98,s=Math.sin(t),c=Math.cos(t); x=(a*Math.sqrt(2)*c)/(1+s*s); z=(a*Math.sqrt(2)*c*s)/(1+s*s);}
    else if(shape==='WAVY'){const rx2=R*(1+0.30*Math.sin(4*t+ph)), rz2=R*(1+0.28*Math.cos(3*t+ph)); x=rx2*Math.cos(t); z=rz2*Math.sin(t);}
    const y=baseY+rand(-yAmp,yAmp)*(0.6+0.4*Math.sin(2*t+ph)); arr.push([x,y,z]); }
  arr.push(arr[0],arr[1],arr[2]); return arr;
}

/* ---------- 그리기 패스 ---------- */
function drawSolid(buf,count,mode){ if(!buf||!count) return; gl.disable(gl.BLEND); gl.uniform1f(loc.uPass,0.0); bind(buf.pos,loc.aPos); bind(buf.col,loc.aCol); bind(buf.glow,loc.aGlow); gl.drawArrays(mode,0,count); }
function drawGlow(buf,count,mode){ if(!buf||!count) return; gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE); gl.uniform1f(loc.uPass,1.0); bind(buf.pos,loc.aPos); bind(buf.col,loc.aCol); bind(buf.glow,loc.aGlow); gl.drawArrays(mode,0,count); }

/* ---------- 지오 빌더 ---------- */
const makeGeo=()=>({pos:[],col:[],glow:[]});
const pushTri=(o,a,b,c,d,e,f,g,h,i,C,G)=>{o.pos.push(a,b,c,d,e,f,g,h,i); o.col.push(C[0],C[1],C[2],C[0],C[1],C[2],C[0],C[1],C[2]); o.glow.push(G,G,G)};
const pushQuad=(o,a,b,c,d,e,f,g,h,i,j,k,l,C,G)=>{pushTri(o,a,b,c,d,e,f,g,h,i,C,G); pushTri(o,a,b,c,g,h,i,j,k,l,C,G)};
const pushBox=(o,cx,cy,cz,sx,sy,sz,ct,cs,g=0.0)=>{const x=sx/2,y=sy/2,z=sz/2;
  pushQuad(o,cx-x,cy+y,cz-z,cx+x,cy+y,cz-z,cx+x,cy+y,cz+z,cx-x,cy+y,cz+z,ct,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx+x,cy-y,cz+z,cx+x,cy-y,cz-z,cx-x,cy-y,cz-z,cs,g);
  pushQuad(o,cx-x,cy-y,cz-z,cx-x,cy+y,cz-z,cx-x,cy+y,cz+z,cx-x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz+z,cx+x,cy+y,cz+z,cx+x,cy+y,cz-z,cx+x,cy-y,cz-z,cs,g);
  pushQuad(o,cx-x,cy-y,cz+z,cx-x,cy+y,cz+z,cx+x,cy+y,cz+z,cx+x,cy-y,cz+z,cs,g);
  pushQuad(o,cx+x,cy-y,cz-z,cx+x,cy+y,cz-z,cx-x,cy+y,cz-z,cx-x,cy-y,cz-z,cs,g);
};
function addSphere(G,cx,cy,cz,R,lat=28,lon=42,col=[1,1,1],glw=0){
  for(let a=0;a<lat;a++){
    const v0=a/lat*Math.PI, v1=(a+1)/lat*Math.PI;
    for(let b=0;b<lon;b++){
      const u0=b/lon*2*Math.PI,u1=(b+1)/lon*2*Math.PI;
      const p=(v,u)=>[cx+R*Math.sin(v)*Math.cos(u), cy+R*Math.cos(v), cz+R*Math.sin(v)*Math.sin(u)];
      const A=p(v0,u0),B=p(v0,u1),C=p(v1,u1),D=p(v1,u0);
      pushQuad(G,A[0],A[1],A[2],B[0],B[1],B[2],C[0],C[1],C[2],D[0],D[1],D[2],col,glw);
}}}
function addCylinder(G,cx,cy,cz,r,h,seg=48,colTop=[1,1,1],colSide=[1,1,1],glw=0){
  const y0=cy-h/2,y1=cy+h/2;
  for(let i=0;i<seg;i++){
    const a0=i/seg*2*Math.PI,a1=(i+1)/seg*2*Math.PI;
    const x0=cx+r*Math.cos(a0), z0=cz+r*Math.sin(a0);
    const x1=cx+r*Math.cos(a1), z1=cz + r*Math.sin(a1); /* ★ FIX */
    pushQuad(G,x0,y0,z0,x1,y0,z1,x1,y1,z1,x0,y1,z0,colSide,glw);
  }
}
function addCone(G,cx,cy,cz,r,h,seg=48,col=[1,1,1],glw=0){
  const tip=[cx,cy+h/2,cz], y0=cy-h/2;
  for(let i=0;i<seg;i++){
    const a0=i/seg*2*Math.PI,a1=(i+1)/seg*2*Math.PI;
    const x0=cx+r*Math.cos(a0), z0=cz+r*Math.sin(a0);
    const x1=cx+r*Math.cos(a1), z1=cz + r*Math.sin(a1); /* ★ FIX */
    pushTri(G, tip[0],tip[1],tip[2], x0,y0,z0, x1,y0,z1, col,glw);
  }
}
function addTorus(G,cx,cy,cz,R,r,segR=48,segr=24,col=[1,1,1],glw=0.6){
  for(let i=0;i<segR;i++){
    const u0=i/segR*2*Math.PI,u1=(i+1)/segR*2*Math.PI;
    for(let j=0;j<segr;j++){
      const v0=j/segr*2*Math.PI,v1=(j+1)/segr*2*Math.PI;
      const p=(u,v)=>[cx+(R+r*Math.cos(v))*Math.cos(u), cy+r*Math.sin(v), cz+(R+r*Math.cos(v))*Math.sin(u)];
      const A=p(u0,v0),B=p(u1,v0),C=p(u1,v1),D=p(u0,v1);
      pushQuad(G, A[0],A[1],A[2], B[0],B[1],B[2], C[0],C[1],C[2], D[0],D[1],D[2], col, glw);
}}}

/* ---------- 테마 ---------- */
const THEMES={
  SPACE:{bg:()=>`radial-gradient(1200px 700px at 70% -10%, #0b1740 0%, transparent 55%), linear-gradient(180deg,#030616,#071531)`,trackC1:[0.58,0.82,1.0],trackC2:[0.62,0.4,1.0],rail:[0.9,0.95,1],trackW:7.8,baseY:1.6,yAmp:6,car:[0.9,0.95,1],fog:[0.02,0.04,0.09],ground:false},
  CYBERPUNK:{bg:()=>`radial-gradient(800px 500px at 80% -10%, #461058 0%, transparent 50%), linear-gradient(180deg,#16061e,#090a18)`,trackC1:[1.0,0.2,0.8],trackC2:[0.2,1.0,0.9],rail:[1,0.7,1],trackW:8.5,baseY:0.6,yAmp:2.2,car:[1.0,0.3,0.9],fog:[0.06,0.02,0.10],ground:true},
  XMAS:{bg:()=>`radial-gradient(1000px 600px at 60% -10%, #0e1b3a 0%, transparent 52%), linear-gradient(180deg,#081226,#0a1a33)`,trackC1:[0.0,0.9,0.3],trackC2:[1.0,0.1,0.1],rail:[1,1,1],trackW:8.8,baseY:0.6,yAmp:1.0,car:[0.9,0.1,0.1],fog:[0.03,0.05,0.08],ground:true},
  NEON:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #103b6b 0%, transparent 52%), linear-gradient(180deg,#081022,#0a0f28)`,trackC1:[0.2,0.9,1.0],trackC2:[1.0,0.5,0.2],rail:[0.8,1,1],trackW:7.6,baseY:1.0,yAmp:3.2,car:[0.2,0.9,1.0],fog:[0.02,0.05,0.12],ground:true},
  VOLCANO:{bg:()=>`radial-gradient(900px 540px at 85% -10%, #3b0f0f 0%, transparent 52%), linear-gradient(180deg,#140606,#230a0a)`,trackC1:[1.0,0.5,0.0],trackC2:[0.9,0.2,0.1],rail:[1,0.85,0.7],trackW:9.0,baseY:0.4,yAmp:1.8,car:[1.0,0.4,0.05],fog:[0.06,0.02,0.02],ground:true}
};
document.body.style.background=THEMES[cfg.theme].bg();

/* ---------- 버퍼 핸들 ---------- */
let envBuf=null,envVerts=0,propBuf=null,propVerts=0,geoBuf=null,geoVerts=0,centerBuf=null,centerVerts=0,tunnelBuf=null,tunnelVerts=0,tunnelGlowBuf=null,tunnelGlowVerts=0,tracksideBuf=null,tracksideVerts=0,snowBuf=null,snowVerts=0,ashBuf=null,ashVerts=0;

/* ---------- 환경/오브젝트 ---------- */
function buildTrack(theme){
  const T=THEMES[theme], seed2=(cfg.seed^hashStr(theme)^hashStr(cfg.shape))>>>0;
  trackW=T.trackW*2.0;
  const CPs=genCP(seed2,cfg.shape,T.yAmp,T.baseY); CP=CPs; centerline=[]; verts=0; railVerts=0;
  const p=[],c=[],g=[], rp=[],rc=[],rg=[]; const Ls=CP.length-3,maxSeg=Ls-1e-6;
  for(let i=0;i<samples;i++){
    const seg=i/(samples-1)*maxSeg,j=Math.floor(seg),t=seg-j;
    const P=catmull(CP[j],CP[j+1],CP[j+2],CP[j+3],t), d=catmullTangent(CP[j],CP[j+1],CP[j+2],CP[j+3],t);
    let Rv=[d[1]*WORLD_UP[2]-d[2]*WORLD_UP[1], d[2]*WORLD_UP[0]-d[0]*WORLD_UP[2], d[0]*WORLD_UP[1]-d[1]*WORLD_UP[0]];
    const rl=Math.hypot(Rv[0],Rv[1],Rv[2])||1; Rv=[Rv[0]/rl,Rv[1]/rl,Rv[2]/rl];
    centerline.push(P[0],P[1],P[2]);
    if(i<samples-1){
      const L= [P[0]-Rv[0]*trackW*0.5, P[1]-Rv[1]*trackW*0.5, P[2]-Rv[2]*trackW*0.5];
      const R= [P[0]+Rv[0]*trackW*0.5, P[1]+Rv[1]*trackW*0.5, P[2]+Rv[2]*trackW*0.5];
      p.push(L[0],L[1],L[2], R[0],R[1],R[2]); c.push(...T.trackC1, ...T.trackC2); g.push(0.0,0.0); verts+=2;
      rp.push(L[0],L[1]+0.10,L[2], R[0],R[1]+0.10,R[2]); rc.push(...T.rail, ...T.rail); rg.push(1.2,1.2); railVerts+=2;
    }
  }
  gl.clearColor(T.fog[0],T.fog[1],T.fog[2],1);
  bufRibbon={pos:makeBuffer(new Float32Array(p),3),col:makeBuffer(new Float32Array(c),3),glow:makeBuffer(new Float32Array(g),1)};
  bufRail  ={pos:makeBuffer(new Float32Array(rp),3),col:makeBuffer(new Float32Array(rc),3),glow:makeBuffer(new Float32Array(rg),1)};
  computeTrackRadii();
  buildEnv(theme,seed2); buildCenterpiece(theme,seed2); buildTunnels(theme,seed2); buildTrackside(theme,seed2);
}

function buildEnv(theme,seed2){
  envBuf=propBuf=geoBuf=snowBuf=ashBuf=null; envVerts=propVerts=geoVerts=snowVerts=ashVerts=0;
  const pts=[],cols=[],glows=[], GEO=makeGeo();
  const rng=mulberry32(seed2), t=THEMES[theme], ringR=trackMaxR+trackW*2.8, groundY=0;
  const pushP=(x,y,z,c,g)=>{pts.push(x,y,z); cols.push(c[0],c[1],c[2]); glows.push(g)}

  /* 지면 */
  if(t.ground){
    const rad=ringR+260, step=12;
    const baseCol=(theme==='XMAS')?[0.95,0.98,1]:(theme==='VOLCANO')?[0.25,0.08,0.06]:(theme==='CYBERPUNK')?[0.08,0.08,0.12]:[0.06,0.08,0.12];
    for(let x=-rad;x<rad;x+=step) for(let z=-rad;z<rad;z+=step){
      if(Math.hypot(x,z)<ringR-12) continue;
      const c0=[baseCol[0]*(0.94+0.12*rng()), baseCol[1]*(0.94+0.12*rng()), baseCol[2]*(0.94+0.12*rng())];
      pushQuad(GEO,x,groundY,z, x+step,groundY,z, x+step,groundY,z+step, x,groundY,z+step, c0,0.0);
    }
  }

  /* 배경 & 캐릭터 */
  if(theme==='SPACE'){
    const rngS=mulberry32(seed2^0x55aa);
    const starCount= cfg.mobile?1600:3200;
    for(let i=0;i<starCount;i++){const rr=ringR+20+rngS()*420,a=rngS()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=(rngS()*2-1)*320+90; pushP(rx,ry,rz,[0.82+rngS()*0.18,0.88+rngS()*0.12,1],0.06);}
    addSphere(GEO,Math.cos(0.7)*(ringR+300),160,Math.sin(0.7)*(ringR+300), 24, 18,28,[0.95,0.95,1.0],0.0);
    function addAlien(x,y,z,s=1){
      pushBox(GEO,x,y+0.8*s,z, 0.7*s,1.2*s,0.4*s, [0.75,0.85,1.0],[0.65,0.78,1.0],0.0);
      pushBox(GEO,x-0.45*s,y+0.75*s,z, 0.25*s,0.9*s,0.25*s,[0.72,0.84,1.0],[0.64,0.76,0.98],0.0);
      pushBox(GEO,x+0.45*s,y+0.75*s,z, 0.25*s,0.9*s,0.25*s,[0.72,0.84,1.0],[0.64,0.76,0.98],0.0);
      pushBox(GEO,x-0.18*s,y+0.2*s,z, 0.22*s,0.7*s,0.22*s,[0.7,0.82,0.98],[0.6,0.74,0.95],0.0);
      pushBox(GEO,x+0.18*s,y+0.2*s,z, 0.22*s,0.7*s,0.22*s,[0.7,0.82,0.98],[0.6,0.74,0.95],0.0);
      addSphere(GEO,x,y+1.6*s,z,0.42*s,16,22,[0.8,0.95,1.0],0.0);
      addSphere(GEO,x,y+1.55*s,z,0.30*s,14,18,[0.6,1.0,0.7],0.0);
    }
    for(let i=0;i<32;i++){ const r=ringR+60+Math.random()*260, a=Math.random()*Math.PI*2; addAlien(Math.cos(a)*r, 22+Math.random()*18, Math.sin(a)*r, 0.8+Math.random()*0.8); }

  } else if(theme==='CYBERPUNK'){
    const starN= cfg.mobile?1000:2200;
    for(let i=0;i<starN;i++){const rr=trackMaxR+260+Math.random()*420,a=Math.random()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=140+Math.random()*320; pushP(rx,ry,rz,[0.85+Math.random()*0.15,0.9+Math.random()*0.1,1],0.08);}
    function addWindows(cx,sy,cz,sx,sz){
      const strideX=2.2,strideY=2.6,strideZ=2.2;
      const halfX=sx/2,halfZ=sz/2,rows=Math.max(1,Math.floor((sy-3)/strideY));
      const colsX=Math.max(1,Math.floor((sx-3)/strideX)), colsZ=Math.max(1,Math.floor((sz-3)/strideZ));
      for(let iy=0;iy<rows;iy++){
        const y=-sy/2+2+iy*strideY;
        for(let ix=0;ix<colsX;ix++){const u=-halfX+2+ix*strideX; pushBox(GEO,cx+u, sy/2+y, cz+halfZ+0.05, 1.4,1.2,0.05, [0.2,0.9,1],[0.2,0.9,1],1.2); pushBox(GEO,cx+u, sy/2+y, cz-halfZ-0.05, 1.4,1.2,0.05,[0.2,0.9,1],[0.2,0.9,1],1.2);}
        for(let iz=0;iz<colsZ;iz++){const u=-halfZ+2+iz*strideZ; pushBox(GEO, cx+halfX+0.05, sy/2+y, cz+u, 0.05,1.2,1.4,[1,0.3,0.9],[1,0.3,0.9],1.1); pushBox(GEO, cx-halfX-0.05, sy/2+y, cz+u, 0.05,1.2,1.4,[1,0.3,0.9],[1,0.3,0.9],1.1); }
      }
    }
    for(let i=0;i<520;i++){
      const r=trackMaxR+trackW*2.8+12+Math.random()*320,a=Math.random()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r,sy=26+Math.random()*140;
      const sx=6+Math.random()*32, sz=6+Math.random()*32;
      pushBox(GEO,x,sy/2,z, sx,sy,sz, [0.08,0.1,0.14],[0.12,0.12,0.16],0.0);
      addWindows(x,sy,z,sx,sz);
    }

  } else if(theme==='XMAS'){
    const SCALE = 3.0;
    // 눈 파티클
    const sPos=[],sCol=[],sGlow=[]; const snowCount= cfg.mobile?2400:5200;
    for(let i=0;i<snowCount;i++){const rr=trackMaxR+trackW*2.6+40+Math.random()*340, aa=Math.random()*Math.PI*2, rx=Math.cos(aa)*rr, rz=Math.sin(aa)*rr, ry=140+Math.random()*300; sPos.push(rx,ry,rz); sCol.push(1,1,1); sGlow.push(-(0.4+Math.random()*0.6));}
    snowBuf={pos:makeBuffer(new Float32Array(sPos),3), col:makeBuffer(new Float32Array(sCol),3), glow:makeBuffer(new Float32Array(sGlow),1)}; snowVerts=sPos.length/3;

    function addWindowsRect(G,cx,cy,cz, sx,sy, sz, strideX=2.0,strideY=2.4, glowCol=[1,0.92,0.65]){
      const hx=sx/2, hy=sy/2, hz=sz/2;
      const win=(x,y,z,w,h)=>pushBox(G,x,y,z,w,h,0.06,glowCol,glowCol,1.15);
      for(let y=-hy+1.2;y<hy-1.2;y+=strideY)
        for(let x=-hx+1.4;x<hx-1.4;x+=strideX){ win(cx+x,cy+y,cz+hz+0.03,1.2,1.0); win(cx+x,cy+y,cz-hz-0.03,1.2,1.0); }
      for(let y=-hy+1.2;y<hy-1.2;y+=strideY)
        for(let z=-hz+1.4;z<hz-1.4;z+=strideX){ win(cx+hx+0.03,cy+y,cz+z,0.06,1.0); win(cx-hx-0.03,cy+y,cz+z,0.06,1.0); }
    }
    function addHouse(G,cx,cz, s=1){
      const sy=4.8*s, sx=6.2*s, sz=4.6*s, y=sy/2;
      pushBox(G,cx,y,cz, sx, sy, sz, [0.9,0.92,0.96],[0.86,0.88,0.93],0.0);
      pushBox(G,cx,sy+0.3,cz, sx+0.2, 0.6*s, sz+0.2,[0.2,0.22,0.28],[0.18,0.2,0.26],0.0);
      pushBox(G,cx,1.2*s,cz+sz/2+0.05, 1.4*s,2.2*s,0.06,[0.3,0.18,0.1],[0.3,0.18,0.1],0.0);
      addWindowsRect(G,cx,y,cz, sx-0.8, sy-1.6, sz-0.8, 2.0*s, 2.2*s, [1.0,0.92,0.7]);
      pushBox(G, cx+sx*0.28, sy+0.9, cz-sz*0.25, 0.7,1.2,0.7, [0.5,0.5,0.6],[0.45,0.45,0.55],0.0);
    }
    function addPine(G,cx,cy,cz, h, r){
      pushBox(G,cx,cy,cz, 0.9*SCALE, h*0.16, 0.9*SCALE, [0.5,0.3,0.2],[0.5,0.3,0.2],0.0);
      addCone(G,cx,cy+h*0.16/2+ h*0.30,cz, r*0.8, h*0.6, 40, [0.1,0.7,0.2],0.0);
      addCone(G,cx,cy+h*0.16/2+ h*0.55,cz, r*0.6, h*0.5, 40, [0.1,0.8,0.25],0.0);
      addCone(G,cx,cy+h*0.16/2+ h*0.75,cz, r*0.45, h*0.4, 40, [0.1,0.9,0.3],0.0);
    }
    function addSnowman(G,cx,cz, s=1){
      addSphere(G,cx, 0.9*s, cz, 0.9*s, 16,22,[1,1,1],0.0);
      addSphere(G,cx, 2.0*s, cz, 0.6*s, 16,22,[1,1,1],0.0);
      addSphere(G,cx, 2.8*s, cz, 0.42*s,14,18,[1,1,1],0.0);
    }
    function addSanta(G,x,z, s=1){
      pushBox(G,x,1.0*s,z, 0.9*s,1.2*s,0.6*s, [0.9,0.1,0.1],[0.8,0.1,0.1],0.0);
      addSphere(G,x,1.9*s,z,0.35*s,12,16,[1,0.92,0.85],0.0);
      addCone(G,x,2.4*s,z,0.40*s,0.7*s,28,[0.9,0.1,0.1],0.0);
    }
    function addRudolph(G,x,z, s=1){
      pushBox(G,x,0.8*s,z, 1.2*s,0.8*s,0.5*s,[0.55,0.3,0.18],[0.5,0.28,0.16],0.0);
      addSphere(G,x+0.7*s,1.2*s,z,0.25*s,12,16,[0.6,0.34,0.2],0.0);
      addSphere(G,x+0.9*s,1.2*s,z,0.12*s,10,12,[1,0.1,0.1],0.0);
    }

    const baseR=ringR+trackW*1.0+40;
    for(let i=0;i<260;i++){
      const r=baseR+Math.random()*260, a=Math.random()*Math.PI*2, x=Math.cos(a)*r, z=Math.sin(a)*r;
      if(Math.random()<0.6){
        const sc=(0.8+Math.random()*0.8)*SCALE;
        addHouse(GEO,x,z,sc);
        if(Math.random()<0.35){
          addSnowman(GEO, x+1.6*sc, z+1.0*sc, 0.7*SCALE);
        }
      } else {
        const n=2+(Math.random()*4|0);
        for(let k=0;k<n;k++){
          const ox=(Math.random()*3-1.5)*SCALE, oz=(Math.random()*3-1.5)*SCALE;
          const h=(8+Math.random()*6)*SCALE, rr=(2.0+Math.random()*1.4)*SCALE;
          addPine(GEO, x+ox,0, z+oz, h, rr);
        }
      }
      if(Math.random()<0.08){ addSanta(GEO, x+(Math.random()*2-1)*SCALE, z+(Math.random()*2-1)*SCALE, 1.0*SCALE); }
      if(Math.random()<0.08){ addRudolph(GEO, x-1.5*SCALE+Math.random()*3*SCALE, z-1.5*SCALE+Math.random()*3*SCALE, 1.0*SCALE); }
    }

  } else if(theme==='NEON'){
    const baseR=ringR+trackW*2.8+18;
    for(let ii=0;ii<36;ii++){const r=baseR+ii*10; for(let a=0;a<Math.PI;a+=Math.PI/28){const x=Math.cos(a)*r,y=Math.sin(a)*40+8,z=0; pushQuad(GEO,x,y,z, x+1.8,y,z, x+1.8,y+1.8,z, x,y+1.8,z, [0.2,0.8,1],0.0);} }

  } else if(theme==='VOLCANO'){
    for(let i=0;i<420;i++){const r=ringR+8+Math.random()*320,a=Math.random()*Math.PI*2,x=Math.cos(a)*r,z=Math.sin(a)*r,sy=9+Math.random()*40; pushBox(GEO,x,sy/2,z, 5,sy,5,[1,0.5,0.2],[1,0.35,0.15],0.0);}
    const aPos=[],aCol=[],aGlow=[]; const ashCount= cfg.mobile?2400:5200;
    for(let i=0;i<ashCount;i++){const rr=ringR+40+Math.random()*360,a=Math.random()*Math.PI*2,rx=Math.cos(a)*rr,rz=Math.sin(a)*rr,ry=160+Math.random()*260; aPos.push(rx,ry,rz); aCol.push(0.6,0.35,0.25); aGlow.push(-(0.2+Math.random()*0.4)); }
    ashBuf={pos:makeBuffer(new Float32Array(aPos),3), col:makeBuffer(new Float32Array(aCol),3), glow:makeBuffer(new Float32Array(aGlow),1)}; ashVerts=aPos.length/3;
  }

  if(pts.length){ envBuf={pos:makeBuffer(new Float32Array(pts),3), col:makeBuffer(new Float32Array(cols),3), glow:makeBuffer(new Float32Array(glows),1)}; envVerts=pts.length/3; }
  if(GEO.pos.length){ geoBuf={pos:makeBuffer(new Float32Array(GEO.pos),3), col:makeBuffer(new Float32Array(GEO.col),3), glow:makeBuffer(new Float32Array(GEO.glow),1)}; geoVerts=GEO.pos.length/3; }
}

/* ---------- 중앙 거대 조형물 ---------- */
function buildCenterpiece(theme,seed2){
  const G=makeGeo(); const safePad = trackW*0.8 + 16; const safeR = Math.max(18, trackMinR - safePad);
  const big = safeR*1.05; const med = safeR*0.7;
  if(theme==='SPACE'){
    addSphere(G,0,med*0.6,0, med*0.55, 36,56, [0.55,0.8,1],0.0);
    addTorus(G,0,med*0.6,0, med*1.0, med*0.08, 96,32, [0.6,0.9,1],0.0);
    for(let i=0;i<10;i++){ const a=i/10*2*Math.PI; const r=med*1.35; const x=Math.cos(a)*r, z=Math.sin(a)*r;
      pushBox(G,x,1.6,z, 0.6,1.1,0.4,[0.72,0.84,1.0],[0.64,0.76,0.98],0.0);
      addSphere(G,x,2.2,z,0.32,14,18,[0.6,1.0,0.7],0.0);
    }
  }
  else if(theme==='CYBERPUNK'){
    addCylinder(G,0,big*0.65,0, big*0.34, big*1.4, 84, [0.08,0.1,0.14],[0.12,0.12,0.16],0.0);
    addTorus(G,0,big*1.32,0, big*0.6, big*0.07, 88,30, [0.2,0.9,1],0.0);
  }
  else if(theme==='NEON'){
    addCylinder(G,0,big*0.9,0, big*0.26, big*1.7, 96, [0.1,0.12,0.18],[0.12,0.14,0.2],0.0);
    for(let i=-6;i<=6;i++){ addCylinder(G,i*big*0.12, big*1.6, 0, big*0.02, big*0.24, 24, [0.2,0.9,1],[0.2,0.9,1],0.0); }
  }
  else if(theme==='XMAS'){
    addCone(G,0,big*0.6,0, big*0.65, big*1.9, 96, [0.1,0.7,0.2],0.0);
    addCone(G,0,big*1.28,0, big*0.48, big*1.3, 96, [0.1,0.8,0.25],0.0);
    addCone(G,0,big*1.84,0, big*0.36, big*0.95, 96, [0.1,0.9,0.3],0.0);
    const starR=big*0.16, starY=big*2.28;
    for(let k=0;k<5;k++){ const ang=k/5*2*Math.PI; addCone(G, Math.cos(ang)*starR, starY, Math.sin(ang)*starR, starR*0.25, starR*0.6, 24, [1,0.95,0.6],0.0); }
    for(let a=0;a<40;a++){ const ang=a/40*2*Math.PI; const r=big*0.52; addSphere(G, Math.cos(ang)*r, big*1.05 + (Math.random()*0.4-0.2), Math.sin(ang)*r, big*0.05, 10,14, [1,0.2+Math.random()*0.8,0.2],0.0); }
    const decoR=big*0.75;
    for(let i=0;i<6;i++){
      const ang=i/6*2*Math.PI; const x=Math.cos(ang)*decoR, z=Math.sin(ang)*decoR;
      if(i%3===0){ pushBox(G,x,1.2,z, 0.9,1.2,0.6, [0.9,0.1,0.1],[0.8,0.1,0.1],0.0); addSphere(G,x,2.0,z,0.35,12,16,[1,0.92,0.85],0.0); }
      else if(i%3===1){ pushBox(G,x,0.8,z, 1.2,0.8,0.5,[0.55,0.3,0.18],[0.5,0.28,0.16],0.0); addSphere(G,x+0.6,1.2,z,0.25,12,16,[0.6,0.34,0.2],0.0); addSphere(G,x+0.82,1.2,z,0.12,10,12,[1,0.1,0.1],0.0); }
      else{ addSphere(G,x, 0.9, z, 0.9, 16,22,[1,1,1],0.0); addSphere(G,x, 2.0, z, 0.6, 16,22,[1,1,1],0.0); addSphere(G,x, 2.8, z, 0.42,14,18,[1,1,1],0.0); }
    }
  }
  else if(theme==='VOLCANO'){
    addCone(G,0,big*0.9,0, big*0.95, big*1.5, 96, [0.32,0.12,0.08],0.0);
    addCylinder(G,0,big*1.62,0, big*0.14, big*0.1, 48, [1,0.3,0.1],[1,0.35,0.12],0.0);
  }
  centerBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; centerVerts=G.pos.length/3;
}

/* ---------- 터널(트랙 스윕) ---------- */
function buildTunnels(theme,seed2){
  tunnelBuf=tunnelGlowBuf=null; tunnelVerts=tunnelGlowVerts=0;
  const G=makeGeo(), L=makeGeo();
  const step = 420; const len = 80; const segAround = 44;
  const radius = trackW*0.6;
  for(let base=140;base<samples;base+=step){
    for(let k=0;k<len-1;k++){
      const i0=base+k, i1=base+k+1;
      const c0=getCenter(i0), c1=getCenter(i1);
      const b0=basisAt(i0), b1=basisAt(i1);
      for(let s=0;s<segAround;s++){
        const a0=s/segAround*2*Math.PI, a1=(s+1)/segAround*2*Math.PI;
        const p=(c,b,a)=>[ c[0]+b.R[0]*Math.cos(a)*radius + b.B[0]*Math.sin(a)*radius,
                           c[1]+b.R[1]*Math.cos(a)*radius + b.B[1]*Math.sin(a)*radius,
                           c[2]+b.R[2]*Math.cos(a)*radius + b.B[2]*Math.sin(a)*radius ];
        const A=p(c0,b0,a0), B=p(c0,b0,a1), C=p(c1,b1,a1), D=p(c1,b1,a0);
        pushQuad(G, A[0],A[1],A[2], B[0],B[1],B[2], C[0],C[1],C[2], D[0],D[1],D[2], [0.12,0.13,0.18],0.0);
      }
    }
    for(let k=0;k<len;k+=6){
      const i=base+k; const c=getCenter(i); const b=basisAt(i);
      for(let s=0;s<segAround;s+=4){
        const a=s/segAround*2*Math.PI;
        const P=[ c[0]+b.R[0]*Math.cos(a)*(radius-0.7) + b.B[0]*Math.sin(a)*(radius-0.7),
                  c[1]+b.R[1]*Math.cos(a)*(radius-0.7) + b.B[1]*Math.sin(a)*(radius-0.7),
                  c[2]+b.R[2]*Math.cos(a)*(radius-0.7) + b.B[2]*Math.sin(a)*(radius-0.7) ];
        L.pos.push(P[0],P[1],P[2]); L.col.push(1,0.8,0.4); L.glow.push(1.0);
      }
    }
  }
  tunnelBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; tunnelVerts=G.pos.length/3;
  if(L.pos.length){ tunnelGlowBuf={pos:makeBuffer(new Float32Array(L.pos),3), col:makeBuffer(new Float32Array(L.col),3), glow:makeBuffer(new Float32Array(L.glow),1)}; tunnelGlowVerts=L.pos.length/3; }
}

/* ---------- 트랙사이드 소품 ---------- */
function buildTrackside(theme,seed2){
  tracksideBuf=null; tracksideVerts=0; const G=makeGeo(); const rng=mulberry32(seed2^0x777);
  for(let i=40;i<samples;i+=Math.floor(22+rng()*26)){
    const {R}=basisAt(i); const C=getCenter(i);
    const side = (rng()<0.5?-1:1), off = side*(trackW*0.6), P=[C[0]+R[0]*off, C[1]+R[1]*off, C[2]+R[2]*off];
    const h=2.8+rng()*6.2, s=0.7+rng()*1.4;
    pushBox(G, P[0],h*0.5,P[2], s,h,s, [0.8,0.9,1],[0.2,0.9,1], 0.9);
  }
  tracksideBuf={pos:makeBuffer(new Float32Array(G.pos),3), col:makeBuffer(new Float32Array(G.col),3), glow:makeBuffer(new Float32Array(G.glow),1)}; tracksideVerts=G.pos.length/3;
}

/* ---------- 차량 ---------- */
function makeCarGeom(themeCol){
  const hw=0.8, hh=0.28, hl=1.36, nose=0.55, color=themeCol;
  const P=[
    -hw,hh,-hl,  hw,hh,-hl,  0,hh+nose,-hl*0.2,
    -hw,hh, hl*0.2, 0,hh+nose,-hl*0.2,  hw,hh, hl*0.2,
    -hw,-hh,-hl, -hw,hh,-hl, -hw,hh,hl*0.2,
    -hw,-hh,-hl, -hw,hh,hl*0.2, -hw,-hh,hl*0.2,
     hw,-hh,-hl,  hw,hh,hl*0.2,  hw,hh,-hl,
     hw,-hh,-hl,  hw,-hh,hl*0.2,  hw,hh,hl*0.2,
    -hw,-hh,hl*0.2, hw,-hh,hl*0.2, hw,-hh,-hl,
    -hw,-hh,hl*0.2, hw,-hh,-hl, -hw,-hh,-hl
  ];
  const cols=[]; for(let i=0;i<P.length/3;i++) cols.push(themeCol[0],themeCol[1],themeCol[2]);
  const glow=new Float32Array(P.length/3).fill(0.0);
  return {pos:makeBuffer(new Float32Array(P),3),col:makeBuffer(new Float32Array(cols),3),glow:makeBuffer(glow,1),verts:P.length/3};
}
let carGeom=makeCarGeom(THEMES[cfg.theme].car);

/* ---------- 입력 ---------- */
const input1={L:false,R:false,ACC:false,BR:false,DR:false};
const input2={L:false,R:false,ACC:false,BR:false,DR:false};
function setKeys(down,e){
  const code=e.code;
  if(code==='KeyA') input1.L=down;
  if(code==='KeyD') input1.R=down;
  if(code==='KeyW') input1.ACC=down;
  if(code==='KeyS') input1.BR=down;
  if(code==='Space') input1.DR=down;
  if(code==='ArrowLeft') input2.L=down;
  if(code==='ArrowRight') input2.R=down;
  if(code==='ArrowUp') input2.ACC=down;
  if(code==='ArrowDown') input2.BR=down;
  if(code==='Slash') input2.DR=down;
}
addEventListener('keydown',e=>{ if(e.repeat) return; const block=['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','Slash','KeyA','KeyD','KeyW','KeyS']; if(block.includes(e.code)) e.preventDefault(); setKeys(true,e); });
addEventListener('keyup',e=>setKeys(false,e));
/* 모바일 버튼 */
const padL=document.getElementById('padL'), padR=document.getElementById('padR');
function bindPad(btn){ const act=btn.dataset.act; btn.addEventListener('pointerdown',e=>{e.preventDefault(); input1[act]=true;},{passive:false});
btn.addEventListener('pointerup',e=>{e.preventDefault(); input1[act]=false;},{passive:false}); }
padL.querySelectorAll('.pbtn').forEach(bindPad); padR.querySelectorAll('.pbtn').forEach(bindPad);

/* ---------- 물리/레이스 ---------- */
const MAX_KMH=360, MAX_V=MAX_KMH/3.6;
function makeCar(ctrl){
  return {
    s:0, prevS:0, v:0, off:0, offV:0, drift:0, lap:0, finished:false, name:'P', lastLapTs:0,
    camEye:null, camAt:null,
    update(dt){
      const ACC=ctrl?.ACC, BR=ctrl?.BR, L=ctrl?.L, R=ctrl?.R, DR=ctrl?.DR;
      const acc = ACC? 0.38*MAX_V : 0;
      const baseDec = 0.070*MAX_V;
      const brakeDec= BR? 0.30*MAX_V : 0;
      this.v = clamp(this.v + (acc - baseDec - brakeDec)*dt, 0, MAX_V);
      const target = (L?-1:0) + (R?1:0);
      const aim = target * (trackW*0.46);
      const spring = 6.0, damp=3.6;
      const force = (aim - this.off)*spring - this.offV*damp;
      this.offV += force*dt;
      if(DR){ this.offV*=1.03; this.v = Math.min(MAX_V, this.v + (0.12*MAX_V)*dt); this.drift += Math.abs(this.offV)*1.2; }
      this.off += this.offV*dt;
      const limit=trackW*0.48; if(this.off<-limit){this.off=-limit; this.offV=0;} if(this.off>limit){this.off=limit; this.offV=0;}
      this.prevS = this.s;
      this.s = (this.s + this.v*dt) % samples;
    },
    world(){
      const i=Math.floor(this.s)|0; const t=this.s-i;
      const p0=getCenter(i), p1=getCenter(i+1);
      const pos=[lerp(p0[0],p1[0],t), lerp(p0[1],p1[1],t), lerp(p0[2],p1[2],t)];
      const {T,R,B}=basisAt(i);
      return {pos:[pos[0]+R[0]*this.off,pos[1]+R[1]*this.off,pos[2]+R[2]*this.off], T,R,B};
    }
  };
}

/* ---------- 1인칭(FPV) 카메라 (스핀 방지) ---------- */
const FPV = { forward: 1.35, height: 1.05, lookAhead: 8.0, fovDeg: 72, eyeSmooth:14.0, atSmooth:18.0 };
function fpvCamVP(car, aspect, dt){
  const w = car.world();
  const eyeT = [ w.pos[0] + w.T[0]*FPV.forward,  w.pos[1] + FPV.height,  w.pos[2] + w.T[2]*FPV.forward ];
  const atT  = [ w.pos[0] + w.T[0]*FPV.lookAhead, w.pos[1] + 1.2,        w.pos[2] + w.T[2]*FPV.lookAhead ];

  const kEye = 1 - Math.exp(-dt*FPV.eyeSmooth);
  const kAt  = 1 - Math.exp(-dt*FPV.atSmooth);
  car.camEye = car.camEye ? mixV(car.camEye, eyeT, kEye) : eyeT;
  car.camAt  = car.camAt  ? mixV(car.camAt,  atT,  kAt)  : atT;

  const V = M.look(car.camEye, car.camAt, [0,1,0], true); // 월드업 고정 → 롤 제거
  const fov = FPV.fovDeg*Math.PI/180, f=1/Math.tan(fov/2), near=0.1, far=4000, nf=1/(near-far);
  const P=[ f/(aspect||1),0,0,0,  0,f,0,0,  0,0,(far+near)*nf,-1,  0,0,(2*far*near)*nf,0 ];
  return M.mul(P,V);
}

/* ---------- 드로우 ---------- */
function drawCar(VP,car){
  const w=car.world();
  const model = M.F(w.R, w.B, w.T, [w.pos[0], w.pos[1]+0.60, w.pos[2]]);
  const VPc = M.mul(VP, model);
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VPc));
  drawSolid(carGeom, carGeom.verts, gl.TRIANGLES);
}
function renderScene(VP, tSec){
  gl.uniformMatrix4fv(loc.uVP,false,new Float32Array(VP)); gl.uniform1f(loc.uTime, tSec);
  gl.enable(gl.POLYGON_OFFSET_FILL); gl.polygonOffset(1,1);
  drawSolid(bufRibbon, verts, gl.TRIANGLE_STRIP);
  gl.disable(gl.POLYGON_OFFSET_FILL);

  drawSolid(tunnelBuf, tunnelVerts, gl.TRIANGLES);
  drawSolid(geoBuf, geoVerts, gl.TRIANGLES);
  drawSolid(centerBuf, centerVerts, gl.TRIANGLES);
  drawGlow(tracksideBuf, tracksideVerts, gl.TRIANGLES);
  drawGlow(tunnelGlowBuf, tunnelGlowVerts, gl.POINTS);
  drawGlow(envBuf, envVerts, gl.POINTS);
  drawGlow(propBuf, propVerts, gl.POINTS);
  drawGlow(bufRail, railVerts, gl.POINTS);
  if(snowBuf) drawGlow(snowBuf, snowVerts, gl.POINTS);
  if(ashBuf)  drawGlow(ashBuf,  ashVerts,  gl.POINTS);
}
function renderOnce(){
  const tSec=performance.now()/1000; gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const dt=1/60;
  if(!cfg.twoP){
    const VP=fpvCamVP(car1, CW/CH, dt);
    renderScene(VP,tSec);
    for(const ai of aiCars) drawCar(VP,ai); // 1인칭이라 플레이어 자동차는 그리지 않음
  }else{
    const half=CW>>1;
    gl.viewport(0,0,half,CH); const VP1=fpvCamVP(car1, (half)/CH, dt); renderScene(VP1,tSec); for(const ai of aiCars) drawCar(VP1,ai);
    gl.viewport(half,0,CW-half,CH); const VP2=fpvCamVP(car2, (CW-half)/CH, dt); renderScene(VP2,tSec); for(const ai of aiCars) drawCar(VP2,ai);
    gl.viewport(0,0,CW,CH);
  }
}

/* ---------- 레이스 ---------- */
let car1=makeCar(input1), car2=makeCar(input2), aiCars=[];
const LAPS=3, START_OFFSET_FRAC=0.25;
function placeAtStart(c, lane=0){
  c.s = (samples*START_OFFSET_FRAC)|0;
  c.prevS = c.s; c.off = lane; c.offV=0; c.v=0; c.lap=0; c.finished=false; c.lastLapTs=0;

  // 시작 시 정면 고정 (FPV)
  const w = c.world();
  c.camEye=[ w.pos[0] + w.T[0]*FPV.forward, w.pos[1] + FPV.height, w.pos[2] + w.T[2]*FPV.forward ];
  c.camAt =[ w.pos[0] + w.T[0]*FPV.lookAhead, w.pos[1] + 1.2,      w.pos[2] + w.T[2]*FPV.lookAhead ];
}
function resetCars(){
  car1=makeCar(input1); car1.name='P1'; placeAtStart(car1, 0);
  car2=makeCar(input2); car2.name='P2'; if(cfg.twoP) placeAtStart(car2, trackW*0.15);
  aiCars=[]; for(let i=0;i<cfg.aiCount;i++){ const ai=makeCar(null); ai.name='AI'+(i+1); placeAtStart(ai, ((i%4)-1.5)*trackW*0.22); ai.v=0.6*MAX_V; aiCars.push(ai); }
}
function updateAI(dt){ for(const ai of aiCars){ const targetV=0.78*MAX_V; ai.v=clamp(ai.v + (targetV - 0.06*MAX_V)*dt, 0, MAX_V*0.92); ai.s = (ai.s + ai.v*dt) % samples; } }
function positions(){ const all=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars]; const arr=all.map(c=>({c,progress:c.lap*samples + c.s})).sort((a,b)=>b.progress-a.progress); return arr.map(x=>x.c); }
function checkLaps(){ const now=performance.now(); const racers=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars]; for(const c of racers){ const wrapped=(c.prevS>samples*0.75)&&(c.s<samples*0.25); if(wrapped && now-c.lastLapTs>2000 && c.v>6){ c.lap++; c.lastLapTs=now; if(c===car1) setHUD('uiLap', `${Math.min(c.lap,LAPS)}/${LAPS}`); if(c.lap>=LAPS) c.finished=true; } } }

/* ---------- 루프 ---------- */
const S={MENU:0,PLAY:1,PAUSE:2,RESULT:3}; let state=S.MENU; let last=performance.now();
function frame(){
  const now=performance.now(), dt=Math.min((now-last)/1000, 0.06); last=now; const tSec=now/1000;
  if(state===S.PLAY){
    car1.update(dt); if(cfg.twoP) car2.update(dt);
    updateAI(dt); checkLaps();

    // HUD
    const spd = Math.min(MAX_KMH, Math.round(car1.v*3.6));
    setHUD('uiSpeed', spd+'');
    const ps=positions(), posIdx=ps.findIndex(p=>p===car1)+1;
    setHUD('uiPos', (cfg.aiCount + (cfg.twoP?1:0) + 1)>1 ? `${posIdx}/${ps.length}` : 'Solo');

    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    if(!cfg.twoP){
      const VP=fpvCamVP(car1, CW/CH, dt); renderScene(VP,tSec); for(const ai of aiCars) drawCar(VP,ai);
    }else{
      const half=CW>>1;
      gl.viewport(0,0,half,CH); const VP1=fpvCamVP(car1,(half)/CH,dt); renderScene(VP1,tSec); for(const ai of aiCars) drawCar(VP1,ai);
      gl.viewport(half,0,CW-half,CH); const VP2=fpvCamVP(car2,(CW-half)/CH,dt); renderScene(VP2,tSec); for(const ai of aiCars) drawCar(VP2,ai);
      gl.viewport(0,0,CW,CH);
    }

    const all=[car1, ...(cfg.twoP?[car2]:[]), ...aiCars];
    if(all.every(c=>c.finished || c.lap>=LAPS)){
      state=S.RESULT;
      const order=positions();
      const rows=order.map((c,i)=>`<tr><td>${i+1}</td><td>${c.name}</td><td>${(c.lap>=LAPS)?'FINISH':'DNF'}</td></tr>`).join('');
      panel(`<h1>🏁 결과</h1><table style="width:100%;text-align:center;border-collapse:collapse"><thead><tr><th>순위</th><th>이름</th><th>상태</th></tr></thead><tbody>${rows}</tbody></table><div style="margin-top:10px"><button class="btn" id="btnAgain">다시</button></div>`);
      document.getElementById('btnAgain').onclick=()=>{clearPanel(); reset();};
    }
    requestAnimationFrame(frame);
  }
}

/* ---------- UI ---------- */
const setHUD=(id,val)=>{const el=document.querySelector('#'+id+' .val'); if(el) el.textContent=val};
function applyTheme(key){
  document.body.style.background=THEMES[key].bg();
  carGeom=makeCarGeom(THEMES[key].car);
  buildTrack(key);
  renderOnce();
}
function reset(){
  buildTrack(cfg.theme); resetCars();
  setHUD('uiLap',`0/${LAPS}`); setHUD('uiSpeed','0');
  setHUD('uiPos', cfg.aiCount>0?`1/${1+cfg.aiCount+(cfg.twoP?1:0)}`:'Solo');
  renderOnce(); showMenu();
}

document.getElementById('btnPlay').onclick=()=>{ if(state!==S.PLAY){ clearPanel(); state=S.PLAY; last=performance.now(); frame(); }};
document.getElementById('btnPause').onclick=()=>{ if(state===S.PLAY){ state=S.PAUSE; panel(`<h1>⏸ 일시정지</h1><div><button class="btn" id="btnResume">▶ 계속</button><button class="btn" id="btnMenu">메뉴</button></div>`); document.getElementById('btnResume').onclick=()=>{clearPanel(); state=S.PLAY; last=performance.now(); frame();}; document.getElementById('btnMenu').onclick=()=>{state=S.MENU; showMenu();}; } };
document.getElementById('btnReset').onclick=reset;
document.getElementById('btnReroll').onclick=()=>{ cfg.seed=(Math.random()*1e9)|0; store.set(cfg); reset(); };
document.getElementById('btnShape').onclick=()=>{ const idx=(SHAPES.indexOf(cfg.shape)+1)%SHAPES.length; cfg.shape=SHAPES[idx]; store.set(cfg); document.getElementById('btnShape').textContent='🛣 '+cfg.shape; reset(); };
document.getElementById('btnAI').onclick=()=>{ cfg.aiCount=(cfg.aiCount+1)%6; store.set(cfg); document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount; reset(); };
document.getElementById('btn2P').onclick=()=>{ cfg.twoP=!cfg.twoP; store.set(cfg); document.getElementById('btn2P').textContent= cfg.twoP?'👥 2P':'👥 1P'; reset(); };
document.getElementById('btnMobile').onclick=()=>{ cfg.mobile=!cfg.mobile; store.set(cfg); document.getElementById('btnMobile').textContent= cfg.mobile?'📱 Mobile: ON':'📱 Mobile: OFF'; padL.style.display=padR.style.display=cfg.mobile?'flex':'none'; };
document.getElementById('selTheme').value=cfg.theme;
document.getElementById('selTheme').onchange=(e)=>{ cfg.theme=e.target.value; store.set(cfg); applyTheme(cfg.theme); resetCars(); };

/* ---------- 도움말/메뉴 ---------- */
function showMenu(){
  const help=`<div class="keys">
  <b>1P</b>: W 가속 / S 브레이크 / A◀ D▶ / Space 드리프트<br/>
  <b>2P</b>: ↑ 가속 / ↓ 브레이크 / ←◀ →▶ / / 드리프트<br/>
  모바일: 좌측 ◀▶ / 우측 DRIFT, 가속, 브레이크
  </div>`;
  panel(`<h1>🏎 시작할 준비!</h1>${help}<div style="margin-top:10px"><button class="btn" id="start">▶ 시작</button></div>`);
  document.getElementById('start').onclick=()=>{ clearPanel(); state=S.PLAY; last=performance.now(); frame(); };
}

/* ---------- 시작 ---------- */
function bootstrap(){
  applyTheme(cfg.theme); resetCars();
  setHUD('uiLap',`0/${LAPS}`);
  setHUD('uiPos', cfg.aiCount>0?`1/${1+cfg.aiCount+(cfg.twoP?1:0)}`:'Solo');
  document.getElementById('btnShape').textContent='🛣 '+cfg.shape;
  document.getElementById('btnAI').textContent='🤖 AI: '+cfg.aiCount;
  document.getElementById('btn2P').textContent= cfg.twoP?'👥 2P':'👥 1P';
  document.getElementById('btnMobile').textContent= cfg.mobile?'📱 Mobile: ON':'📱 Mobile: OFF';
  padL.style.display=padR.style.display=cfg.mobile?'flex':'none';
  showMenu(); renderOnce();
}
bootstrap();

})();</script>
</body>
</html>
