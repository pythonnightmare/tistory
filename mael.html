<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DTC‑SVM + EKF 보상 3D 시뮬레이터 (GitHub Pages)</title>
  <style>
    :root{
      --panel-bg: rgba(16,18,27,.75);
      --panel-br: rgba(255,255,255,.12);
      --fg: #e7eef7;
      --muted: #98a2b3;
      --accent: #60a5fa;
      --ok: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --chart-bg: #0b1322;
      --grid: rgba(255,255,255,.08);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 15% 10%,#0b1220,#0a0f1a 60%,#070b12 100%);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,Segoe UI Emoji,Segoe UI Symbol,"Noto Sans KR",sans-serif}
    #scene{position:fixed;inset:0}
    .panel{position:fixed;top:12px;left:12px;width:min(420px, 45vw); backdrop-filter: blur(10px); background:var(--panel-bg); border:1px solid var(--panel-br); border-radius:16px; padding:14px 14px 10px}
    .row{display:grid;grid-template-columns:160px 1fr;gap:8px;align-items:center;margin:8px 0}
    .row label{font-size:12px;color:var(--muted)}
    .row input[type=range]{width:100%}
    .row input[type=number], .row select{width:100%;background:#0f172a;border:1px solid var(--panel-br);color:var(--fg);border-radius:10px;padding:6px 8px}
    .row .val{font-variant-numeric:tabular-nums;justify-self:end;color:#cbd5e1}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid var(--panel-br);color:#cbd5e1;margin-right:6px}
    .title{display:flex;align-items:center;gap:8px;margin-bottom:8px}
    .title h1{font-size:15px;margin:0;font-weight:700}
    .grid{position:fixed;right:12px;top:12px;display:grid;gap:8px;max-width:min(480px,48vw)}
    .card{background:var(--panel-bg);border:1px solid var(--panel-br);border-radius:16px;padding:12px}
    .kpis{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .kpi{background:#0b1322;border:1px solid var(--panel-br);border-radius:12px;padding:10px}
    .kpi h3{margin:0 0 6px 0;font-size:12px;color:var(--muted)}
    .kpi .v{font-size:16px;font-variant-numeric:tabular-nums}
    button{cursor:pointer;border-radius:12px;border:1px solid var(--panel-br);background:#0f172a;color:var(--fg);padding:8px 10px}
    button:hover{background:#111c30}
    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .dot{width:10px;height:10px;border-radius:50%}
    .legend .item{display:flex;align-items:center;gap:6px;font-size:12px;color:#cbd5e1}
    .footer{font-size:11px;color:#9aa6b2;margin-top:8px}
    a{color:var(--accent);text-decoration:none}
    .tests{margin-top:8px}
    .test-pass{color:var(--ok)}
    .test-fail{color:var(--bad)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px}
    .charts{display:grid;gap:8px}
    .chart{background:var(--chart-bg);border:1px solid var(--panel-br);border-radius:12px;padding:6px}
    .chart h4{margin:2px 6px 6px 6px;font-size:12px;color:var(--muted)}
    canvas.plot{width:100%;height:120px;display:block;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.0));}
    .row.preset{grid-template-columns:1fr 1fr 1fr}
  </style>

  <!-- Import Map + Shim to resolve bare module specifiers like "three" in browsers -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="panel">
    <div class="title">
      <span class="badge">EV PMSM</span>
      <h1>DTC‑SVM + EKF 보상 3D 시뮬레이터</h1>
    </div>

    <div class="row preset">
      <button id="presetCreep">🚗 크리프(저속)</button>
      <button id="presetCruise">🛣 정속</button>
      <button id="presetFW">⚡ 필드위크닝</button>
    </div>

    <div class="row"><label>모드</label>
      <select id="mode">
        <option value="realtime">실시간 시뮬레이션</option>
        <option value="map">3D 리플 맵</option>
      </select>
    </div>

    <div class="row"><label>보상(Compensation)</label>
      <select id="compMode">
        <option value="off">OFF</option>
        <option value="ekf">EKF</option>
      </select>
    </div>

    <div class="row"><label>메인 제어(백본)</label>
      <select id="backbone">
        <option value="foc">FOC(+SVM) 등가</option>
        <option value="dtc">DTC-SVM 등가</option>
      </select>
    </div>

    <div class="row"><label>극쌍수 p</label>
      <input id="pp" type="number" min="1" step="1" value="4" />
    </div>

    <div class="row"><label>전기 각속도 ω<sub>e</sub> [rad/s]</label>
      <input id="omega" type="range" min="1" max="1200" value="300" />
      <div class="val" id="omegaVal">300</div>
    </div>

    <div class="row"><label>DC 링크 V<sub>dc</sub> [V]</label>
      <input id="vdc" type="range" min="100" max="800" value="350" />
      <div class="val" id="vdcVal">350</div>
    </div>

    <div class="row"><label>데드타임 t<sub>d</sub> [ns]</label>
      <input id="tdead" type="range" min="50" max="3000" value="800" />
      <div class="val" id="tdeadVal">800</div>
    </div>

    <div class="row"><label>소자 유형</label>
      <select id="device">
        <option value="igbt">IGBT (V<sub>f</sub>≈1.7V)</option>
        <option value="sic">SiC MOSFET (V<sub>f</sub>≈1.2V)</option>
      </select>
    </div>

    <div class="row"><label>샘플링 T<sub>s</sub> [µs]</label>
      <input id="ts" type="range" min="25" max="200" value="100" />
      <div class="val" id="tsVal">100</div>
    </div>

    <div class="row"><label>R<sub>s</sub> [Ω]</label>
      <input id="rs" type="range" min="0.02" max="0.3" step="0.01" value="0.08" />
      <div class="val" id="rsVal">0.08</div>
    </div>

    <div class="row"><label>L<sub>d</sub>=L<sub>q</sub> [mH]</label>
      <input id="ld" type="range" min="0.1" max="3.0" step="0.1" value="1.2" />
      <div class="val" id="ldVal">1.2</div>
    </div>

    <div class="row"><label>영구자석 쇄교 Ψ<sub>f</sub> [Wb]</label>
      <input id="psif" type="range" min="0.02" max="0.25" step="0.01" value="0.08" />
      <div class="val" id="psifVal">0.08</div>
    </div>

    <div class="row"><label>i<sub>d</sub>* [A]</label>
      <input id="idref" type="range" min="-50" max="50" step="1" value="0" />
      <div class="val" id="idrefVal">0</div>
    </div>

    <div class="row"><label>i<sub>q</sub>* [A]</label>
      <input id="iqref" type="range" min="-200" max="200" step="1" value="60" />
      <div class="val" id="iqrefVal">60</div>
    </div>

    <div class="row"><label>EKF Q<sub>dist</sub> (×1e-2)</label>
      <input id="qscale" type="range" min="1" max="100" step="1" value="20" />
      <div class="val" id="qscaleVal">0.20</div>
    </div>

    <div class="row"><label>EKF R<sub>meas</sub> (A²)</label>
      <input id="rmeas" type="range" min="0.0001" max="0.01" step="0.0001" value="0.001" />
      <div class="val" id="rmeasVal">0.0010</div>
    </div>

    <div class="row"><label>맵 해상도 (N×N)</label>
      <input id="mapN" type="range" min="8" max="28" step="2" value="16" />
      <div class="val" id="mapNVal">16×16</div>
    </div>

    <div class="row" style="grid-template-columns:1fr 1fr;gap:8px">
      <button id="toggle">⏸︎ 일시정지</button>
      <button id="reset">↺ 리셋</button>
    </div>
    <div class="row" style="grid-template-columns:1fr;gap:8px">
      <button id="genMap">🗺 3D 리플 맵 생성</button>
    </div>

    <div class="legend" style="margin-top:6px">
      <div class="item"><span class="dot" style="background:#60a5fa"></span>v<sub>cmd</sub></div>
      <div class="item"><span class="dot" style="background:#ef4444"></span>v<sub>dist,true</sub></div>
      <div class="item"><span class="dot" style="background:#22c55e"></span>v<sub>comp (EKF)</sub></div>
      <div class="item"><span class="dot" style="background:#f59e0b"></span>ψ (플럭스 궤적)</div>
    </div>

    <div class="footer">※ 교육용 단순화 모델입니다. 실제 구동기 적용 전 HIL/차대 검증이 필수입니다.</div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="kpis">
        <div class="kpi"><h3>토크 평균 [Nm]</h3><div class="v" id="torqueAvg">0.00</div></div>
        <div class="kpi"><h3>토크 리플 RMS [%]</h3><div class="v" id="torqueRipple">0.00</div></div>
        <div class="kpi"><h3>i<sub>q</sub> 리플 RMS [A]</h3><div class="v" id="iqRipple">0.00</div></div>
        <div class="kpi"><h3>전류 THD* [%]</h3><div class="v" id="thd">—</div></div>
      </div>
    </div>
    <div class="card">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px"><span class="badge">CHARTS</span><strong>실시간 그래프</strong></div>
      <div class="charts">
        <div class="chart"><h4>토크 시간파형</h4><canvas id="torquePlot" class="plot" width="440" height="140"></canvas></div>
        <div class="chart"><h4>전류 i<sub>q</sub> 시간파형</h4><canvas id="iqPlot" class="plot" width="440" height="140"></canvas></div>
        <div class="chart"><h4>상전류 i<sub>a</sub> 시간파형</h4><canvas id="iaPlot" class="plot" width="440" height="140"></canvas></div>
        <div class="chart"><h4>스펙트럼 (i<sub>a</sub>, 1~10차)</h4><canvas id="specPlot" class="plot" width="440" height="160"></canvas></div>
      </div>
    </div>
    <div class="card">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px"><span class="badge">TESTS</span><strong>진단 / 유닛 테스트</strong></div>
      <button id="runTests">🧪 테스트 실행</button>
      <div id="testOut" class="tests mono"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---------- 3D SCENE ----------
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0f1a, 40, 160);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0, 16, 28);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0,0,0);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(10,20,10);
    scene.add(light, new THREE.AmbientLight(0xffffff, .35));

    const grid = new THREE.GridHelper(40, 40, 0x19324d, 0x0f2136);
    grid.material.opacity = 0.7; grid.material.transparent = true;
    scene.add(grid);

    const axes = new THREE.AxesHelper(8); axes.position.y = .01; scene.add(axes);

    // αβ-평면 시각 가이드(육각 SVM)
    const hex = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.CircleGeometry(8,6)),
      new THREE.LineBasicMaterial({color:0x22405f, transparent:true, opacity:.7})
    );
    hex.rotation.x = -Math.PI/2; hex.position.y = 0.01; scene.add(hex);

    function makeArrow(color=0x60a5fa){
      const g1 = new THREE.CylinderGeometry(.06,.06,3.0,12);
      const g2 = new THREE.ConeGeometry(.14,.5,16);
      const m = new THREE.MeshStandardMaterial({color, metalness:.2, roughness:.4});
      const shaft = new THREE.Mesh(g1, m); const head = new THREE.Mesh(g2, m);
      head.position.y = 1.75; shaft.position.y = .25;
      const group = new THREE.Group(); group.add(shaft, head); return group;
    }

    const arrowCmd = makeArrow(0x60a5fa); // v_cmd
    const arrowDist = makeArrow(0xef4444); // v_dist,true
    const arrowComp = makeArrow(0x22c55e); // v_comp
    scene.add(arrowCmd, arrowDist, arrowComp);

    // Flux trail
    const trailN = 600; const trailGeom = new THREE.BufferGeometry();
    const trailPos = new Float32Array(trailN*3);
    trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
    const trailMat = new THREE.LineBasicMaterial({color:0xf59e0b, transparent:true, opacity:.9});
    const trail = new THREE.Line(trailGeom, trailMat); scene.add(trail);

    // Map surfaces (created on demand)
    let mapGroup = new THREE.Group(); scene.add(mapGroup);

    // ---------- UTIL ----------
    const sqrt3 = Math.sqrt(3);
    function clamp(x,a,b){return Math.min(b, Math.max(a,x));}
    function sign(x){return x>=0?1:-1}

    function dq_to_albe(id, iq, theta){
      const c=Math.cos(theta), s=Math.sin(theta);
      const ial = c*id - s*iq; const ibe = s*id + c*iq; return [ial, ibe];
    }
    function albe_to_dq(ial, ibe, theta){
      const c=Math.cos(theta), s=Math.sin(theta);
      const id = c*ial + s*ibe; const iq = -s*ial + c*ibe; return [id, iq];
    }
    function albe_to_abc(ial, ibe){
      const ia=ial; const ib=-0.5*ial + (sqrt3/2)*ibe; const ic=-0.5*ial - (sqrt3/2)*ibe; return [ia,ib,ic];
    }
    function abc_to_albe(ia,ib,ic){
      const ial = (2/3)*(ia - 0.5*ib - 0.5*ic);
      const ibe = (2/3)*((sqrt3/2)*(ib - ic));
      return [ial, ibe];
    }

    // ---------- SIM MODEL ----------
    const params = {
      p: 4, // pole pairs
      omega_e: 300,
      Vdc: 350,
      tdead_ns: 800,
      Ts: 100e-6, // 100us
      Rs: 0.08,
      Ld: 1.2e-3,
      Lq: 1.2e-3,
      psi_f: 0.08,
      id_ref: 0,
      iq_ref: 60,
      device: 'igbt',
      backbone: 'foc',
      compMode: 'off',
      qScale: 0.20, // Qdist scaling
      rMeas: 0.001, // A^2
    };

    const state = {
      theta: 0,
      id: 0, iq: 0,
      // EKF state
      x: new Float64Array([0,0,0,0]), // [id, iq, vddist, vqdist]
      P: (function(){const I=new Float64Array(16); for(let i=0;i<4;i++) I[i*4+i]=0.1; return I;})(),
    };

    // PI controllers (simple, for demo)
    const ctrl = {
      id_i:0, iq_i:0,
      Kp: 2.5, Ki: 800, // coarse defaults
    };

    const meters = { torque:[], iq:[], ia:[] };
    const meterMax = 4096; // for nicer FFT window

    function deviceVf(){ return params.device==='igbt'? 1.7 : 1.2; }

    function computeDisturbanceABC(ia,ib,ic){
      // Very simplified: average phase voltage error due to deadtime + diode drop
      // Δv_phase ≈ sign(i_phase) * (Vdc * tdead/Ts) + sign(i_phase) * V_diode*k
      const kdt = 1.0;
      const kd = 1.0;
      const dv = params.Vdc * (params.tdead_ns*1e-9) / params.Ts * kdt; // in volts
      const Vf = deviceVf();
      const da = sign(ia)*dv + sign(ia)*Vf*kd;
      const db = sign(ib)*dv + sign(ib)*Vf*kd;
      const dc = sign(ic)*dv + sign(ic)*Vf*kd;
      return [da,db,dc];
    }

    function voltageLimit(vd, vq){
      // SVM linear modulation limit (no overmod): Vmax ≈ Vdc/√3
      const vmax = params.Vdc / sqrt3;
      const mag = Math.hypot(vd, vq);
      if(mag>vmax){ const s=vmax/mag; return [vd*s, vq*s]; }
      return [vd,vq];
    }

    function gauss(){
      // Box-Muller
      let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    function stepPlant(){
      const {Ld,Lq,Rs,psi_f,Ts,omega_e} = params;
      // reference currents
      const id_star = params.id_ref;
      const iq_star = params.iq_ref;

      // simple PI current control (FOC backbone)
      const err_d = id_star - state.id;
      const err_q = iq_star - state.iq;
      ctrl.id_i += ctrl.Ki * err_d * Ts;
      ctrl.iq_i += ctrl.Ki * err_q * Ts;
      let vd_cmd = ctrl.Kp*err_d + ctrl.id_i + Rs*state.id - omega_e*Lq*state.iq;
      let vq_cmd = ctrl.Kp*err_q + ctrl.iq_i + Rs*state.iq + omega_e*(Ld*state.id + psi_f);

      // EKF-based compensation (add estimated disturbance)
      let vcomp_d = 0, vcomp_q = 0;
      if(params.compMode==='ekf'){
        vcomp_d = state.x[2];
        vcomp_q = state.x[3];
      }

      // limit
      [vd_cmd, vq_cmd] = voltageLimit(vd_cmd + vcomp_d, vq_cmd + vcomp_q);

      // true disturbance from abc current signs
      const [ial, ibe] = dq_to_albe(state.id, state.iq, state.theta);
      const [ia,ib,ic] = albe_to_abc(ial, ibe);
      const [dva,dvb,dvc] = computeDisturbanceABC(ia,ib,ic);
      const [dv_al, dv_be] = abc_to_albe(dva,dvb,dvc);
      const [dv_d, dv_q] = albe_to_dq(dv_al, dv_be, state.theta);

      // plant dynamics (Euler)
      const did = (vd_cmd - Rs*state.id + omega_e*Lq*state.iq - dv_d) / Ld;
      const diq = (vq_cmd - Rs*state.iq - omega_e*(Ld*state.id + psi_f) - dv_q) / Lq;
      state.id += did * Ts;
      state.iq += diq * Ts;

      // update angle
      state.theta += omega_e * Ts; if(state.theta>Math.PI*2) state.theta-=Math.PI*2;

      // noisy measurement for EKF
      const measId = state.id + gauss()*Math.sqrt(params.rMeas);
      const measIq = state.iq + gauss()*Math.sqrt(params.rMeas);

      // EKF update with measurement z=[id, iq]
      ekfUpdate(vd_cmd, vq_cmd, omega_e, [measId, measIq]);

      // compute outputs
      const torque = 1.5 * params.p * (params.psi_f*state.iq + (params.Ld-params.Lq)*state.id*state.iq);

      // metrics buffers
      meters.torque.push(torque); if(meters.torque.length>meterMax) meters.torque.shift();
      meters.iq.push(state.iq); if(meters.iq.length>meterMax) meters.iq.shift();
      meters.ia.push(ia); if(meters.ia.length>meterMax) meters.ia.shift();

      // arrows (scale for view)
      const s=1/50;
      arrowCmd.position.set(0,0,0); arrowDist.position.set(0,0,0); arrowComp.position.set(0,0,0);
      arrowCmd.rotation.z = Math.atan2(vq_cmd, vd_cmd); arrowCmd.scale.set(1,1,Math.hypot(vd_cmd,vq_cmd)*s);
      arrowDist.rotation.z = Math.atan2(dv_q, dv_d); arrowDist.scale.set(1,1,Math.hypot(dv_d,dv_q)*s);
      arrowComp.rotation.z = Math.atan2(vcomp_q, vcomp_d); arrowComp.scale.set(1,1,Math.hypot(vcomp_d,vcomp_q)*s);

      // flux trail point
      const psi_d = params.Ld*state.id + params.psi_f;
      const psi_q = params.Lq*state.iq;
      const [psial, psibe] = dq_to_albe(psi_d, psi_q, state.theta);
      // push into circular buffer
      for(let i=0;i<trailN-1;i++){
        trailPos[i*3+0] = trailPos[(i+1)*3+0];
        trailPos[i*3+1] = trailPos[(i+1)*3+1];
        trailPos[i*3+2] = trailPos[(i+1)*3+2];
      }
      trailPos[(trailN-1)*3+0] = psial*.15;
      trailPos[(trailN-1)*3+1] = 0.02;
      trailPos[(trailN-1)*3+2] = psibe*.15;
      trailGeom.attributes.position.needsUpdate = true;

      // update KPIs & charts occasionally
      updateKPIs();
      if(frameCount%6===0) drawCharts();
    }

    // ---------- EKF ----------
    function ekfUpdate(vd_cmd, vq_cmd, omega_e, z){
      const {Ld,Lq,Rs,Ts} = params;
      // state x=[id, iq, vdd, vdq], P 4x4
      const x = state.x; const P = state.P;
      const id=x[0], iq=x[1], vdd=x[2], vdq=x[3];

      // f(x)
      const f1 = (vd_cmd - Rs*id + omega_e*Lq*iq - vdd)/Ld;
      const f2 = (vq_cmd - Rs*iq - omega_e*(Ld*id + params.psi_f) - vdq)/Lq;

      // Jacobian (continuous) F_c
      const a11 = -Rs/Ld;
      const a12 = omega_e*Lq/Ld;
      const a13 = -1/Ld;
      const a14 = 0;
      const a21 = -omega_e*Ld/Lq;
      const a22 = -Rs/Lq;
      const a23 = 0;
      const a24 = -1/Lq;

      // Discretize: F = I + Ts*F_c
      const F = [
        1+Ts*a11, Ts*a12, Ts*a13, Ts*a14,
        Ts*a21, 1+Ts*a22, Ts*a23, Ts*a24,
        0,0,1,0,
        0,0,0,1
      ];

      // Predict
      const xpred = new Float64Array(4);
      xpred[0] = id + Ts*f1;
      xpred[1] = iq + Ts*f2;
      xpred[2] = vdd;
      xpred[3] = vdq;

      // Ppred = F P F^T + Q
      const Ppred = mat4add(mat4mul(mat4mul(F, P), transpose4(F)), Qd());

      // Update
      const H = [1,0,0,0, 0,1,0,0];
      const HP = [
        Ppred[0], Ppred[1], Ppred[2], Ppred[3],
        Ppred[4], Ppred[5], Ppred[6], Ppred[7]
      ];
      const HPHt = [
        HP[0], HP[4],
        HP[1], HP[5]
      ]; // 2x2
      // add R
      const R11 = params.rMeas; const R22 = params.rMeas;
      const S11 = HPHt[0]+R11; const S12 = HPHt[2]; const S21 = HPHt[1]; const S22 = HPHt[3]+R22;
      const detS = S11*S22 - S12*S21; const invS = [ S22/detS, -S12/detS, -S21/detS, S11/detS ];

      // K = Ppred H^T S^-1  (4x2)
      const PHt = [
        Ppred[0], Ppred[4],
        Ppred[1], Ppred[5],
        Ppred[2], Ppred[6],
        Ppred[3], Ppred[7]
      ];
      const K = [
        PHt[0]*invS[0] + PHt[1]*invS[2], PHt[0]*invS[1] + PHt[1]*invS[3],
        PHt[2]*invS[0] + PHt[3]*invS[2], PHt[2]*invS[1] + PHt[3]*invS[3],
        PHt[4]*invS[0] + PHt[5]*invS[2], PHt[4]*invS[1] + PHt[5]*invS[3],
        PHt[6]*invS[0] + PHt[7]*invS[2], PHt[6]*invS[1] + PHt[7]*invS[3],
      ];

      // y = z - H xpred
      const y1 = z[0] - xpred[0];
      const y2 = z[1] - xpred[1];

      // x = xpred + K y
      x[0] = xpred[0] + K[0]*y1 + K[1]*y2;
      x[1] = xpred[1] + K[2]*y1 + K[3]*y2;
      x[2] = xpred[2] + K[4]*y1 + K[5]*y2;
      x[3] = xpred[3] + K[6]*y1 + K[7]*y2;

      // P = (I - K H) Ppred
      const KH = [
        K[0], K[1], 0, 0,
        K[2], K[3], 0, 0,
        K[4], K[5], 0, 0,
        K[6], K[7], 0, 0,
      ];
      const I4 = identity4();
      const IminusKH = mat4sub(I4, KH);
      const Pnew = mat4mul(IminusKH, Ppred);
      for(let i=0;i<16;i++) P[i]=Pnew[i];
    }

    function identity4(){ const I=new Float64Array(16); for(let i=0;i<4;i++) I[i*4+i]=1; return I; }
    function transpose4(M){
      return [ M[0],M[4],M[8], M[12], M[1],M[5],M[9],M[13], M[2],M[6],M[10],M[14], M[3],M[7],M[11],M[15] ];
    }
    function mat4mul(A,B){
      const C=new Float64Array(16);
      for(let r=0;r<4;r++) for(let c=0;c<4;c++){
        C[r*4+c]=A[r*4+0]*B[0*4+c]+A[r*4+1]*B[1*4+c]+A[r*4+2]*B[2*4+c]+A[r*4+3]*B[3*4+c];
      }
      return C;
    }
    function mat4add(A,B){ const C=new Float64Array(16); for(let i=0;i<16;i++) C[i]=A[i]+B[i]; return C; }
    function mat4sub(A,B){ const C=new Float64Array(16); for(let i=0;i<16;i++) C[i]=A[i]-B[i]; return C; }
    function Qd(){
      // process noise for [id,iq,vdd,vdq]; give more weight to vdist random walk
      const qd = new Float64Array(16);
      const q = 1e-6; const qdist = params.qScale*1e-2; // slider in 1e-2 units
      qd[0]=q; qd[5]=q; qd[10]=qdist; qd[15]=qdist; return qd;
    }

    // ---------- KPIs & CHARTS ----------
    function rms(arr){
      let m=0; for(const x of arr) m+=x; m/=arr.length||1;
      let s=0; for(const x of arr) s+=(x-m)*(x-m); s/=arr.length||1; return {m, rms: Math.sqrt(s)};
    }

    function computeTHDandSpectrum(sig, fs, f1, H=10){
      const N = sig.length;
      if(N<64 || f1<=0) return {thd:0, mags:[], freqs:[]};
      const mags=[]; const freqs=[];
      let A1rms = 0; let totalRMS = rms(sig).rms;
      for(let h=1; h<=H; h++){
        const fh = h*f1; if(fh>fs/2) { mags.push(0); freqs.push(fh); continue; }
        const k = Math.round(fh*N/fs); const mag = goertzelMag(sig, k, N);
        const Apeak = (2*mag)/N; // DFT peak
        const Arms = Apeak/Math.SQRT2; mags.push(Arms); freqs.push(fh); if(h===1) A1rms = Arms;
      }
      const noiseHarm = Math.max(0, Math.hypot(...mags.slice(1)));
      const thd = A1rms>1e-9 ? (noiseHarm / A1rms)*100 : 0;
      return {thd, mags, freqs};
    }

    function goertzelMag(sig, k, N){
      const w = 2*Math.PI*k/N; const cw = Math.cos(w); const sw = Math.sin(w);
      let s0=0,s1=0,s2=0; const coeff = 2*cw;
      for(let n=0;n<N;n++){ s0 = sig[n] + coeff*s1 - s2; s2=s1; s1=s0; }
      const real = s1 - s2*cw; const imag = s2*sw; return Math.hypot(real, imag);
    }

    function updateKPIs(){
      const {m:Tm, rms:Tr} = rms(meters.torque);
      const {rms:iqr} = rms(meters.iq);
      document.getElementById('torqueAvg').textContent = Tm.toFixed(2);
      const ripplePct = (Math.abs(Tm)>1e-6)? (Tr/Math.abs(Tm)*100): 0;
      document.getElementById('torqueRipple').textContent = ripplePct.toFixed(2);
      document.getElementById('iqRipple').textContent = iqr.toFixed(2);
      // THD from i_a
      const fs = 1/params.Ts; const f1 = params.omega_e/(2*Math.PI);
      const N = Math.min(meters.ia.length, 1024);
      const win = meters.ia.slice(-N);
      const {thd} = computeTHDandSpectrum(win, fs, f1, 10);
      document.getElementById('thd').textContent = isFinite(thd)? thd.toFixed(2) : '—';
    }

    // --- drawing helpers ---
    const torquePlot = document.getElementById('torquePlot');
    const iqPlot = document.getElementById('iqPlot');
    const iaPlot = document.getElementById('iaPlot');
    const specPlot = document.getElementById('specPlot');

    function drawGrid(ctx){
      const w=ctx.canvas.width, h=ctx.canvas.height; ctx.save();
      ctx.strokeStyle= 'rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); for(let y=0;y<=h;y+=Math.floor(h/4)) { ctx.moveTo(0,y); ctx.lineTo(w,y); }
      for(let x=0;x<=w;x+=Math.floor(w/8)) { ctx.moveTo(x,0); ctx.lineTo(x,h); }
      ctx.stroke(); ctx.restore();
    }

    function drawLine(ctx, data, color, ymin=null, ymax=null){
      const w=ctx.canvas.width, h=ctx.canvas.height; ctx.clearRect(0,0,w,h); drawGrid(ctx);
      if(data.length<2) return;
      const N=Math.min(data.length, w);
      const arr=data.slice(-N);
      let min=Infinity,max=-Infinity; if(ymin==null||ymax==null){ for(const v of arr){ if(v<min)min=v; if(v>max)max=v; } if(min===max){min-=1;max+=1;} } else {min=ymin;max=ymax}
      const sx=w/(N-1); const sy=(h-8)/(max-min); ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=1.5; ctx.moveTo(0, h-4 - (arr[0]-min)*sy);
      for(let i=1;i<N;i++){ const x=i*sx; const y=h-4 - (arr[i]-min)*sy; ctx.lineTo(x,y);} ctx.stroke();
    }

    function drawBars(ctx, mags){
      const w=ctx.canvas.width, h=ctx.canvas.height; ctx.clearRect(0,0,w,h); drawGrid(ctx);
      const H=mags.length; if(H===0) return; const bw = (w-20)/H;
      const max=Math.max(1e-9, ...mags);
      for(let i=0;i<H;i++){
        const m=mags[i]; const bh = (m/max)*(h-10);
        ctx.fillStyle='rgba(96,165,250,.9)'; ctx.fillRect(10+i*bw, h-5-bh, bw*0.7, bh);
      }
    }

    function drawCharts(){
      const tctx = torquePlot.getContext('2d'); drawLine(tctx, meters.torque, '#7dd3fc');
      const iqctx = iqPlot.getContext('2d'); drawLine(iqctx, meters.iq, '#86efac');
      const iactx = iaPlot.getContext('2d'); drawLine(iactx, meters.ia, '#fca5a5');
      // spectrum
      const fs = 1/params.Ts; const f1 = params.omega_e/(2*Math.PI);
      const N = Math.min(meters.ia.length, 1024); const win = meters.ia.slice(-N);
      const {mags} = computeTHDandSpectrum(win, fs, f1, 10);
      const sctx = specPlot.getContext('2d'); drawBars(sctx, mags);
    }

    // ---------- 3D MAP (Torque Ripple vs ω & t_dead) ----------
    function clearMap(){ mapGroup.clear(); }

    async function generateMap(){
      clearMap();
      const N = parseInt(document.getElementById('mapN').value,10);
      const wMin=10, wMax=1200; const tdMin=50e-9, tdMax=3e-6;

      const geomOff = new THREE.PlaneGeometry(24, 24, N-1, N-1);
      const geomOn  = new THREE.PlaneGeometry(24, 24, N-1, N-1);
      geomOff.rotateX(-Math.PI/2); geomOn.rotateX(-Math.PI/2);

      const posOff = geomOff.attributes.position; const posOn = geomOn.attributes.position;

      // run coarse sims across grid
      const Zoff = [], Zon=[];
      for(let iy=0; iy<N; iy++){
        const td = tdMin + (tdMax-tdMin)*(iy/(N-1));
        for(let ix=0; ix<N; ix++){
          const w = wMin + (wMax-wMin)*(ix/(N-1));
          const off = mapSample(w, td, false);
          const on  = mapSample(w, td, true);
          Zoff.push(off); Zon.push(on);
        }
      }

      const zOffMax = Math.max(...Zoff); const zOnMax = Math.max(...Zon); const zMax = Math.max(zOffMax, zOnMax, 1e-6);
      // update vertices height (normalize to 0..6)
      for(let i=0;i<posOff.count;i++){
        posOff.setY(i, 6 * (Zoff[i]/zMax));
        posOn.setY(i, 6 * (Zon[i]/zMax));
      }
      posOff.needsUpdate=true; posOn.needsUpdate=true;

      const matOff = new THREE.MeshStandardMaterial({color:0xbd0026, wireframe:false, transparent:true, opacity:.60});
      const matOn  = new THREE.MeshStandardMaterial({color:0x00b34a, wireframe:false, transparent:true, opacity:.60});

      const meshOff = new THREE.Mesh(geomOff, matOff); meshOff.position.set(-14, 0, 0);
      const meshOn  = new THREE.Mesh(geomOn,  matOn);  meshOn.position.set( 14, 0, 0);

      const labelOff = textSprite('OFF: 토크 리플(정규화)', '#ff7880'); labelOff.position.set(-14, 4.5, 12.5);
      const labelOn  = textSprite('EKF ON: 토크 리플(정규화)', '#7dffb3'); labelOn.position.set(14, 4.5, 12.5);

      mapGroup.add(meshOff, meshOn, labelOff, labelOn);
    }

    function mapSample(omega_e, tdead, comp){
      // clone small sim; run for ~2 electrical periods; return torque RMS percentage
      const backup = { ...params };
      params.omega_e = omega_e; params.tdead_ns = tdead*1e9; params.compMode = comp? 'ekf':'off';

      const s = { id:0, iq:0, theta:0, x:new Float64Array([0,0,0,0]), P:(function(){const I=new Float64Array(16); for(let i=0;i<4;i++) I[i*4+i]=0.1; return I;})() };
      // small locals copy of step, without touching globals
      const Ld=params.Ld, Lq=params.Lq, Rs=params.Rs, Ts=params.Ts, psi_f=params.psi_f;
      let id_i=0, iq_i=0; const Kp=2.5, Ki=800; const arr=[];
      const steps = Math.max(200, Math.floor( (2*2*Math.PI/omega_e)/Ts )); // 2 periods
      for(let k=0;k<steps;k++){
        const err_d = params.id_ref - s.id; const err_q = params.iq_ref - s.iq;
        id_i += Ki*err_d*Ts; iq_i += Ki*err_q*Ts;
        let vd_cmd = Kp*err_d + id_i + Rs*s.id - omega_e*Lq*s.iq;
        let vq_cmd = Kp*err_q + iq_i + Rs*s.iq + omega_e*(Ld*s.id + psi_f);
        let vcomp_d = comp? s.x[2] : 0; let vcomp_q = comp? s.x[3] : 0;
        const vmax = params.Vdc/sqrt3; const mag = Math.hypot(vd_cmd+vcomp_d, vq_cmd+vcomp_q); if(mag>vmax){ const sc=vmax/mag; vd_cmd*=sc; vq_cmd*=sc; vcomp_d*=sc; vcomp_q*=sc; }
        const [ial,ibe] = dq_to_albe(s.id, s.iq, s.theta);
        const [ia,ib,ic]=albe_to_abc(ial,ibe);
        const [dva,dvb,dvc]=computeDisturbanceABC(ia,ib,ic);
        const [dv_al,dv_be]=abc_to_albe(dva,dvb,dvc);
        const [dv_d,dv_q]=albe_to_dq(dv_al,dv_be,s.theta);
        const did = (vd_cmd+vcomp_d - Rs*s.id + omega_e*Lq*s.iq - dv_d)/Ld;
        const diq = (vq_cmd+vcomp_q - Rs*s.iq - omega_e*(Ld*s.id + psi_f) - dv_q)/Lq;
        s.id += did*Ts; s.iq += diq*Ts; s.theta += omega_e*Ts; if(s.theta>2*Math.PI) s.theta-=2*Math.PI;
        // simple EKF predict-update
        const x=s.x; const P=s.P; const id=x[0], iq=x[1], vdd=x[2], vdq=x[3];
        const f1=(vd_cmd - Rs*id + omega_e*Lq*iq - vdd)/Ld; const f2=(vq_cmd - Rs*iq - omega_e*(Ld*id + psi_f) - vdq)/Lq;
        const a11=-Rs/Ld, a12=omega_e*Lq/Ld, a13=-1/Ld, a14=0, a21=-omega_e*Ld/Lq, a22=-Rs/Lq, a23=0, a24=-1/Lq;
        const F=[1+Ts*a11,Ts*a12,Ts*a13,Ts*a14, Ts*a21,1+Ts*a22,Ts*a23,Ts*a24, 0,0,1,0, 0,0,0,1];
        const xpred=new Float64Array([id+Ts*f1, iq+Ts*f2, vdd, vdq]);
        const Ppred = mat4add(mat4mul(mat4mul(F,P), transpose4(F)), Qd());
        const HP=[Ppred[0],Ppred[1],Ppred[2],Ppred[3], Ppred[4],Ppred[5],Ppred[6],Ppred[7]];
        const S11=HP[0]+params.rMeas, S22=HP[5]+params.rMeas, S12=HP[2], S21=HP[1];
        const det=S11*S22 - S12*S21; const invS=[S22/det, -S12/det, -S21/det, S11/det];
        const PHt=[Ppred[0],Ppred[4], Ppred[1],Ppred[5], Ppred[2],Ppred[6], Ppred[3],Ppred[7]];
        const K=[ PHt[0]*invS[0]+PHt[1]*invS[2], PHt[0]*invS[1]+PHt[1]*invS[3], PHt[2]*invS[0]+PHt[3]*invS[2], PHt[2]*invS[1]+PHt[3]*invS[3], PHt[4]*invS[0]+PHt[5]*invS[2], PHt[4]*invS[1]+PHt[5]*invS[3], PHt[6]*invS[0]+PHt[7]*invS[2], PHt[6]*invS[1]+PHt[7]*invS[3] ];
        const y1=s.id - xpred[0]; const y2=s.iq - xpred[1];
        x[0]=xpred[0]+K[0]*y1+K[1]*y2; x[1]=xpred[1]+K[2]*y1+K[3]*y2; x[2]=xpred[2]+K[4]*y1+K[5]*y2; x[3]=xpred[3]+K[6]*y1+K[7]*y2;
        const KH=[K[0],K[1],0,0, K[2],K[3],0,0, K[4],K[5],0,0, K[6],K[7],0,0];
        const I4=identity4(); const IminusKH=mat4sub(I4,KH); s.P = mat4mul(IminusKH,Ppred);
        const T = 1.5*params.p*(params.psi_f*s.iq + (params.Ld-params.Lq)*s.id*s.iq); arr.push(T);
      }
      // metric
      let m=0; for(const x of arr) m+=x; m/=arr.length||1; let s2=0; for(const x of arr) s2+=(x-m)*(x-m); s2/=arr.length||1; const rms=Math.sqrt(s2);
      // restore
      Object.assign(params, backup);
      return (Math.abs(m)>1e-6)? (rms/Math.abs(m)) : rms;
    }

    function textSprite(text, color='#cbd5e1'){
      const cvs=document.createElement('canvas'); cvs.width=1024; cvs.height=256; const ctx=cvs.getContext('2d');
      ctx.clearRect(0,0,cvs.width,cvs.height);
      ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,cvs.width,cvs.height);
      ctx.fillStyle=color; ctx.font='bold 90px Inter, ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, cvs.width/2, cvs.height/2);
      const tex=new THREE.CanvasTexture(cvs); tex.anisotropy=8; tex.encoding=THREE.sRGBEncoding;
      const mat=new THREE.SpriteMaterial({map:tex, transparent:true}); const sp=new THREE.Sprite(mat); sp.scale.set(14,3.5,1); return sp;
    }

    // ---------- WIRING UI ----------
    const $ = (id)=>document.getElementById(id);
    const BIND = [
      ['omega','omegaVal',v=>params.omega_e=parseFloat(v), v=>v],
      ['vdc','vdcVal',v=>params.Vdc=parseFloat(v), v=>v],
      ['tdead','tdeadVal',v=>params.tdead_ns=parseFloat(v), v=>v],
      ['ts','tsVal',v=>params.Ts=parseFloat(v)*1e-6, v=>v],
      ['rs','rsVal',v=>params.Rs=parseFloat(v), v=>Number(v).toFixed(2)],
      ['ld','ldVal',v=>{params.Ld=params.Lq=parseFloat(v)*1e-3}, v=>v],
      ['psif','psifVal',v=>params.psi_f=parseFloat(v), v=>Number(v).toFixed(2)],
      ['idref','idrefVal',v=>params.id_ref=parseFloat(v), v=>v],
      ['iqref','iqrefVal',v=>params.iq_ref=parseFloat(v), v=>v],
      ['qscale','qscaleVal',v=>params.qScale=parseFloat(v)/100, v=> (parseFloat(v)/100).toFixed(2)],
      ['rmeas','rmeasVal',v=>params.rMeas=parseFloat(v), v=> Number(v).toFixed(4)],
      ['mapN','mapNVal',v=>null, v=>`${v}×${v}`],
    ];
    for(const [id,valId,setter,fmt] of BIND){
      const el=$(id); const val=$(valId); const update=()=>{ setter(el.value); val.textContent=fmt(el.value) };
      el.addEventListener('input', update); update();
    }
    $('pp').addEventListener('change', e=>params.p=parseInt(e.target.value,10));
    $('device').addEventListener('change', e=>params.device=e.target.value);
    $('compMode').addEventListener('change', e=>params.compMode=e.target.value);
    $('backbone').addEventListener('change', e=>params.backbone=e.target.value);

    // presets
    $('presetCreep').onclick = ()=>{ $('omega').value=30; $('tdead').value=1200; $('iqref').value=20; $('compMode').value='ekf';
      ['omega','tdead','iqref'].forEach(id=>$(id).dispatchEvent(new Event('input'))); $('compMode').dispatchEvent(new Event('change')); };
    $('presetCruise').onclick = ()=>{ $('omega').value=450; $('tdead').value=600; $('iqref').value=80; $('compMode').value='off';
      ['omega','tdead','iqref'].forEach(id=>$(id).dispatchEvent(new Event('input'))); $('compMode').dispatchEvent(new Event('change')); };
    $('presetFW').onclick = ()=>{ $('omega').value=1000; $('tdead').value=800; $('iqref').value=120; $('vdc').value=300; $('idref').value=-20; $('compMode').value='ekf';
      ['omega','tdead','iqref','vdc','idref'].forEach(id=>$(id).dispatchEvent(new Event('input'))); $('compMode').dispatchEvent(new Event('change')); };

    let running = true, frameCount=0;
    $('toggle').onclick = ()=>{ running=!running; $('toggle').textContent = running? '⏸︎ 일시정지':'▶ 재생'; };
    $('reset').onclick = ()=>{ state.theta=0; state.id=0; state.iq=0; state.x.set([0,0,0,0]); meters.torque.length=0; meters.iq.length=0; meters.ia.length=0; };
    $('genMap').onclick = ()=>{ generateMap(); };
    $('mode').addEventListener('change', e=>{
      if(e.target.value==='map') generateMap(); else clearMap();
    });

    // ---------- TESTS ----------
    function appendTest(outEl, name, pass, details=''){
      const div=document.createElement('div');
      div.innerHTML = `<span class="${pass?'test-pass':'test-fail'}">${pass?'✔':'✖'}</span> ${name}${details?` — <span class="mono">${details}</span>`:''}`;
      outEl.appendChild(div);
    }
    function runTests(){
      const out = document.getElementById('testOut'); out.innerHTML='';
      // 1) THREE loaded
      appendTest(out, 'THREE 로딩', typeof THREE.WebGLRenderer==='function');
      // 2) OrbitControls available
      appendTest(out, 'OrbitControls 로딩', typeof OrbitControls==='function');
      // 3) Disturbance sign matches current sign
      const dvp = computeDisturbanceABC(1,0,0)[0];
      const dvn = computeDisturbanceABC(-1,0,0)[0];
      appendTest(out, '데드타임/다이오드 전압 부호', (dvp>0 && dvn<0), `+I→${dvp.toFixed(3)}V, -I→${dvn.toFixed(3)}V`);
      // 4) mapSample returns finite numbers (on/off)
      const mOff = mapSample(100, 1e-6, false);
      const mOn  = mapSample(100, 1e-6, true);
      appendTest(out, 'mapSample 유효 값(OFF)', Number.isFinite(mOff));
      appendTest(out, 'mapSample 유효 값(ON)',  Number.isFinite(mOn));
      // 5) One safe render
      let ok=true; try{ renderer.render(scene,camera); }catch(e){ ok=false; }
      appendTest(out, '렌더 1프레임', ok);
      // 6) THD test: pure sine → THD < 1%
      const fs=5000, f1=50, N=512; const sig=new Array(N).fill(0).map((_,n)=>Math.sin(2*Math.PI*f1*n/fs));
      const {thd:thdTest} = computeTHDandSpectrum(sig, fs, f1, 10);
      appendTest(out, 'THD(순정 사인) < 1%', thdTest < 1.0, `THD=${thdTest.toFixed(2)}%`);
    }
    document.getElementById('runTests').addEventListener('click', runTests);

    // ---------- MAIN LOOP ----------
    function loop(){
      requestAnimationFrame(loop); frameCount++;
      if(running && $('mode').value==='realtime'){
        // run several plant steps per frame for stability
        const steps = 4; for(let i=0;i<steps;i++) stepPlant();
      }
      controls.update();
      renderer.render(scene, camera);
    }
    loop();

    // ---------- RESIZE ----------
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

  </script>
</body>
</html>
