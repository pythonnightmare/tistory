<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Minimal Breaker — 오리지널 HTML5 게임</title>
  <style>
    /*
      Minimal Breaker (c) 2025 Original work by ChatGPT for user "돌려"
      - 순수 HTML/CSS/JS, 외부 라이브러리/에셋 0개
      - GitHub Pages/Tistory iframe 호스팅 적합
      - 기능: 모바일 최적화 토글, 맵 폭 축소(기본 9열/모바일 6열), 세로 비율 16:12, 모바일 1.6배(16:19.2)
      - 안정화: 모바일 화면 들썩임 방지 CSS/로직, 벽돌 즉시 파괴
      - 변경: 모바일에서 패들 폭 1/3, "스피드 x2" **독립 토글 버튼** 추가, "드래그 허용" 버튼으로 페이지 스크롤 가능 토글
      - Tests: 런타임 자기진단에 스피드 토글/드래그 토글 검사 추가
    */

    :root{ --bg:#0b0f17; --ink:#e6edf3; --muted:#9aa4b2; --primary:#2d7ff9; --accent:#23a559; --warn:#f5a524; --danger:#ef4444; --panel:#111827; }

    /* 화면 흔들림 방지 */
    html, body {
      overscroll-behavior: none;      /* 상/하 바운스 방지 */
      -webkit-overflow-scrolling: auto;
      overflow: hidden;               /* 페이지 자체 스크롤 제거 */
      -webkit-text-size-adjust: 100%; /* iOS 자동 글자 확대 방지 */
      height:100%; margin:0; background:var(--bg); color:var(--ink);
      font: 15px/1.5 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    .wrap{ display:flex; align-items:center; justify-content:center; min-height:100%; padding:16px; box-sizing:border-box; }

    /* 맵 폭 축소 */
    .game{ width:min(720px, 100%); margin:0 auto; }
    body.mobile .game{ width:min(600px, 100%); }

    .bar{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin:0 0 10px 0; color:var(--muted); flex-wrap:wrap; }
    .bar .left, .bar .right{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .tag{ background:var(--panel); color:var(--ink); border-radius:10px; padding:6px 10px; }
    .btn{ background:var(--panel); color:var(--ink); border:1px solid #202838; padding:6px 10px; border-radius:10px; cursor:pointer; }
    .btn:hover{ border-color:#2a3650; }

    /* 기본: 세로 16:12, 모바일: 1.6배 = 16:19.2 */
    canvas{
      width:100%; aspect-ratio: 16 / 12; display:block;
      background:linear-gradient(180deg, #0c111a 0%, #0c111a 70%, #0a0f18 100%);
      box-shadow:0 12px 40px rgba(0,0,0,.35); border-radius:14px;
      /* 터치 제스처로 스크롤/줌 방지 + 합성가속 (드래그 허용 모드에서 덮어씀) */
      touch-action: none; -webkit-user-select: none; user-select: none; transform: translateZ(0);
    }
    body.mobile canvas{ aspect-ratio: 16 / 19.2; }

    /* 드래그 허용 모드: 페이지 스크롤 허용 */
    body.drag-allow canvas{ touch-action: auto; }

    body.mobile .bar{ font-size:16px; }

    .help{ margin-top:10px; color:var(--muted); text-align:center; opacity:.9; }
    .kbd{ padding:2px 6px; border:1px solid #344156; border-radius:6px; color:var(--ink); }

    .toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:20px; background:#111827; color:var(--ink); padding:8px 12px; border-radius:10px; border:1px solid #202838; opacity:0; pointer-events:none; transition:opacity .25s ease; }
    .toast.show{ opacity:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <div class="bar">
        <div class="left">
          <span class="tag">Minimal Breaker</span>
          <span>점수 <strong id="score">0</strong></span>
          <span>스테이지 <strong id="stage">1</strong></span>
          <span>라이프 <strong id="lives">3</strong></span>
        </div>
        <div class="right">
          <button class="btn" id="btnMobile">모바일 최적화: 끔</button>
          <button class="btn" id="btnSpeed">속도 x1</button>
          <button class="btn" id="btnDrag">드래그: 차단</button>
          <button class="btn" id="btnPause">일시정지</button>
          <button class="btn" id="btnRestart">리셋</button>
        </div>
      </div>
      <canvas id="cv" width="1280" height="960" aria-label="브레이크아웃 게임 캔버스" role="img"></canvas>
      <div class="help">
        <span class="kbd">←</span>/<span class="kbd">→</span> 또는 <span class="kbd">A</span>/<span class="kbd">D</span> 이동 · <span class="kbd">Space</span> 발사/일시정지 · 터치 드래그(게임) / 드래그 허용 버튼(페이지)
      </div>
    </div>
  </div>
  <div class="toast" id="toast"></div>

  <script>
  (()=>{
    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');
    const scoreEl = document.getElementById('score');
    const stageEl = document.getElementById('stage');
    const livesEl = document.getElementById('lives');
    const btnPause = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    const btnMobile = document.getElementById('btnMobile');
    const btnSpeed = document.getElementById('btnSpeed');
    const btnDrag = document.getElementById('btnDrag');
    const toast = document.getElementById('toast');

    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const state = {
      w: 1280, h: 960, // 기본 16:12
      paddle: { x: 640, y: 920, w: 150, h: 16, speed: 650, targetX: 640 },
      balls: [], bricks: [], particles: [], powerups: [],
      rows: 7, cols: 9, gutter: 8, brickH: 24,
      score: 0, lives: 3, stage: 1,
      launched: false, paused: false,
      mobile: false,
      speedMul: 1,        // 속도 x1 / x2 토글
      dragAllow: false,   // 페이지 드래그 허용 여부
      last: 0,
    };

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand  = (a,b) => a + Math.random()*(b-a);

    function showToast(msg){
      toast.textContent = msg; toast.classList.add('show');
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(()=> toast.classList.remove('show'), 1200);
    }

    const container = document.querySelector('.game');
    let lastWidth = 0;

    function resize(){
      const rect = container.getBoundingClientRect();
      const width = Math.round(rect.width);
      if (Math.abs(width - lastWidth) < 1) return; // 가로폭이 같으면 무시
      lastWidth = width;

      state.w = Math.round(width * DPR);
      const ar = state.mobile ? (19.2/16) : (12/16); // 모바일 1.6배
      state.h = Math.round(width * ar * DPR);

      cv.width = state.w; cv.height = state.h;
      state.paddle.y = state.h - 40 * DPR;
      if(!state.launched){
        const p = state.paddle; const b = state.balls[0];
        if(b){ b.x = p.x; b.y = p.y - 20*DPR; }
      }
      layoutBricks();
    }

    function layoutBricks(){
      const { rows, cols, gutter, brickH } = state;
      const marginX = 28 * DPR;
      const marginY = 60 * DPR;
      const areaW = state.w - marginX*2;
      const bw = (areaW - (cols-1)*gutter) / cols;
      const colors = ['#2d7ff9','#23a559','#f5a524','#ef4444','#8b5cf6'];
      const bricks = [];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          bricks.push({ // 즉시 파괴
            x: Math.round(marginX + c*(bw+gutter)),
            y: Math.round(marginY + r*(brickH+gutter)),
            w: Math.round(bw), h: brickH,
            color: colors[(r+c)%colors.length], alive:true,
            score: 20
          });
        }
      }
      state.bricks = bricks;
    }

    function currentBaseSpeed(){
      // 모바일 여부 + 스피드 배수 반영
      const base = state.mobile ? 420 : 420; // 기본값은 동일, 가독성을 위해 분리
      return base * state.speedMul * DPR;
    }

    function newBall(x, y, speedMul=1){
      const speed = currentBaseSpeed() * speedMul;
      const angle = - (Math.PI*0.25 + Math.random()*Math.PI*0.5);
      state.balls.push({ x, y, r: (state.mobile? 10:8)*DPR, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed });
    }

    function resetLevel(next=false){
      if(next){ state.stage++; stageEl.textContent = state.stage; state.rows = Math.min(11, state.rows+1); }
      state.launched = false; state.balls.length = 0; state.powerups.length = 0;
      const p = state.paddle;
      // 모바일에서 패들 폭 1/3 적용
      const baseDesktop = 150 * DPR;
      const baseMobile  = (200 * (1/3)) * DPR; // 200 → 1/3
      const minDesktop  = 90 * DPR;
      const minMobile   = (140 * (1/3)) * DPR; // 140 → 1/3
      const baseW = state.mobile ? baseMobile : baseDesktop;
      const minW  = state.mobile ? minMobile  : minDesktop;
      p.w = clamp(baseW - (state.stage-1)*5*DPR, minW, 260*DPR);
      p.x = state.w/2; p.targetX = p.x;
      layoutBricks();
      newBall(p.x, state.paddle.y - 20*DPR);
      scoreEl.textContent = state.score; livesEl.textContent = state.lives;
    }

    function spawnParticles(x,y,color){ for(let i=0;i<8;i++) state.particles.push({ x, y, vx: rand(-80,80)*DPR, vy: rand(-120,0)*DPR, life: 0.6, color }); }

    function dropPowerup(x,y){
      const roll = Math.random(); let type=null;
      if(roll < 0.10) type='M'; else if(roll<0.22) type='W'; else if(roll<0.34) type='S';
      if(!type) return; state.powerups.push({ x, y, vy: 140*DPR, type, w: 22*DPR, h: 14*DPR });
    }

    function applyPowerup(type){
      const p = state.paddle;
      if(type==='W'){ p.w = clamp(p.w * 1.25, 90*DPR, 300*DPR); showToast('Paddle ↑ 넓이 증가'); }
      else if(type==='S'){ for(const b of state.balls){ b.vx*=0.8; b.vy*=0.8; } showToast('속도 ↓ 슬로우'); }
      else if(type==='M'){ const old = state.balls.slice(); for(const b of old){ newBall(b.x, b.y, 1); } showToast('멀티볼!'); }
    }

    function updateButtons(){
      btnMobile.textContent = `모바일 최적화: ${state.mobile ? '켬' : '끔'}`;
      btnSpeed.textContent  = `속도 x${state.speedMul}`;
      btnDrag.textContent   = `드래그: ${state.dragAllow ? '허용' : '차단'}`;
    }

    function setMobileMode(on){
      state.mobile = !!on;
      document.body.classList.toggle('mobile', state.mobile);
      state.cols = state.mobile ? 6 : 9;
      state.brickH = state.mobile ? 28 : 24;
      state.gutter = state.mobile ? 10 : 8;
      // 모바일/데스크톱 전환 시 패들 폭/볼 반지름 재설정 위해 리셋
      resetLevel(false);
      forceResize();
      updateButtons();
      showToast(state.mobile ? '모바일 UI 최적화 적용' : '모바일 최적화 해제');
    }

    function setSpeedMode(mult){
      mult = Math.max(1, Math.min(3, mult|0 || mult));
      if(mult === state.speedMul) return;
      const ratio = mult / state.speedMul;
      state.speedMul = mult;
      // 현재 공 속도도 즉시 스케일링
      for(const b of state.balls){ b.vx *= ratio; b.vy *= ratio; }
      updateButtons();
      showToast(`속도 x${state.speedMul}`);
    }

    function setDragAllow(on){
      state.dragAllow = !!on;
      document.body.classList.toggle('drag-allow', state.dragAllow);
      updateButtons();
      showToast(state.dragAllow ? '페이지 드래그 허용' : '페이지 드래그 차단');
    }

    const input = { left:false, right:false };
    window.addEventListener('keydown', e=>{
      if(e.code==='ArrowLeft' || e.code==='KeyA') input.left=true;
      if(e.code==='ArrowRight' || e.code==='KeyD') input.right=true;
      if(e.code==='Space') toggleLaunchOrPause();
    });
    window.addEventListener('keyup', e=>{
      if(e.code==='ArrowLeft' || e.code==='KeyA') input.left=false;
      if(e.code==='ArrowRight' || e.code==='KeyD') input.right=false;
    });

    // 터치 스크롤 조건부 차단 (dragAllow=false 일 때만 차단)
    document.addEventListener('touchmove', (e)=> {
      if(!state.dragAllow) e.preventDefault();
    }, { passive:false });

    let dragging=false;
    cv.addEventListener('pointerdown', e=>{
      if(state.dragAllow) return; // 페이지 드래그 허용 모드에선 게임 드래그 비활성화
      dragging=true; cv.setPointerCapture(e.pointerId);
      if(!state.launched && !state.paused) state.launched=true;
    });
    cv.addEventListener('pointerup',   ()=>{ dragging=false; });
    cv.addEventListener('pointermove', e=>{
      if(state.dragAllow || !dragging) return;
      const rect = cv.getBoundingClientRect();
      const x = (e.clientX - rect.left) * DPR;
      state.paddle.targetX = x;
    });

    btnPause.addEventListener('click', ()=>{ state.paused = !state.paused; btnPause.textContent = state.paused? '계속' : '일시정지'; });
    btnRestart.addEventListener('click', ()=>{ state.score=0; state.lives=3; state.stage=1; stageEl.textContent=1; resetLevel(false); });
    btnMobile.addEventListener('click', ()=> setMobileMode(!state.mobile));
    btnSpeed.addEventListener('click',  ()=> setSpeedMode(state.speedMul===1?2:1));
    btnDrag.addEventListener('click',   ()=> setDragAllow(!state.dragAllow));

    function toggleLaunchOrPause(){
      if(!state.launched){ state.launched=true; }
      else { state.paused = !state.paused; btnPause.textContent = state.paused? '계속' : '일시정지'; }
    }

    function rectCircleCollide(rx,ry,rw,rh, cx,cy,cr){
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx-nx, dy = cy-ny; return (dx*dx + dy*dy) <= cr*cr;
    }

    function step(dt){
      const p = state.paddle;
      const move = (input.right?1:0) - (input.left?1:0);
      if(move !== 0){ p.targetX += move * p.speed * dt; }
      p.x += (p.targetX - p.x) * Math.min(1, dt*12);
      p.x = clamp(p.x, p.w/2 + 8*DPR, state.w - p.w/2 - 8*DPR);

      for(let i=state.balls.length-1;i>=0;i--){
        const b = state.balls[i];
        if(!state.launched){ b.x = p.x; b.y = p.y - 20*DPR; continue; }
        b.x += b.vx*dt; b.y += b.vy*dt;
        if(b.x < b.r){ b.x=b.r; b.vx*=-1; }
        if(b.x > state.w - b.r){ b.x=state.w - b.r; b.vx*=-1; }
        if(b.y < b.r + 8*DPR){ b.y=b.r + 8*DPR; b.vy*=-1; }
        if(b.y > state.h + 50*DPR){ state.balls.splice(i,1); }
      }

      if(state.launched && state.balls.length===0){
        state.lives--; livesEl.textContent = state.lives;
        if(state.lives<0){ state.lives=3; state.score=0; state.stage=1; stageEl.textContent=1; showToast('게임 오버'); }
        resetLevel(false); return;
      }

      // Paddle collision
      for(const b of state.balls){
        if(rectCircleCollide(p.x-p.w/2, p.y-p.h/2, p.w, p.h, b.x,b.y,b.r)){
          const rel = (b.x - p.x) / (p.w/2);
          const speed = Math.hypot(b.vx,b.vy) * 1.01;
          const ang = (-Math.PI*0.15) + (-Math.PI*0.7) * rel;
          b.vx = Math.cos(ang)*speed; b.vy = -Math.abs(Math.sin(ang)*speed);
          b.y = p.y - p.h/2 - b.r - 0.1;
        }
      }

      // Brick collision & scoring — 즉시 파괴
      let aliveCount = 0;
      for(const br of state.bricks){
        if(!br.alive) continue; aliveCount++;
        for(const b of state.balls){
          if(!rectCircleCollide(br.x, br.y, br.w, br.h, b.x,b.y,b.r)) continue;
          const ox = (br.x + br.w/2) - b.x; const oy = (br.y + br.h/2) - b.y;
          const ax = (br.w/2 + b.r) - Math.abs(ox); const ay = (br.h/2 + b.r) - Math.abs(oy);
          if(ax < ay){ b.vx *= -1; b.x += (ox>0? -ax: ax); }
          else { b.vy *= -1; b.y += (oy>0? -ay: ay); }
          br.alive = false; state.score += br.score; scoreEl.textContent = state.score;
          spawnParticles(b.x,b.y, br.color); dropPowerup(br.x+br.w/2, br.y+br.h/2);
        }
      }

      // Powerups
      for(let i=state.powerups.length-1;i>=0;i--){
        const pu = state.powerups[i]; pu.y += pu.vy*dt;
        if(rectCircleCollide(p.x-p.w/2, p.y-p.h/2, p.w, p.h, pu.x, pu.y, Math.max(pu.w,pu.h)/2)){
          applyPowerup(pu.type); state.powerups.splice(i,1); continue;
        }
        if(pu.y > state.h + 40*DPR) state.powerups.splice(i,1);
      }

      // Particles
      for(let i=state.particles.length-1;i>=0;i--){
        const pa = state.particles[i]; pa.life -= dt; if(pa.life<=0){ state.particles.splice(i,1); continue; }
        pa.x += pa.vx*dt; pa.y += pa.vy*dt; pa.vy += 480*DPR*dt;
      }

      if(aliveCount===0){ showToast(`스테이지 ${state.stage} 클리어`); resetLevel(true); }
    }

    function draw(){
      const { w,h } = state; ctx.clearRect(0,0,w,h);
      const grd = ctx.createLinearGradient(0,0,0,h); grd.addColorStop(0,'#0f172a'); grd.addColorStop(1,'#0b1220'); ctx.fillStyle=grd; ctx.fillRect(0,0,w,h);

      for(const br of state.bricks){ if(!br.alive) continue; ctx.fillStyle=br.color; ctx.fillRect(br.x, br.y, br.w, br.h); ctx.fillStyle='rgba(0,0,0,.15)'; ctx.fillRect(br.x, br.y+br.h-4*DPR, br.w, 4*DPR); }

      const p = state.paddle; ctx.fillStyle='#1f2a44'; ctx.fillRect(p.x-p.w/2, p.y-p.h/2, p.w, p.h); ctx.fillStyle='#2d7ff9'; ctx.fillRect(p.x-p.w/2, p.y-p.h/2, p.w, 4*DPR);

      for(const b of state.balls){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle='#e6edf3'; ctx.fill(); ctx.closePath(); }

      for(const pu of state.powerups){ ctx.fillStyle='#111827'; ctx.fillRect(pu.x-pu.w/2, pu.y-pu.h/2, pu.w, pu.h); ctx.strokeStyle='#2a3650'; ctx.strokeRect(pu.x-pu-w/2, pu.y-pu.h/2, pu.w, pu.h); ctx.fillStyle='#23a559'; ctx.font=`${12*DPR}px ui-sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(pu.type, pu.x, pu.y+1*DPR); }

      for(const pa of state.particles){ ctx.globalAlpha = Math.max(0, pa.life/0.6); ctx.fillStyle = pa.color; ctx.fillRect(pa.x,pa.y, 3*DPR,3*DPR); ctx.globalAlpha = 1; }

      if(state.paused){ drawCenterText('일시정지 — Space', h*0.5); } else if(!state.launched){ drawCenterText('Space 또는 터치로 시작', h*0.5); }
    }

    function drawCenterText(t, y){
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,y-40*DPR, state.w, 80*DPR);
      ctx.fillStyle='#e6edf3'; ctx.font=`${24*DPR}px ui-sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(t, state.w/2, y);
    }

    function loop(ts){ if(!state.last) state.last = ts; const dt = Math.min(0.033, (ts - state.last)/1000); state.last = ts; if(!state.paused) step(dt); draw(); requestAnimationFrame(loop); }

    // --- Test helpers ---
    function approx(a,b,eps=1e-3){ return Math.abs(a-b) <= eps; }
    function assert(cond, msg){ if(!cond) throw new Error(msg); }
    function forceResize(){ lastWidth = 0; resize(); }

    function runTests(){
      try{
        // 1) 기본 속성
        assert(typeof state.paddle.h === 'number', 'paddle.h should be a number');

        // 2) 비율 테스트
        const prevMobile = state.mobile; const prevSpeed = state.speedMul; const prevDrag = state.dragAllow;
        state.mobile = false; forceResize();
        assert(approx(state.h/state.w, 12/16, 0.02), 'desktop aspect ~12/16');
        state.mobile = true; forceResize();
        assert(approx(state.h/state.w, 19.2/16, 0.02), 'mobile aspect ~19.2/16');

        // 3) 스피드 토글 테스트
        const b0 = {vx:100, vy:0}; const old = Math.hypot(b0.vx,b0.vy);
        state.balls.push(b0); setSpeedMode(2); // x2
        const ratio = Math.hypot(b0.vx,b0.vy) / old; assert(approx(ratio,2,0.01),'speed toggle scales velocity x2');
        state.balls.pop(); setSpeedMode(prevSpeed);

        // 4) 드래그 토글 텍스트 반영
        setDragAllow(true);  assert(btnDrag.textContent.includes('허용'),'drag button shows 허용');
        setDragAllow(false); assert(btnDrag.textContent.includes('차단'),'drag button shows 차단');

        // 5) draw/step smoke
        step(0.016); draw();

        // 복구
        state.mobile = prevMobile; setDragAllow(prevDrag); forceResize();

        console.log('[Minimal Breaker] Tests passed.');
        showToast('Self-test: OK');
      }catch(err){
        console.error('[Minimal Breaker] Test failed:', err);
        showToast('Self-test failed (F12 console)');
      }
      updateButtons();
    }

    function init(){
      state.paddle.h = 16*DPR;
      requestAnimationFrame(()=>{ const r = container.getBoundingClientRect(); lastWidth = Math.round(r.width); resize(); });
      resetLevel(false);
      window.addEventListener('resize', resize);
      requestAnimationFrame(loop);
      setTimeout(runTests, 60);
      updateButtons();
    }

    init();
  })();
  </script>
</body>
</html>
