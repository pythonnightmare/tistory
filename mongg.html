<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EV Free Drive — IPMSM FOC→Overmod→6-Step (+MTPA/MTPV, SVPWM, Deadtime, Phasor)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{ --bg:#0b0f14; --panel:#111826; --muted:#7d8aa3; --text:#e8eef9; --accent:#4cc9f0; --accent2:#a0e9ff; --shadow:0 10px 30px rgba(0,0,0,.35); --radius:18px }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 80% -10%,#1a2330 0%,#0b0f14 55%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Apple SD Gothic Neo,Noto Sans KR,Arial}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;position:sticky;top:0;backdrop-filter:blur(6px);z-index:50;border-bottom:1px solid rgba(255,255,255,.06);background:linear-gradient(180deg,rgba(8,11,17,.86),rgba(8,11,17,.45))}
    header .left{display:flex;align-items:center;gap:10px}
    header h1{font-size:16px;margin:0;font-weight:800}
    header .sub{color:#9fb3cc;font-size:11px}
    .btnbar{display:flex;gap:6px;flex-wrap:wrap}
    .btn{background:linear-gradient(180deg,#1e2635,#141b27);border:1px solid rgba(255,255,255,.12);color:#e8f3ff;padding:8px 10px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:var(--shadow);font-size:12px}
    .btn.accent{background:linear-gradient(180deg,#34d5ff,#1aaadb);color:#06283b;border-color:rgba(76,201,240,.6)}
    .btn.warn{background:linear-gradient(180deg,#ffd76a,#f3b740);color:#2a1d00}
    .drawer{display:none}
    .drawer.open{display:block}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);box-shadow:var(--shadow);margin:8px 14px}
    .card h2{font-size:12px;letter-spacing:.35px;text-transform:uppercase;color:var(--accent2);margin:0;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.06)}
    .tabs{display:grid;grid-template-columns: repeat(4,1fr);gap:6px;padding:8px}
    .tab{cursor:pointer;text-align:center;padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0f1522;font-size:12px}
    .tab.active{background:linear-gradient(180deg,#34d5ff,#1aaadb);color:#052531;border-color:rgba(76,201,240,.6);font-weight:800}
    .panel{display:none;padding:10px 12px 12px}
    .panel.active{display:block}
    .group{border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px;margin-bottom:10px;background:rgba(255,255,255,.02)}
    .group-title{color:#b9d7ff;font-weight:800;font-size:11px;text-transform:uppercase;letter-spacing:.35px;margin-bottom:8px}
    .row{display:grid;grid-template-columns: 1fr auto;gap:8px;align-items:center;margin:6px 0}
    input[type=number],select{width:120px;background:#0d1320;color:var(--text);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:6px 8px;font-size:12px}
    input[type=range]{width:100%}
    .app{display:grid;grid-template-columns: 1fr 450px;gap:10px;padding:8px 14px}
    #three-wrap{height:clamp(560px, 70vh, 880px);border-radius:18px;overflow:hidden;outline:none}
    .telemetry{display:grid;grid-template-columns: repeat(auto-fit, minmax(120px,1fr));gap:6px;padding:6px 0}
    .tile{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 10px}
    .tile .k{font-size:10px;color:#9fd3ff;text-transform:uppercase;letter-spacing:.35px}
    .tile .v{font-size:16px;font-weight:800;margin-top:2px}
    .sidebar{display:flex;flex-direction:column;gap:10px;min-height:0}
    canvas.chart{width:100%;height:160px}
    #phasor{width:100%;height:220px;background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.08);border-radius:14px}
    @media (max-width: 1100px){ .app{grid-template-columns:1fr} }
    footer{color:#7d8aa3;font-size:11px;text-align:center;padding:8px}
  </style>

  <!-- Import Map (CDN) -->
  <script type="importmap">
  { "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <header>
    <div class="left">
      <button id="btnControls" class="btn">☰ Controls</button>
      <h1>EV Free Drive — IPMSM FOC→Overmod→6-Step</h1>
      <span class="sub">W/↑ 가속 · S/↓ 브레이크 · ←(우회전) →(좌회전) · Space 일시정지/재개</span>
    </div>
    <div class="btnbar">
      <button id="btnStart" class="btn accent">▶ 시작</button>
      <button id="btnPause" class="btn">⏸ 일시정지</button>
      <button id="btnReset" class="btn warn">↺ 초기화</button>
      <button id="btnCsv" class="btn">⤓ CSV</button>
      <button id="btnFollow" class="btn">🎥 Follow: ON</button>
      <button id="btnStep80" class="btn">⏱ 속도스텝 0→80</button>
    </div>
  </header>

  <!-- Controls -->
  <section id="controlsDrawer" class="card drawer" aria-hidden="true">
    <h2>Controls</h2>
    <div class="tabs">
      <div class="tab active" data-tab="drive">Drive</div>
      <div class="tab" data-tab="motor">IPMSM</div>
      <div class="tab" data-tab="adv">Advanced</div>
      <div class="tab" data-tab="help">Help</div>
    </div>

    <div class="panel active" id="panel-drive">
      <div class="group">
        <div class="group-title">주행 모드</div>
        <div class="row">
          <label>모드</label>
          <select id="mode">
            <option value="pedal">Pedal (스로틀/브레이크)</option>
            <option value="cruise" selected>Cruise (목표속도)</option>
          </select>
        </div>
        <div id="cruiseBox">
          <div class="row"><label>목표 속도 (km/h)</label><input id="targetKmh" type="number" value="80" step="1"></div>
          <div class="row"><label>속도 PI Kp/Ki</label>
            <span><input id="Kps" type="number" value="6" step="0.5" style="width:70px"> / <input id="Kis" type="number" value="2" step="0.2" style="width:70px"></span>
          </div>
          <div class="row"><label>속도 타임콘스턴트 τv(s)</label><input id="taus" type="number" value="0.8" step="0.1"></div>
        </div>
        <div id="pedalBox" style="display:none">
          <div class="row"><label>스로틀 (%)</label><input id="throttle" type="range" min="0" max="100" value="0"></div>
          <div class="row"><label>브레이크 (%)</label><input id="brake" type="range" min="0" max="100" value="0"></div>
          <div class="row"><label>조향 (°)</label><input id="steer" type="range" min="-30" max="30" value="0"></div>
          <div class="row"><label>키 반응(%/s)</label>
            <select id="keyRate"><option value="50">느림</option><option value="100" selected>보통</option><option value="180">빠름</option></select>
          </div>
        </div>
        <div class="btnbar" style="margin-top:8px">
          <button id="btnDisturb" class="btn">⚡ 부하시험(+300Nm, 2s)</button>
        </div>
      </div>

      <div class="group">
        <div class="group-title">차량/환경</div>
        <div class="row"><label>m (kg)</label><input id="mass" type="number" value="1600" step="10"></div>
        <div class="row"><label>Rw/G</label>
          <span><input id="Rw" type="number" value="0.31" step="0.01" style="width:70px"> / <input id="gear" type="number" value="9.0" step="0.1" style="width:70px"></span>
        </div>
        <div class="row"><label>η / CdA / c_r</label>
          <span><input id="eta" type="number" value="0.95" step="0.01" style="width:64px"> / <input id="CdA" type="number" value="0.70" step="0.05" style="width:64px"> / <input id="cr" type="number" value="0.012" step="0.002" style="width:64px"></span>
        </div>
        <div class="row"><label>ρ (kg/m³)</label><input id="rho" type="number" value="1.225" step="0.01"></div>
        <div class="row"><label>마찰 μ</label><input id="mu" type="number" value="1.0" step="0.05"></div>
        <div class="row"><label>등판(°)</label><input id="gradeDeg" type="number" value="0" step="0.5"></div>
        <div class="row"><label>표시 스무딩 τ(ms)</label><input id="smoothMs" type="number" value="250" step="25"></div>
        <div class="row"><label>차트 주기/창</label>
          <span><input id="chartMs" type="number" value="120" step="10" style="width:80px"> / <input id="chartWindow" type="number" value="60" step="10" style="width:80px"> s</span>
        </div>
      </div>
    </div>

    <div class="panel" id="panel-motor">
      <div class="group">
        <div class="group-title">인버터/전원</div>
        <div class="row"><label>Vdc (V)</label><input id="Vdc" type="number" value="400" step="10"></div>
        <div class="row"><label>전류 제한 Imax (A)</label><input id="Imax" type="number" value="600" step="10"></div>
        <div class="row"><label>제어 모드</label>
          <select id="ctrlMode">
            <option value="auto" selected>Auto (FOC→Overmod→6-Step)</option>
            <option value="foc">FOC (SVPWM만)</option>
            <option value="six">강제 6-Step</option>
          </select>
        </div>
        <div class="row"><label>MTPA</label>
          <select id="mtpaOn"><option value="1" selected>ON</option><option value="0">OFF (Id=0)</option></select>
        </div>
        <div class="row"><label>Flux Weakening 게인</label><input id="Kfw" type="number" value="1200" step="50"></div>
        <div class="row"><label>PWM fsw (kHz)</label><input id="fswKhz" type="number" value="10" step="1"></div>
        <div class="row"><label>Deadtime</label><select id="deadOn"><option value="1" selected>ON</option><option value="0">OFF</option></select></div>
        <div class="row"><label>Td (µs)</label><input id="deadUs" type="number" value="1.0" step="0.1"></div>
      </div>
      <div class="group">
        <div class="group-title">IPMSM 파라미터</div>
        <div class="row"><label>극쌍수 p</label><input id="pp" type="number" value="4" step="1"></div>
        <div class="row"><label>Rs (Ω)</label><input id="Rs" type="number" value="0.05" step="0.005"></div>
        <div class="row"><label>Ld/Lq (H)</label>
          <span><input id="Ld" type="number" value="0.00025" step="0.00005" style="width:90px"> / <input id="Lq" type="number" value="0.00050" step="0.00005" style="width:90px"></span>
        </div>
        <div class="row"><label>자속 ψf (Wb)</label><input id="psif" type="number" value="0.06" step="0.005"></div>
        <div class="row"><label>관성 J (kg·m²)</label><input id="J" type="number" value="0.35" step="0.05"></div>
        <div class="row"><label>점성 B (Nms)</label><input id="B" type="number" value="0.02" step="0.01"></div>
      </div>
    </div>

    <div class="panel" id="panel-adv">
      <div class="group"><div class="group-title">자동튜닝 & 테스트</div>
        <div class="btnbar">
          <button id="btnAutoSpeed" class="btn">⚙️ 속도 PI 자동튜닝</button>
          <button id="btnStepChange" class="btn">⏱ 속도스텝 60→150</button>
          <button id="btnForceOver" class="btn">🧪 과변조 유도(+Vdc↓)</button>
        </div>
        <div style="font-size:12px;color:#9fb3cc;margin-top:6px">
          선형 SVPWM 한계: V<sub>max,lin</sub>=Vdc/√3, 6-Step 능선: V<sub>hex</sub>=2Vdc/3, m=|V<sub>dq,ref</sub>|/V<sub>max,lin</sub>.<br/>
          m≤1: FOC(SVPWM), 1&lt;m&lt;1.1547: Overmod(플랫탑), ≥1.1547: 6-Step. Deadtime은 위상 전압에 부호 기반 보정.
        </div>
      </div>
    </div>

    <div class="panel" id="panel-help">
      <div class="group"><div class="group-title">키보드</div>
        <div>W/↑ 가속 · S/↓ 브레이크 · ←(우회전) →(좌회전) · Space 재생/일시정지</div>
        <div>본 시뮬은 교육용 단순화 모델(평균 전압, 연속시간 근사)을 사용합니다.</div>
      </div>
    </div>
  </section>

  <main class="app">
    <section class="card" style="padding:8px">
      <div class="telemetry">
        <div class="tile"><div class="k">속도</div><div class="v" id="v_kmh">0.0 km/h</div></div>
        <div class="tile"><div class="k">모터 rpm</div><div class="v" id="rpm">0</div></div>
        <div class="tile"><div class="k">i_d / i_q</div><div class="v" id="idq">0 / 0 A</div></div>
        <div class="tile"><div class="k">v_d / v_q</div><div class="v" id="vdq">0 / 0 V</div></div>
        <div class="tile"><div class="k">|V| / m</div><div class="v" id="Vmag">0 / 0.00</div></div>
        <div class="tile"><div class="k">영역</div><div class="v" id="region">SVPWM</div></div>
        <div class="tile"><div class="k">E_bemf</div><div class="v" id="ebemf">0 V</div></div>
        <div class="tile"><div class="k">토크</div><div class="v" id="tq">0 N·m</div></div>
      </div>
      <div id="three-wrap" tabindex="0"></div>
    </section>

    <aside class="sidebar">
      <div class="card" style="padding:10px">
        <div style="font-weight:800;color:#bfe3ff;margin:6px 2px">📈 Telemetry (Time s)</div>
        <canvas id="chartSpeed"   class="chart"></canvas>
        <canvas id="chartMod"     class="chart"></canvas>
        <canvas id="chartDQ"      class="chart"></canvas>
        <canvas id="chartPhase"   class="chart"></canvas>
        <canvas id="chartTorque"  class="chart"></canvas>
      </div>
      <div class="card" style="padding:10px">
        <div style="font-weight:800;color:#bfe3ff;margin:6px 2px">🧭 Phasor — dq 벡터 vs 원/헥사</div>
        <canvas id="phasor" width="260" height="220"></canvas>
      </div>
    </aside>
  </main>

  <footer>© EV Free Drive — IPMSM FOC/Overmod/6-Step 단일 HTML (MTPA+MTPV, SVPWM, Deadtime, Phasor)</footer>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---------- Utils ----------
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const sign0=(x)=> Math.abs(x)<1e-9 ? 0 : (x>0?1:-1);

    // EMA smoother for tiles
    const smoother=(()=>{ const m=new Map(); let last=performance.now(); return{
      dt(){ const now=performance.now(); const d=now-last; last=now; return d; },
      run(k,target,tauMs,dtMs){ if(!tauMs||tauMs<=1){m.set(k,target);return target;}
        const prev=m.has(k)?m.get(k):target; const a=1-Math.exp(-dtMs/Math.max(1,tauMs));
        const out=prev+a*(target-prev); m.set(k,out); return out; }
    };})();

    // DOM
    const $=id=>document.getElementById(id);
    const els={
      btnControls:$('btnControls'), drawer:$('controlsDrawer'),
      btnStart:$('btnStart'), btnPause:$('btnPause'), btnReset:$('btnReset'), btnCsv:$('btnCsv'), btnFollow:$('btnFollow'),
      btnDisturb:$('btnDisturb'), btnAutoSpeed:$('btnAutoSpeed'), btnStepChange:$('btnStepChange'), btnStep80:$('btnStep80'), btnForceOver:$('btnForceOver'),
      tabs:[...document.querySelectorAll('.tab')], panels:{drive:$('panel-drive'), motor:$('panel-motor'), adv:$('panel-adv'), help:$('panel-help')},
      // drive
      mode:$('mode'), targetKmh:$('targetKmh'), Kps:$('Kps'), Kis:$('Kis'), taus:$('taus'),
      throttle:$('throttle'), brake:$('brake'), steer:$('steer'), keyRate:$('keyRate'),
      // vehicle
      mass:$('mass'), Rw:$('Rw'), gear:$('gear'), eta:$('eta'), CdA:$('CdA'), cr:$('cr'), rho:$('rho'), mu:$('mu'), gradeDeg:$('gradeDeg'),
      chartMs:$('chartMs'), chartWindow:$('chartWindow'), smoothMs:$('smoothMs'),
      // inverter/motor
      Vdc:$('Vdc'), Imax:$('Imax'), ctrlMode:$('ctrlMode'), mtpaOn:$('mtpaOn'), Kfw:$('Kfw'),
      pp:$('pp'), Rs:$('Rs'), Ld:$('Ld'), Lq:$('Lq'), psif:$('psif'), J:$('J'), B:$('B'),
      fswKhz:$('fswKhz'), deadOn:$('deadOn'), deadUs:$('deadUs'),
      // tiles
      v_kmh:$('v_kmh'), rpm:$('rpm'), idq:$('idq'), vdq:$('vdq'), Vmag:$('Vmag'), region:$('region'), ebemf:$('ebemf'), tq:$('tq')
    };

    // Drawer + tabs
    els.btnControls.addEventListener('click',()=>{ els.drawer.classList.toggle('open'); els.drawer.setAttribute('aria-hidden', !els.drawer.classList.contains('open'));});
    els.tabs.forEach(t=>t.addEventListener('click',()=>{ els.tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active'); const k=t.dataset.tab; Object.values(els.panels).forEach(p=>p.classList.remove('active')); $('panel-'+k).classList.add('active');}));

    // Mode UI
    const cruiseBox=document.getElementById('cruiseBox'), pedalBox=document.getElementById('pedalBox');
    const setModeVis=()=>{ const m=els.mode.value; cruiseBox.style.display=m==='cruise'?'':'none'; pedalBox.style.display=m==='pedal'?'':''; };
    els.mode.addEventListener('change', setModeVis); setModeVis();

    // ---------- Charts ----------
    const mkX=()=>({type:'linear', title:{display:true, text:'Time (s)', color:'#cfe4ff'}, ticks:{color:'#9fb3cc'}, grid:{color:'rgba(255,255,255,.08)'}});
    const mkY=(t)=>({title:{display:!!t, text:t, color:'#cfe4ff'}, ticks:{color:'#9fb3cc'}, grid:{color:'rgba(255,255,255,.06)'}});
    const plugins={legend:{labels:{color:'#cfe4ff'}}, decimation:{enabled:true, algorithm:'lttb', samples:800}};

    const cSpeed=new Chart($('chartSpeed'),{type:'line',data:{datasets:[
      {label:'Speed (km/h)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Ref (km/h)',   data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('km/h')}, plugins}});

    const cMod=new Chart($('chartMod'),{type:'line',data:{datasets:[
      {label:'|Vdq,act| (V)', data:[], yAxisID:'y1', borderWidth:2, pointRadius:0, tension:.18},
      {label:'m(ref)', data:[], yAxisID:'y2', borderWidth:2, pointRadius:0, tension:.18},
      {label:'E_bemf(V)', data:[], yAxisID:'y1', borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y1:mkY('V'), y2:{position:'right', grid:{drawOnChartArea:false}, ticks:{color:'#9fb3cc'}, title:{display:true, text:'m', color:'#cfe4ff'}}}, plugins}});

    const cDQ=new Chart($('chartDQ'),{type:'line',data:{datasets:[
      {label:'i_d(A)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'i_q(A)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'v_d(V)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]},
      {label:'v_q(V)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('A / V')}, plugins}});

    const cPhase=new Chart($('chartPhase'),{type:'line',data:{datasets:[
      {label:'Va (V)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Vb (V)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Vc (V)', data:[], borderWidth:2, pointRadius:0, tension:.18}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('V_phase')}, plugins}});

    const cTorque=new Chart($('chartTorque'),{type:'line',data:{datasets:[
      {label:'Torque (Nm)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Load (Nm)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('Nm')}, plugins}});

    const MAX_POINTS=6000;
    const pushXY=(chart, arr)=>{ const t=state.t; chart.data.datasets.forEach((ds,i)=>{ ds.data.push({x:t, y:arr[i]}); if(ds.data.length>MAX_POINTS) ds.data.shift(); const win=timeWindowSec(); while(ds.data.length && ds.data[0].x < t-win) ds.data.shift();}); chart.update('none'); };
    function chartIntervalMs(){ return Math.max(16, +els.chartMs.value||120); }
    function timeWindowSec(){ return Math.max(5, +els.chartWindow.value||60); }

    // ---------- 3D Scene ----------
    const wrap=$('three-wrap');
    const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0f14);
    const camera=new THREE.PerspectiveCamera(55, wrap.clientWidth/Math.max(1,wrap.clientHeight), .1, 5000); camera.position.set(-18,10,18);
    const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(wrap.clientWidth, wrap.clientHeight); renderer.shadowMap.enabled=true; wrap.appendChild(renderer.domElement);
    const controls=new OrbitControls(camera, renderer.domElement); controls.target.set(0,1,0); controls.update();
    wrap.addEventListener('pointerdown',()=>wrap.focus()); window.addEventListener('load',()=>wrap.focus(),{once:true});

    scene.add(new THREE.HemisphereLight(0xbfd1ff, 0x202020, .9));
    const dir=new THREE.DirectionalLight(0xffffff,.9); dir.position.set(25,40,20); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); scene.add(dir);
    const ground=new THREE.Mesh(new THREE.PlaneGeometry(4000,4000), new THREE.MeshStandardMaterial({color:0x0e1624, metalness:.25, roughness:.95}));
    ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
    scene.add(new THREE.GridHelper(2000, 200, 0x2b415e, 0x0e1624));

    function wheel(){
      const tire=new THREE.Mesh(new THREE.TorusGeometry(0.42,0.11,16,28), new THREE.MeshStandardMaterial({color:0x111, roughness:0.9, metalness:0.1})); tire.rotation.y=Math.PI/2;
      const rim=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.16,16), new THREE.MeshStandardMaterial({color:0xcad6e3, metalness:0.7, roughness:0.35})); rim.rotation.z=Math.PI/2; rim.position.x=0.02;
      const g=new THREE.Group(); g.add(tire,rim); g.castShadow=true; return g;
    }
    function createSedan(){
      const car=new THREE.Group();
      const L=4.4, W=1.88, wheelbase=2.7, track=1.58, groundClear=0.18;
      const lower=new THREE.Mesh(new THREE.BoxGeometry(L,0.45,W), new THREE.MeshStandardMaterial({color:0x122a44, metalness:.6, roughness:.35}));
      lower.position.set(0, groundClear+0.225, 0); lower.castShadow=true; car.add(lower);
      const body=new THREE.Mesh(new THREE.BoxGeometry(L*0.86,0.6,W*0.98), new THREE.MeshStandardMaterial({color:0x1a3f6a, metalness:.6, roughness:.28}));
      body.position.set(0.05, groundClear+0.75, 0); body.castShadow=true; car.add(body);
      const hood=new THREE.Mesh(new THREE.BoxGeometry(1.35,0.35,W*0.95), new THREE.MeshStandardMaterial({color:0x1a4a7c, metalness:.6, roughness:.28}));
      hood.position.set(L*0.5-1.2, groundClear+0.95, 0); hood.rotation.z=-Math.PI*0.06; hood.castShadow=true; car.add(hood);
      const trunk=new THREE.Mesh(new THREE.BoxGeometry(1.05,0.35,W*0.95), new THREE.MeshStandardMaterial({color:0x173a63, metalness:.6, roughness:.28}));
      trunk.position.set(-L*0.5+0.9, groundClear+0.95, 0); trunk.rotation.z= Math.PI*0.03; trunk.castShadow=true; car.add(trunk);
      const glass=new THREE.Mesh(new THREE.BoxGeometry(1.9,0.5,W*0.85), new THREE.MeshPhysicalMaterial({color:0xaad4ff, metalness:0, roughness:0.05, transmission:0.6, transparent:true, ior:1.45}));
      glass.position.set(-0.15, groundClear+1.25, 0); glass.rotation.z=0.08; car.add(glass);
      const bumperM = new THREE.MeshStandardMaterial({color:0x0f2034, metalness:.5, roughness:.45});
      const frontB = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.28,W*0.96), bumperM); frontB.position.set(L*0.5-0.25, groundClear+0.45, 0); car.add(frontB);
      const rearB  = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.28,W*0.96), bumperM); rearB.position.set(-L*0.5+0.25, groundClear+0.45, 0); car.add(rearB);
      const headM = new THREE.MeshStandardMaterial({color:0x222, emissive:0xfff4d0, emissiveIntensity:3});
      const tailM = new THREE.MeshStandardMaterial({color:0x222, emissive:0xff3b3b, emissiveIntensity:2.2});
      const headL=new THREE.Mesh(new THREE.SphereGeometry(0.08), headM); const headR=headL.clone();
      headL.position.set(L*0.5-0.1, groundClear+0.55,  W*0.38); headR.position.set(L*0.5-0.1, groundClear+0.55, -W*0.38); car.add(headL,headR);
      const tailL=new THREE.Mesh(new THREE.SphereGeometry(0.08), tailM); const tailR=tailL.clone();
      tailL.position.set(-L*0.5+0.1, groundClear+0.55,  W*0.38); tailR.position.set(-L*0.5+0.1, groundClear+0.55, -W*0.38); car.add(tailL,tailR);
      const wFL=wheel(), wFR=wheel(), wRL=wheel(), wRR=wheel();
      const xF =  wheelbase*0.5, xR = -wheelbase*0.5, z = track*0.5;
      wFL.position.set( xF, groundClear+0.42,  z);
      wFR.position.set( xF, groundClear+0.42, -z);
      wRL.position.set( xR, groundClear+0.42,  z);
      wRR.position.set( xR, groundClear+0.42, -z);
      car.add(wFL,wFR,wRL,wRR);
      const carAxes=new THREE.AxesHelper(1.2); carAxes.position.set(0, groundClear+0.4, 0); car.add(carAxes);
      car.userData.wheels = {wFL,wFR,wRL,wRR};
      car.userData.params = {Rw:0.31};
      return car;
    }
    const car = createSedan(); scene.add(car);

    // ---------- Model / State ----------
    const state={
      running:false, follow:true, t:0,
      // mech
      v:0, yaw:0, pos:new THREE.Vector3(0,0,0),
      // motor electrical (dq frame currents & voltages)
      theta_e:0, id:0, iq:0, vd:0, vq:0, va:0, vb:0, vc:0,
      // control (speed PI)
      evInt:0,
      // logs
      log:[],
      // test
      disturbT:0, disturbTEnd:0
    };
    let last=performance.now();

    // ---------- Parameter access ----------
    function P(){ return {
      // vehicle
      m:+els.mass.value, Rw:+els.Rw.value, gear:+els.gear.value, eta:+els.eta.value, CdA:+els.CdA.value, cr:+els.cr.value, rho:+els.rho.value, mu:+els.mu.value, grade:+els.gradeDeg.value*Math.PI/180,
      // drive
      mode:els.mode.value, targetKmh:+els.targetKmh.value, Kps:+els.Kps.value, Kis:+els.Kis.value, taus:+els.taus.value,
      thr:(+els.throttle?.value||0)/100, brk:(+els.brake?.value||0)/100, keyRate:+els.keyRate?.value||100,
      // motor/inverter
      Vdc:+els.Vdc.value, Imax:+els.Imax.value, ctrlMode:els.ctrlMode.value, mtpa:(els.mtpaOn.value==='1'), Kfw:+els.Kfw.value,
      pp:+els.pp.value, Rs:+els.Rs.value, Ld:+els.Ld.value, Lq:+els.Lq.value, psif:+els.psif.value, J:+els.J.value, B:+els.B.value,
      fsw:(+els.fswKhz.value||10)*1000, deadOn:(els.deadOn.value==='1'), Td:+els.deadUs.value*1e-6
    };}

    // ---------- Transforms ----------
    function dq_to_ab(d,q,th){ const c=Math.cos(th), s=Math.sin(th); return {a:c*d - s*q, b:s*d + c*q}; }
    function ab_to_dq(a,b,th){ const c=Math.cos(th), s=Math.sin(th); return {d:c*a + s*b, q:-s*a + c*b}; }
    function ab_to_abc(a,b){
      const va = a;
      const vb = -0.5*a + (Math.sqrt(3)/2)*b;
      const vc = -0.5*a - (Math.sqrt(3)/2)*b;
      return {va,vb,vc};
    }
    function abc_to_ab(va,vb,vc){ const a = (2/3)*(va - 0.5*(vb+vc)); const b=(2/3)*((Math.sqrt(3)/2)*(vb - vc)); return {a,b}; }
    function currentsABC_fromDQ(id,iq,th){
      const ab = dq_to_ab(id,iq,th);
      const abc = ab_to_abc(ab.a,ab.b);
      return {ia:abc.va, ib:abc.vb, ic:abc.vc};
    }

    // ---------- IPMSM core ----------
    function torque_ipmsm(pp, psif, Ld, Lq, id, iq){
      return 1.5*pp*( psif*iq + (Ld - Lq)*id*iq );
    }
    function voltage_dq(Rs, Ld, Lq, psif, id, iq, we){
      const vd = Rs*id - we*Lq*iq;
      const vq = Rs*iq + we*(Ld*id + psif);
      return {vd, vq};
    }

    // ---------- MTPA / MTPV ----------
    function mtpa_idiq(Is, Ld, Lq, psif){
      const dlt = Ld - Lq; if(Math.abs(Is)<1e-9) return {id:0, iq:0};
      const num = -psif + Math.sqrt(psif*psif + 8*dlt*dlt*Is*Is);
      const id = num / (4*dlt);
      const iq = Math.sqrt(Math.max(0, Is*Is - id*id));
      return {id, iq};
    }
    function ref_with_MTPA_MTPV(Tm_ref, we, p){
      const Imax = p.Imax, Vlin=p.Vdc/Math.sqrt(3), Vhex=2*p.Vdc/3;
      const Vtarget = (p.ctrlMode==='foc')? Vlin : Vhex;
      let id_ref=0, iq_ref=0;

      if(p.mtpa){
        // find Is on MTPA to meet torque
        let lo=0, hi=Imax, best={id:0,iq:0,T:0};
        for(let k=0;k<20;k++){
          const Is=(lo+hi)/2;
          let {id,iq}=mtpa_idiq(Is,p.Ld,p.Lq,p.psif);
          iq=Math.sign(Tm_ref)*Math.abs(iq);
          const T=torque_ipmsm(p.pp,p.psif,p.Ld,p.Lq,id,iq);
          if(Math.abs(T)>=Math.abs(Tm_ref)){ best={id,iq,T}; hi=Is; } else { lo=Is; best={id,iq,T}; }
        }
        id_ref=best.id; iq_ref=best.iq;
      }else{
        iq_ref = clamp(Tm_ref/(1.5*p.pp*p.psif), -Imax, Imax);
        id_ref = 0;
        const Is=Math.hypot(id_ref,iq_ref); if(Is>Imax){ const k=Imax/Is; id_ref*=k; iq_ref*=k; }
      }

      // Flux-weakening (simple proportional on voltage error)
      let {vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we);
      let V=Math.hypot(vd,vq);
      if(V>Vtarget && Math.abs(we)>1e-6){
        const err = V - Vtarget;
        id_ref -= (p.Kfw * err) / (Math.abs(we)+1e-6);
        let Is=Math.hypot(id_ref,iq_ref); if(Is>Imax){ const k=Imax/Is; id_ref*=k; iq_ref*=k; }
        ({vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we));
        V=Math.hypot(vd,vq);
      }

      // MTPV sliding if 여전히 초과 → 전류원(circle) 위에서 -d축으로 슬라이딩
      if(V>Vtarget && Math.abs(we)>1e-6){
        const Is=Math.hypot(id_ref,iq_ref);
        for(let it=0; it<60 && V>Vtarget; it++){
          id_ref -= 0.005*Is;
          const sc = Is/Math.max(1e-9,Math.hypot(id_ref,iq_ref));
          id_ref*=sc; iq_ref*=sc;
          ({vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we));
          V=Math.hypot(vd,vq);
        }
      }
      return {id:id_ref, iq:iq_ref};
    }

    // ---------- Modulation: SVPWM / Overmod / 6-Step + Deadtime ----------
    const M_HEX = 2/Math.sqrt(3); // 1.1547...
    function regionFromM(m){ return (m<=1)?'SVPWM' : (m<M_HEX-1e-9?'Overmod':'6-Step'); }

    function svm_duties(vα, vβ, Vdc, Ts, region){
      // sector, alpha
      let θ = Math.atan2(vβ, vα); if(θ<0) θ+=2*Math.PI;
      const sector = Math.floor(θ/(Math.PI/3)) + 1; // 1..6
      const base = (sector-1)*(Math.PI/3);
      const α = θ - base;
      const Vref = Math.hypot(vα, vβ);
      const K = (Math.sqrt(3)/Vdc)*Vref; // normalized magnitude
      let T1 = K*Math.sin(Math.PI/3 - α)*Ts;
      let T2 = K*Math.sin(α)*Ts;
      T1=Math.max(0,T1); T2=Math.max(0,T2);
      let T0 = Ts - T1 - T2;

      if(region==='SVPWM' && T0<0){ // clamp back to linear
        const s = Ts/(T1+T2+1e-12); T1*=s; T2*=s; T0=0;
      }
      if(region==='Overmod'){ // flat-top: force T0=0, scale T1/T2
        if(T0<0){ const s = Ts/(T1+T2+1e-12); T1*=s; T2*=s; T0=0; }
        else { T0=0; }
      }
      if(region==='6-Step'){ // collapse to active vector (T1+T2=Ts or one-hot)
        // pick center of sector → two switches high
        // emulate as T1=Ts, T2=0
        T1=Ts; T2=0; T0=0;
      }

      // duties by sector (space-vector symmetrical placement: T0/2 on both ends)
      let da,db,dc;
      const halfT0=T0/2;
      switch(sector){
        case 1: da=(T1+T2+halfT0)/Ts; db=(T2+halfT0)/Ts; dc=halfT0/Ts; break;
        case 2: da=(T1+halfT0)/Ts;     db=(T1+T2+halfT0)/Ts; dc=halfT0/Ts; break;
        case 3: da=halfT0/Ts;          db=(T1+T2+halfT0)/Ts; dc=(T2+halfT0)/Ts; break;
        case 4: da=halfT0/Ts;          db=(T1+halfT0)/Ts;     dc=(T1+T2+halfT0)/Ts; break;
        case 5: da=(T2+halfT0)/Ts;     db=halfT0/Ts;          dc=(T1+T2+halfT0)/Ts; break;
        case 6: da=(T1+T2+halfT0)/Ts;  db=halfT0/Ts;          dc=(T1+halfT0)/Ts; break;
      }
      return {da:clamp(da,0,1), db:clamp(db,0,1), dc:clamp(dc,0,1), sector};
    }

    // convert duties to line-neutral average voltages
    function phaseVoltages_fromDuties(da,db,dc,Vdc){
      // zero-sequence removed (v_a+v_b+v_c=0)
      const va = (2/3)*Vdc*(da - 0.5*(db+dc));
      const vb = (2/3)*Vdc*(db - 0.5*(dc+da));
      const vc = (2/3)*Vdc*(dc - 0.5*(da+db));
      return {va,vb,vc};
    }

    function abc_from_six(theta, Vdc){
      const ang = (theta%(2*Math.PI)+2*Math.PI)%(2*Math.PI);
      const sec = Math.floor(ang/(Math.PI/3));
      const map = [[1,1,0],[0,1,0],[0,1,1],[0,0,1],[1,0,1],[1,0,0]][sec];
      const pa = (map[0]? +Vdc/2 : -Vdc/2), pb=(map[1]?+Vdc/2:-Vdc/2), pc=(map[2]?+Vdc/2:-Vdc/2);
      const avg=(pa+pb+pc)/3;
      return {va:pa-avg, vb:pb-avg, vc:pc-avg};
    }

    function apply_deadtime(va,vb,vc, ia,ib,ic, Vdc, Td, Ts){
      const Vdead = Vdc*(Td/Math.max(1e-9,Ts));
      return {
        va: va - Vdead*Math.sign(ia||0),
        vb: vb - Vdead*Math.sign(ib||0),
        vc: vc - Vdead*Math.sign(ic||0)
      };
    }

    function applyModulation(vα_ref, vβ_ref, p, theta_e, ia,ib,ic){
      const Vlin = p.Vdc/Math.sqrt(3);
      const Vhex = 2*p.Vdc/3;
      const Vref = Math.hypot(vα_ref, vβ_ref);
      const m_ref = Vref / Vlin;
      let region = regionFromM(m_ref);
      let va,vb,vc, da,db,dc;

      if(p.ctrlMode==='foc'){ region='SVPWM'; }
      if(p.ctrlMode==='six'){ region='6-Step'; }

      if(region==='6-Step' && p.ctrlMode!=='foc'){
        ({va,vb,vc} = abc_from_six(theta_e, p.Vdc));
      }else{
        // scale for foc to keep inside linear
        let vα=vα_ref, vβ=vβ_ref;
        if(p.ctrlMode==='foc' && Vref>Vlin){ const k=Vlin/Vref; vα*=k; vβ*=k; }
        // SVM duties (with overmod flat-top if needed)
        ({da,db,dc} = svm_duties(vα, vβ, p.Vdc, 1/Math.max(1,p.fsw), region));
        ({va,vb,vc} = phaseVoltages_fromDuties(da,db,dc,p.Vdc));
      }

      // Deadtime
      if(p.deadOn){
        ({va,vb,vc} = apply_deadtime(va,vb,vc, ia,ib,ic, p.Vdc, p.Td, 1/Math.max(1,p.fsw)));
      }

      // Effective alpha-beta for |Vdq,act|
      const ab = abc_to_ab(va,vb,vc);
      const Vmag = Math.hypot(ab.a, ab.b);
      return {va,vb,vc, Vmag, m:Math.min(M_HEX, m_ref), region, duties:{da,db,dc}};
    }

    // ---------- Phasor canvas ----------
    const phasor = $('phasor');
    const pctx = phasor.getContext('2d');
    function drawCircle(ctx,cx,cy,r){ ctx.beginPath(); ctx.arc(cx,cy,r,0,2*Math.PI); ctx.stroke(); }
    function drawHex(ctx,cx,cy,r){
      ctx.beginPath();
      for(let k=0;k<6;k++){
        const a = Math.PI/6 + k*Math.PI/3;
        const x=cx+r*Math.cos(a), y=cy-r*Math.sin(a);
        if(k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.stroke();
    }
    function drawLine(ctx,x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    function drawPhasor(Vd,Vq,Vdc){
      const w=phasor.width, h=phasor.height, cx=w/2, cy=h/2, padding=18;
      const rHex = Math.min(w,h)/2 - padding;
      const Vhex = 2*Vdc/3, Vlin = Vdc/Math.sqrt(3);
      const s = rHex / Vhex; // px per Volt
      pctx.clearRect(0,0,w,h);
      pctx.lineWidth=1;

      pctx.strokeStyle='#2e415c'; drawCircle(pctx,cx,cy,Vlin*s);
      pctx.strokeStyle='#f3b740'; drawHex(pctx,cx,cy,Vhex*s);

      // axes
      pctx.strokeStyle='rgba(255,255,255,.18)'; drawLine(pctx, padding,cy, w-padding,cy); drawLine(pctx, cx,padding, cx,h-padding);

      // vector
      pctx.strokeStyle='#e8eef9'; pctx.lineWidth=2;
      drawLine(pctx, cx,cy, cx+Vd*s, cy- Vq*s);

      // tip dot
      pctx.fillStyle='#34d5ff'; pctx.beginPath(); pctx.arc(cx+Vd*s, cy- Vq*s, 3, 0, 2*Math.PI); pctx.fill();
    }

    // ---------- Input handling ----------
    const down=new Set();
    function ensurePedalMode(){ if(els.mode.value!=='pedal'){ els.mode.value='pedal'; els.mode.dispatchEvent(new Event('change')); } }
    window.addEventListener('keydown',e=>{
      const tag=(e.target?.tagName||'').toLowerCase(); if(tag==='input'||tag==='select'||tag==='textarea') return;
      if(['KeyW','KeyS','KeyA','KeyD','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)){ e.preventDefault(); down.add(e.code); }
    }, {capture:true});
    window.addEventListener('keyup',e=>down.delete(e.code), {capture:true});

    function applyKey(dt){
      const p=P();
      if(p.mode==='cruise'){ if(down.has('Space')){ toggleRun(); } return; }
      let thr=+els.throttle.value, brk=+els.brake.value, steer=+els.steer.value;
      if(down.has('KeyW')||down.has('ArrowUp')) thr += p.keyRate*dt;
      if(down.has('KeyS')||down.has('ArrowDown')) brk += p.keyRate*dt;
      if(!(down.has('KeyW')||down.has('ArrowUp'))) thr -= p.keyRate*0.6*dt;
      if(!(down.has('KeyS')||down.has('ArrowDown'))) brk -= p.keyRate*0.8*dt;
      thr=clamp(thr,0,100); brk=clamp(brk,0,100);
      if(thr>0&&brk>0){ if(thr>brk) brk=0; else thr=0; }
      const steerRate=120;
      if(down.has('KeyA')) steer -= steerRate*dt;
      if(down.has('KeyD')) steer += steerRate*dt;
      if(down.has('ArrowLeft'))  steer += steerRate*dt; // ← = 우회전
      if(down.has('ArrowRight')) steer -= steerRate*dt; // → = 좌회전
      if(!(down.has('KeyA')||down.has('KeyD')||down.has('ArrowLeft')||down.has('ArrowRight'))){
        const backRate=160*dt; steer += (steer>0 ? -1:1)*Math.min(Math.abs(steer), backRate);
      }
      steer = clamp(steer, -30, 30);
      els.throttle.value=Math.round(thr); els.brake.value=Math.round(brk); els.steer.value=Math.round(steer);
      if(down.has('Space')){ toggleRun(); }
      ensurePedalMode();
    }
    function toggleRun(){ state.running=!state.running; down.delete('Space'); if(state.running){ last=performance.now(); requestAnimationFrame(loop);} }

    // ---------- Simulation ----------
    const DT_INT=0.0005; // 2 kHz integ (전기모델 평균화)
    let lastChart=0;

    function roadLoadTorque(p, v){
      const F_roll = p.m*9.80665*p.cr*sign0(v);
      const F_aero = 0.5*p.rho*p.CdA*v*v*sign0(v);
      const F_grade = p.m*9.80665*Math.sin(p.grade);
      const F = F_roll+F_aero+F_grade;
      return (F*p.Rw/p.gear)/Math.max(1e-6,p.eta);
    }

    function stepSim(dt){
      const p=P();

      // --- Outer: Speed PI → torque-like demand ---
      const vref = (p.mode==='cruise') ? clamp(p.targetKmh,0,220)/3.6 : ( (p.thr - 0.9*p.brk)*3.0 );
      const ev = vref - state.v;
      const torqueCmd = p.Kps*ev + state.evInt*p.Kis;
      const Kaw_s = 1/Math.max(0.1, p.taus);
      state.evInt += ( ev + Kaw_s*0 ) * dt;

      // demand Nm + load comp
      const TreqNm = clamp(torqueCmd*400, -4000, 4000);
      const Tload = roadLoadTorque(p, state.v);
      const Tm_ref = TreqNm + Tload + state.disturbT;

      // --- Electrical speed and references ---
      const w_mech = state.v / Math.max(1e-9, p.Rw) * p.gear; // rad/s shaft
      const we = p.pp * w_mech; // electrical rad/s

      // (id,iq) via MTPA + FW + MTPV
      let {id:id_ref, iq:iq_ref} = ref_with_MTPA_MTPV(Tm_ref, we, p);

      // ideal decoupled voltage to track (id,iq) (education-purpose)
      let {vd:vd_ref, vq:vq_ref} = voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we);

      // dq→αβ (reference)
      const vAB_ref = dq_to_ab(vd_ref, vq_ref, state.theta_e);

      // currents for deadtime sign
      const iabc = currentsABC_fromDQ(state.id, state.iq, state.theta_e);

      // Apply modulation (SVPWM / Overmod / 6-Step) + Deadtime
      const mod = applyModulation(vAB_ref.a, vAB_ref.b, p, state.theta_e, iabc.ia, iabc.ib, iabc.ic);

      // Actual dq voltage from applied phase voltages
      const ab_act = abc_to_ab(mod.va, mod.vb, mod.vc);
      const vdq_act = ab_to_dq(ab_act.a, ab_act.b, state.theta_e);
      state.vd = vdq_act.d; state.vq = vdq_act.q;

      // Electrical current dynamics
      const did = (state.vd - p.Rs*state.id + we*p.Lq*state.iq)/p.Ld;
      const diq = (state.vq - p.Rs*state.iq - we*(p.Ld*state.id + p.psif))/p.Lq;
      state.id += did*dt; state.iq += diq*dt;

      // phase voltage (for charts)
      state.va=mod.va; state.vb=mod.vb; state.vc=mod.vc;

      // Torque & mech update
      const Tm = torque_ipmsm(p.pp,p.psif,p.Ld,p.Lq,state.id,state.iq);
      const Tw = (Tm * p.gear * p.eta) / Math.max(1e-6, p.Rw); // tire force
      const F_mu = p.mu * p.m * 9.80665;
      let F_trac = clamp(Tw, -F_mu, F_mu);
      const v=state.v;
      const F_roll = p.m*9.80665*p.cr*sign0(v);
      const F_aero = 0.5*p.rho*p.CdA*v*v*sign0(v);
      const F_grade = p.m*9.80665*Math.sin(p.grade);
      const F_long = F_trac - F_roll - F_aero - F_grade;
      state.v += (F_long/Math.max(1e-6,p.m)) * dt;

      // elec angle
      state.theta_e += we*dt;

      // sticky stop
      if(Math.abs(state.v)<0.02 && Math.abs(Tm_ref)<2) state.v*=0.985;

      // tiles + charts
      const dtMs=smoother.dt(); const tau = Math.max(0, +els.smoothMs.value||250);
      const kmhVal= state.v*3.6;
      const rpmVal = w_mech*60/(2*Math.PI);
      const Ebemf = Math.abs(we)*p.psif;
      els.v_kmh.textContent = `${smoother.run('kmh',kmhVal, tau, dtMs).toFixed(1)} km/h`;
      els.rpm.textContent   = `${smoother.run('rpm', rpmVal, tau, dtMs).toFixed(0)}`;
      els.idq.textContent   = `${smoother.run('id', state.id, tau, dtMs).toFixed(1)} / ${smoother.run('iq', state.iq, tau, dtMs).toFixed(1)} A`;
      els.vdq.textContent   = `${smoother.run('vd', state.vd, tau, dtMs).toFixed(1)} / ${smoother.run('vq', state.vq, tau, dtMs).toFixed(1)} V`;
      els.Vmag.textContent  = `${smoother.run('vm', mod.Vmag, tau, dtMs).toFixed(1)} / ${smoother.run('m', mod.m, tau, dtMs).toFixed(3)}`;
      els.region.textContent= mod.region;
      els.ebemf.textContent = `${smoother.run('eb', Ebemf, tau, dtMs).toFixed(1)} V`;
      els.tq.textContent    = `${smoother.run('tq', Tm, tau, dtMs).toFixed(1)} N·m`;

      updateCar();

      const now=performance.now();
      if(now-lastChart>chartIntervalMs()){
        pushXY(cSpeed,   [kmhVal, (p.mode==='cruise'?p.targetKmh:kmhVal)]);
        pushXY(cMod,     [mod.Vmag, (Math.hypot(vd_ref, vq_ref)/(p.Vdc/Math.sqrt(3))), Ebemf]);
        pushXY(cDQ,      [state.id, state.iq, state.vd, state.vq]);
        pushXY(cPhase,   [state.va, state.vb, state.vc]);
        const tau_load = roadLoadTorque(p, state.v);
        pushXY(cTorque,  [Tm, tau_load]);
        lastChart=now;
      }

      drawPhasor(state.vd, state.vq, p.Vdc);

      // log
      state.log.push({t:state.t, kmh:kmhVal, ref:(p.mode==='cruise'?p.targetKmh:kmhVal), id:state.id, iq:state.iq, vd:state.vd, vq:state.vq, V:mod.Vmag, m:mod.m, tq:Tm, eb:Ebemf});
      state.t += dt;
    }

    function updateCar(){
      car.position.set(state.pos.x, 0, state.pos.z);
      const step = state.v*DT_INT;
      state.pos.x += step;
      const {wFL,wFR,wRL,wRR}=car.userData.wheels;
      const Rw = P().Rw;
      const wW = state.v / Math.max(1e-6, Rw);
      [wFL,wFR,wRL,wRR].forEach(w=> w.rotation.x -= wW*(1/60));
      if(state.follow){
        const back = new THREE.Vector3(-10,6,0);
        const camPos = new THREE.Vector3().copy(car.position).add(back);
        camera.position.lerp(new THREE.Vector3(camPos.x, camPos.y, camPos.z), .15);
        const look = new THREE.Vector3(car.position.x+4, 1, car.position.z);
        controls.target.lerp(look, .2); controls.update();
      }
      renderer.render(scene,camera);
    }

    function loop(now){ if(!state.running) return; const dt=Math.min(.02,(now-last)/1000); last=now;
      let rem=dt; while(rem>1e-9){ const h=Math.min(DT_INT,rem); applyKey(h); stepSim(h); rem-=h; }
      requestAnimationFrame(loop);
    }

    new ResizeObserver(()=>{ const w=wrap.clientWidth, h=wrap.clientHeight; renderer.setSize(w,h); camera.aspect=w/Math.max(1,h); camera.updateProjectionMatrix(); }).observe(wrap);

    // ---------- Buttons ----------
    els.btnStart.addEventListener('click',()=>{ if(!state.running){ state.running=true; last=performance.now(); requestAnimationFrame(loop);} });
    els.btnPause.addEventListener('click',()=> state.running=false);
    els.btnReset.addEventListener('click',()=>{ state.running=false;
      Object.assign(state,{t:0,v:0,yaw:0,pos:new THREE.Vector3(0,0,0), id:0,iq:0,vd:0,vq:0,theta_e:0, log:[], disturbT:0, disturbTEnd:0});
      [cSpeed,cMod,cDQ,cPhase,cTorque].forEach(ch=>{ ch.data.datasets.forEach(ds=>ds.data=[]); ch.update(); });
      car.position.set(0,0,0); car.rotation.set(0,0,0); drawPhasor(0,0, +els.Vdc.value||400);
    });
    els.btnCsv.addEventListener('click',()=>{ if(!state.log.length) return;
      const rows=[["t(s)","speed(km/h)","speed_ref(km/h)","id(A)","iq(A)","vd(V)","vq(V)","|V|(V)","m","torque(Nm)","E_bemf(V)"],
        ...state.log.map(d=>[d.t.toFixed(4),d.kmh.toFixed(3),d.ref.toFixed(3),d.id.toFixed(3),d.iq.toFixed(3),d.vd.toFixed(3),d.vq.toFixed(3),d.V.toFixed(3),d.m.toFixed(5),d.tq.toFixed(3),d.eb.toFixed(3)])];
      const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='ipmsm_foc_overmod_6step_full.csv'; a.click(); URL.revokeObjectURL(url);
    });
    els.btnFollow.addEventListener('click',()=>{ state.follow=!state.follow; els.btnFollow.textContent = state.follow?'🎥 Follow: ON':'🎥 Follow: OFF'; });
    els.btnDisturb.addEventListener('click',()=>{ state.disturbT=300; state.disturbTEnd=state.t+2; setTimeout(()=>state.disturbT=0,2000); });
    els.btnStep80.addEventListener('click',()=>{ els.mode.value='cruise'; setModeVis(); els.targetKmh.value=80; });
    els.btnStepChange.addEventListener('click',()=>{ els.mode.value='cruise'; setModeVis(); els.targetKmh.value = (+els.targetKmh.value<100)?150:60; });
    els.btnAutoSpeed.addEventListener('click',()=>{ // rough gain from vehicle params
      const p=P(); const a_gain = 300/p.m; const tauv = Math.max(0.3, +els.taus.value||0.8);
      const Kps = 1/Math.max(1e-6, a_gain*tauv); const Kis = 0.5/tauv;
      els.Kps.value=Kps.toFixed(2); els.Kis.value=Kis.toFixed(2);
    });
    els.btnForceOver.addEventListener('click',()=>{ els.Vdc.value = Math.max(100,(+els.Vdc.value||400) * 0.7); });

    // ---------- Self-test ----------
    (function(){
      const approx=(a,b,e=1e-6)=>Math.abs(a-b)<=e;
      const Vdc=400; const Vlin=Vdc/Math.sqrt(3), Vhex=2*Vdc/3; console.assert(approx((Vhex/Vlin), 2/Math.sqrt(3), 1e-6),'m_hex mismatch');
    })();

    // initial phasor
    drawPhasor(0,0,+els.Vdc.value||400);
  </script>
</body>
</html>
