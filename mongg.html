<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IPMSM — MTPA · Overmodulation · 6-Step EV Drive Simulator (v2.7.2)</title>

  <!-- 폰트 / 라이브러리 (defer로 미리 로드) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1624; --panel2:#0e1522; --text:#e8eef9; --muted:#8aa0be;
      --accent:#4cc9f0; --accent2:#a0e9ff; --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
      --shadow:0 12px 32px rgba(0,0,0,.35); --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 800px at 20% 0%,#0d1421 0%,#0b0f14 60%);
      color:var(--text); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif
    }
    .wrap{display:grid; grid-template-rows:auto 1fr; height:100vh}
    header{
      display:flex; align-items:center; justify-content:space-between; padding:14px 18px;
      background:linear-gradient(180deg,rgba(76,201,240,.08),rgba(160,233,255,.03));
      border-bottom:1px solid #1e2738; position:sticky; top:0; z-index:10
    }
    .brand{display:flex; gap:12px; align-items:center}
    .badge{
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
      background:linear-gradient(90deg,rgba(76,201,240,.18),rgba(160,233,255,.12));
      border:1px solid rgba(160,233,255,.25);
      box-shadow:0 0 0 2px rgba(160,233,255,.06) inset; font-weight:600; letter-spacing:.2px
    }
    .badge small{color:var(--muted); font-weight:600}
    .brand h1{font-size:18px; margin:0; letter-spacing:.2px}
    .toolbar{display:flex; gap:10px; align-items:center}
    .toolbar button{
      appearance:none; border:1px solid #26304a; background:linear-gradient(180deg,#122033,#0f1a2b);
      padding:8px 10px; border-radius:10px; color:var(--text); font-weight:700; letter-spacing:.2px; cursor:pointer
    }
    .toolbar button.primary{border-color:#2b7490; background:linear-gradient(180deg,#124a63,#0d3b4f)}

    .main{display:grid; grid-template-columns:2fr 1fr; gap:16px; padding:16px; height:calc(100vh - 68px)}
    .panel{
      background:linear-gradient(180deg,var(--panel) 0%, var(--panel2) 100%);
      border:1px solid #1b2334; border-radius:var(--radius); box-shadow:var(--shadow)
    }
    .card{position:relative; padding:10px 10px 14px 10px}
    .card h4{position:absolute; top:10px; left:12px; margin:0; font-size:12px; color:var(--muted); letter-spacing:.3px}
    canvas{width:100% !important; height:100% !important; display:block}
    .vehicle3d{min-height:320px}
    .charts{display:grid; grid-template-rows:1fr 1fr 1fr; gap:16px; height:100%}
    .charts .card{min-height:220px}

    /* 설정 서랍: 닫힘 상태일 때 클릭 차단 방지 (pointer-events) */
    .drawer{position:fixed; inset:0; display:none; z-index:50; pointer-events:none;}
    .drawer.open{display:block; pointer-events:auto;}
    .drawer .sheet{
      position:absolute; left:0; top:0; bottom:0; width:460px; transform:translateX(0);
      background:linear-gradient(180deg,#0f1624,#0e1522);
      border-right:1px solid #1b2334; padding:16px; overflow:auto
    }
    .drawer .overlay{position:absolute; inset:0; background:rgba(0,0,0,.4)}

    .row{display:grid; grid-template-columns:170px 1fr 90px; gap:10px; align-items:center; margin-bottom:8px}
    .row label{font-weight:600; font-size:13px}
    .row output{font-variant-numeric:tabular-nums; text-align:right; color:var(--accent2)}
    input[type=range], input[type=number], select{width:100%}
    .hint{font-size:12px; color:var(--muted); line-height:1.5}

    .pill{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #2a3650; background:linear-gradient(180deg,#121a2a,#0f1624); font-size:12px}
    .state{display:flex; gap:8px; align-items:center; justify-content:flex-end}
    .state .dot{width:10px; height:10px; border-radius:99px}
    .zone-basic{background:#22c55e} .zone-ovm{background:#f59e0b} .zone-6step{background:#ef4444}
    .muted{color:var(--muted)} .small{font-size:12px}

    .legend-chip{display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; border:1px solid #2b3650; margin:0 6px 6px 0; font-size:12px}
    .sw{width:10px; height:10px; border-radius:2px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="badge"><span>IPMSM Drive Lab</span> <small>v2.7.2</small></div>
      <h1>MTPA→OVM→6-Step 시뮬레이터 (IPMSM)</h1>
    </div>
    <div class="toolbar">
      <button id="btnSettings" class="primary">⚙️ 설정</button>
      <button id="btnCSV">⬇️ CSV 다운로드</button>
      <div class="state small">
        <span class="muted">모드:</span>
        <span id="modePill" class="pill"><b id="modeText">기본</b> <span id="zoneText" class="muted">(선형 영역)</span></span>
        <div class="dot zone-basic" id="zoneDot"></div>
      </div>
    </div>
  </header>

  <div class="main">
    <!-- LEFT: 3D main view -->
    <section class="panel card vehicle3d" id="car3dCard">
      <h4>Vehicle 3D View</h4>
      <div id="hud" style="position:absolute; right:10px; top:10px; background:rgba(0,0,0,.35); border:1px solid #203047; border-radius:10px; padding:6px 8px; font-size:12px; line-height:1.3">
        <div><b>v</b>: <span id="hudV">0</span> m/s · <b>RPM</b>: <span id="hudRPM">0</span></div>
        <div><b>m</b>: <span id="hudM">0</span> · <b>영역</b>: <span id="hudMode">기본</span></div>
        <div><b>v_ref</b>: <span id="hudVref">0</span> m/s</div>
      </div>
      <canvas id="car3d"></canvas>
    </section>

    <!-- RIGHT: charts -->
    <section class="charts">
      <div class="panel card electrical" id="cardVolts">
        <h4>Phase Voltages vs Back-EMF (a상)
          <span class="legend">
            <span class="legend-chip"><span class="sw" style="background:#ef4444"></span>v_a</span>
            <span class="legend-chip"><span class="sw" style="background:#22c55e"></span>v_b</span>
            <span class="legend-chip"><span class="sw" style="background:#3b82f6"></span>v_c</span>
            <span class="legend-chip"><span class="sw" style="background:#9ca3af"></span>e_a</span>
          </span>
        </h4>
        <canvas id="volts"></canvas>
      </div>
      <div class="panel card electrical" id="cardCurrents">
        <h4>Phase Currents & Electromagnetic Torque
          <span class="legend">
            <span class="legend-chip"><span class="sw" style="background:#f97316"></span>T_e</span>
            <span class="legend-chip"><span class="sw" style="background:#ef4444"></span>i_a</span>
            <span class="legend-chip"><span class="sw" style="background:#22c55e"></span>i_b</span>
            <span class="legend-chip"><span class="sw" style="background:#3b82f6"></span>i_c</span>
          </span>
        </h4>
        <canvas id="currents"></canvas>
      </div>
      <div class="panel card electrical" id="cardFFT">
        <h4>Harmonic Spectrum of v<sub>a</sub> (최근 1 전기주기)
          <span class="legend"><span class="legend-chip"><span class="sw" style="background:#60a5fa"></span>Mag [% of 1st]</span></span>
        </h4>
        <canvas id="fft"></canvas>
      </div>
    </section>
  </div>
</div>

<!-- SETTINGS DRAWER -->
<div id="drawer" class="drawer" aria-hidden="true">
  <div class="overlay" id="drawerOverlay"></div>
  <aside class="sheet">
    <h3 style="margin:0 0 12px 0; color:var(--muted)">시뮬레이션 설정</h3>

    <h4 class="muted" style="margin:6px 0 4px 0">제어</h4>
    <div class="row"><label>제어 방식</label>
      <select id="ctrlMode"><option value="manual">수동 (m, 모드 직접)</option><option value="auto">Auto: MTPA→OVM→6-Step</option></select><output></output>
    </div>
    <div class="row"><label>가속 페달</label><input id="throttle" type="range" min="-1" max="1" step="0.01" value="0" /><output id="throttleVal">0%</output></div>
    <div class="row"><label>모듈레이션 m</label><input id="midx" type="range" min="0" max="1.5" step="0.01" value="0.80" /><output id="mVal">0.80</output></div>
    <div class="row"><label>모드</label>
      <select id="modeSel"><option value="basic">기본 (3rd harmonic)</option><option value="ovm">과변조 (OVM)</option><option value="six">6-스텝 (구형파)</option></select>
      <output></output>
    </div>

    <h4 class="muted" style="margin:10px 0 4px 0">주행 사이클러</h4>
    <div class="row"><label>프로파일</label>
      <select id="cycleSel">
        <option value="manual">수동</option>
        <option value="urban">도심(시내)</option>
        <option value="highway">고속</option>
        <option value="stopgo">정지-출발</option>
      </select>
      <output id="cycleInfo">—</output>
    </div>
    <div class="row"><label>속도 배율</label><input id="cycleV" type="range" min="0.6" max="1.5" step="0.05" value="1.00" /><output id="cycleVVal">×1.00</output></div>
    <div class="row"><label>시간 배율</label><input id="cycleT" type="range" min="0.5" max="2.0" step="0.05" value="1.00" /><output id="cycleTVal">×1.00</output></div>
    <div class="row"><label>재생/일시정지</label><button id="btnCyclePlay">⏸ 일시정지</button><output id="cycleTNow">t=0.0s</output></div>

    <h4 class="muted" style="margin:10px 0 4px 0">IPMSM 파라미터</h4>
    <div class="row"><label>R<sub>s</sub> [Ω]</label><input id="rs" type="range" min="0.01" max="0.3" step="0.005" value="0.050" /><output id="rsVal">0.050</output></div>
    <div class="row"><label>L<sub>d</sub> [mH]</label><input id="ld" type="range" min="0.05" max="2.0" step="0.01" value="0.30" /><output id="ldVal">0.30</output></div>
    <div class="row"><label>L<sub>q</sub> [mH]</label><input id="lq" type="range" min="0.05" max="2.0" step="0.01" value="0.60" /><output id="lqVal">0.60</output></div>
    <div class="row"><label>자속 λ<sub>f</sub> [Wb]</label><input id="lambdaF" type="range" min="0.02" max="0.12" step="0.001" value="0.060" /><output id="lfVal">0.060</output></div>
    <div class="row"><label>극쌍수 p</label><input id="pp" type="range" min="1" max="6" step="1" value="3" /><output id="ppVal">3</output></div>

    <h4 class="muted" style="margin:10px 0 4px 0">인버터 / 버스</h4>
    <div class="row"><label>DC 버스 V<sub>dc</sub> [V]</label><input id="vdc" type="range" min="100" max="800" step="10" value="400" /><output id="vdcVal">400V</output></div>

    <h4 class="muted" style="margin:10px 0 4px 0">차량/기구</h4>
    <div class="row"><label>기어비 G</label><input id="gear" type="range" min="2" max="12" step="0.1" value="9.0" /><output id="gearVal">9.0</output></div>
    <div class="row"><label>휠 반경 R<sub>w</sub> [m]</label><input id="wheelR" type="range" min="0.15" max="0.40" step="0.01" value="0.30" /><output id="wheelRVal">0.30</output></div>
    <div class="row"><label>차량 질량 m [kg]</label><input id="mass" type="range" min="800" max="2500" step="10" value="1800" /><output id="massVal">1800</output></div>
    <div class="row"><label>CdA [m²]</label><input id="cda" type="range" min="0.3" max="0.9" step="0.01" value="0.60" /><output id="cdaVal">0.60</output></div>

    <h4 class="muted" style="margin:10px 0 4px 0">오실로스코프 보기</h4>
    <div class="row"><label>시간 창 [s]</label><input id="timeWin" type="range" min="0.1" max="10" step="0.1" value="3.0" /><output id="timeWinVal">3.0s</output></div>
    <div class="row"><label>V 축 자동</label><input id="autoYV" type="checkbox" checked /><output>Auto</output></div>
    <div class="row"><label>V 축 범위 (±V)</label><input id="yv" type="range" min="20" max="600" step="5" value="220" /><output id="yvVal">220</output></div>
    <div class="row"><label>I 축 자동</label><input id="autoYI" type="checkbox" checked /><output>Auto</output></div>
    <div class="row"><label>I 축 범위 (±A)</label><input id="yi" type="range" min="10" max="800" step="10" value="200" /><output id="yiVal">200</output></div>
    <div class="row"><label>토크 축 (±Nm)</label><input id="yT" type="range" min="50" max="600" step="10" value="300" /><output id="yTVal">300</output></div>
    <div class="row"><label>FFT 로그스케일</label><input id="fftLog" type="checkbox" /><output>off</output></div>

    <h4 class="muted" style="margin:10px 0 4px 0">표시 신호 선택</h4>
    <div class="row"><label>전압 파형</label>
      <div>
        <label><input type="checkbox" id="chk_va" checked> v_a</label>
        <label><input type="checkbox" id="chk_vb" checked> v_b</label>
        <label><input type="checkbox" id="chk_vc" checked> v_c</label>
        <label><input type="checkbox" id="chk_ea" checked> e_a</label>
      </div>
      <output></output>
    </div>
    <div class="row"><label>전류/토크</label>
      <div>
        <label><input type="checkbox" id="chk_ia" checked> i_a</label>
        <label><input type="checkbox" id="chk_ib" checked> i_b</label>
        <label><input type="checkbox" id="chk_ic" checked> i_c</label>
        <label><input type="checkbox" id="chk_te" checked> T_e</label>
      </div>
      <output></output>
    </div>

    <h4 class="muted" style="margin:10px 0 4px 0">FFT</h4>
    <div class="row"><label>H 최대차수</label><input id="harmMax" type="range" min="10" max="80" step="1" value="40" /><output id="harmMaxVal">40</output></div>
    <p class="hint">단축키: ←/→ 가속·감속, Space 일시정지/재생, S 정지</p>
    <div id="selfTests" class="hint" style="margin-top:8px"></div>
  </aside>
</div>

<!-- 메인 스크립트: DOM 파싱 후 실행 -->
<script>
(function(){
  // ===== Helpers =====
  const DPR = window.devicePixelRatio || 1;
  const clamp = (x,lo,hi)=> Math.min(Math.max(x,lo),hi);
  const fmt = (x,d=2)=> Number(x).toFixed(d);
  const si  = (n)=>{ n=Number(n); const a=Math.abs(n);
    if(a>=1e9) return (n/1e9).toFixed(2)+'G';
    if(a>=1e6) return (n/1e6).toFixed(2)+'M';
    if(a>=1e3) return (n/1e3).toFixed(2)+'k';
    if(a>=1)   return n.toFixed(2);
    if(a>=1e-3)return (n*1e3).toFixed(2)+'m';
    if(a>=1e-6)return (n*1e6).toFixed(2)+'µ';
    return n.toExponential(2);
  };

  function ready(fn){
    if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', fn); }
    else fn();
  }

  ready(function(){
    // ===== Elements =====
    const els = {
      drawer: document.getElementById('drawer'), drawerOverlay: document.getElementById('drawerOverlay'), btnSettings: document.getElementById('btnSettings'),
      ctrlMode: document.getElementById('ctrlMode'), throttle: document.getElementById('throttle'), throttleVal: document.getElementById('throttleVal'),
      vdc: document.getElementById('vdc'), vdcVal: document.getElementById('vdcVal'),
      pp: document.getElementById('pp'), ppVal: document.getElementById('ppVal'),
      midx: document.getElementById('midx'), mVal: document.getElementById('mVal'), modeSel: document.getElementById('modeSel'),
      rs: document.getElementById('rs'), rsVal: document.getElementById('rsVal'), ld: document.getElementById('ld'), ldVal: document.getElementById('ldVal'),
      lq: document.getElementById('lq'), lqVal: document.getElementById('lqVal'), lambdaF: document.getElementById('lambdaF'), lfVal: document.getElementById('lfVal'),
      gear: document.getElementById('gear'), gearVal: document.getElementById('gearVal'), wheelR: document.getElementById('wheelR'), wheelRVal: document.getElementById('wheelRVal'),
      mass: document.getElementById('mass'), massVal: document.getElementById('massVal'), cda: document.getElementById('cda'), cdaVal: document.getElementById('cdaVal'),
      timeWin: document.getElementById('timeWin'), timeWinVal: document.getElementById('timeWinVal'),
      autoYV: document.getElementById('autoYV'), autoYI: document.getElementById('autoYI'),
      yv: document.getElementById('yv'), yvVal: document.getElementById('yvVal'),
      yi: document.getElementById('yi'), yiVal: document.getElementById('yiVal'),
      yT: document.getElementById('yT'), yTVal: document.getElementById('yTVal'),
      fftLog: document.getElementById('fftLog'), harmMax: document.getElementById('harmMax'), harmMaxVal: document.getElementById('harmMaxVal'),
      chk_va: document.getElementById('chk_va'), chk_vb: document.getElementById('chk_vb'), chk_vc: document.getElementById('chk_vc'), chk_ea: document.getElementById('chk_ea'),
      chk_ia: document.getElementById('chk_ia'), chk_ib: document.getElementById('chk_ib'), chk_ic: document.getElementById('chk_ic'), chk_te: document.getElementById('chk_te'),
      modePill: document.getElementById('modePill'), modeText: document.getElementById('modeText'), zoneText: document.getElementById('zoneText'), zoneDot: document.getElementById('zoneDot'),
      btnCSV: document.getElementById('btnCSV'),
      hudV: document.getElementById('hudV'), hudRPM: document.getElementById('hudRPM'), hudM: document.getElementById('hudM'), hudMode: document.getElementById('hudMode'),
      hudVref: document.getElementById('hudVref'),
      cycleSel: document.getElementById('cycleSel'), cycleInfo: document.getElementById('cycleInfo'),
      cycleV: document.getElementById('cycleV'), cycleVVal: document.getElementById('cycleVVal'),
      cycleT: document.getElementById('cycleT'), cycleTVal: document.getElementById('cycleTVal'),
      btnCyclePlay: document.getElementById('btnCyclePlay'), cycleTNow: document.getElementById('cycleTNow')
    };

    const HAS_CHART = (typeof Chart !== 'undefined');
    const HAS_THREE = (typeof THREE !== 'undefined');

    // 라이브러리가 없어도 UI는 계속 동작 — 안내 배지만 로그
    if(!HAS_CHART || !HAS_THREE){
      console.warn('Some libs missing:', { HAS_CHART, HAS_THREE });
      const tag=document.createElement('div');
      tag.textContent = `⚠ 일부 라이브러리 로드 실패 — Chart:${HAS_CHART?'OK':'X'}, THREE:${HAS_THREE?'OK':'X'}`;
      tag.style.cssText='margin-left:8px;font-size:12px;color:#f59e0b';
      document.querySelector('header .toolbar')?.appendChild(tag);
    }

    // ===== 바인딩 유틸 =====
    function bindRange(range,out,map=(x)=>x){ if(!range||!out) return; const f=()=> out.textContent=map(range.value); range.addEventListener('input',f); f(); }
    function bindY(el,out){ if(!el||!out) return; const f=()=> out.textContent=fmt(el.value,0); el.addEventListener('input',f); f(); }

    bindRange(els.throttle, els.throttleVal, v=> (Math.round(v*100))+'%');
    bindRange(els.vdc, els.vdcVal, v=> fmt(v,0)+'V');
    bindRange(els.pp, els.ppVal, v=> v);
    bindRange(els.midx, els.mVal, v=> fmt(v,2));
    bindRange(els.rs, els.rsVal, v=> fmt(v,3));
    bindRange(els.ld, els.ldVal, v=> fmt(v,2));
    bindRange(els.lq, els.lqVal, v=> fmt(v,2));
    bindRange(els.lambdaF, els.lfVal, v=> fmt(v,3));
    bindRange(els.gear, els.gearVal, v=> fmt(v,1));
    bindRange(els.wheelR, els.wheelRVal, v=> fmt(v,2));
    bindRange(els.mass, els.massVal, v=> fmt(v,0));
    bindRange(els.cycleV, els.cycleVVal, v=> '×'+fmt(v,2));
    bindRange(els.cycleT, els.cycleTVal, v=> '×'+fmt(v,2));
    bindRange(els.timeWin, els.timeWinVal, v=> fmt(v,1)+'s');
    bindY(els.yv,els.yvVal); bindY(els.yi,els.yiVal); bindY(els.yT,els.yTVal);

    // 설정 드로어 토글
    if(els.btnSettings){
      els.btnSettings.addEventListener('click', ()=> { els.drawer.classList.add('open'); els.drawer.setAttribute('aria-hidden','false'); });
    }
    if(els.drawerOverlay){
      els.drawerOverlay.addEventListener('click', ()=> { els.drawer.classList.remove('open'); els.drawer.setAttribute('aria-hidden','true'); });
    }

    // ===== dq 변환 =====
    function clarke(va,vb,vc){ const v_alpha=(2/3)*(va-0.5*vb-0.5*vc); const v_beta=(2/3)*((Math.sqrt(3)/2)*(vb-vc)); return {v_alpha,v_beta}; }
    function parkTransform(va,vb,vc,th){ const {v_alpha,v_beta}=clarke(va,vb,vc); const c=Math.cos(th), s=Math.sin(th); return { v_d:c*v_alpha+s*v_beta, v_q:-s*v_alpha+c*v_beta }; }
    function invPark(id,iq,th){ const c=Math.cos(th), s=Math.sin(th); const i_alpha=c*id - s*iq, i_beta=s*id + c*iq;
      const ia=i_alpha, ib=-0.5*i_alpha + (Math.sqrt(3)/2)*i_beta, ic=-0.5*i_alpha - (Math.sqrt(3)/2)*i_beta; return {ia,ib,ic};
    }

    // ===== 3rd harmonic 정규화 =====
    function maxH3(){
      const f=(x)=> Math.sin(x)+(1/6)*Math.sin(3*x);
      let a=0,b=2*Math.PI; const gr=(Math.sqrt(5)-1)/2; let c=b-gr*(b-a), d=a+gr*(b-a); let fc=f(c), fd=f(d);
      for(let i=0;i<80;i++){ if(fc<fd){ a=c; c=d; fc=fd; d=a+gr*(b-a); fd=f(d);} else { b=d; d=c; fd=fc; c=b-gr*(b-a); fc=f(c);} }
      return Math.max(fc,fd);
    }
    const V3H_MAX = maxH3();

    // ===== 전압 합성 =====
    function synthesizeVoltages(theta,m,Vdc,mode){
      const s1=Math.sin(theta), s2=Math.sin(theta-2*Math.PI/3), s3=Math.sin(theta+2*Math.PI/3);
      let vaN,vbN,vcN; const h=(x)=> Math.sin(x)+(1/6)*Math.sin(3*x);
      if(mode==='six'){ vaN=Math.sign(s1); vbN=Math.sign(s2); vcN=Math.sign(s3); }
      else{
        vaN=(m*h(theta))/V3H_MAX; vbN=(m*h(theta-2*Math.PI/3))/V3H_MAX; vcN=(m*h(theta+2*Math.PI/3))/V3H_MAX;
        if(mode==='ovm'){ const clip=(z)=> Math.max(-1,Math.min(1,z)); vaN=clip(vaN); vbN=clip(vbN); vcN=clip(vcN); }
      }
      const k=Vdc/2; return {va:k*vaN, vb:k*vbN, vc:k*vcN};
    }

    // ===== 차트 =====
    if(HAS_CHART){
      Chart.defaults.color='#c8d3e6'; Chart.defaults.font.size=11; Chart.defaults.animation=false;
    }
    function mkChart(ctx,yLabel,type='line'){
      return new Chart(ctx,{
        type, data:{datasets:[]},
        options:{
          parsing:false, responsive:true, maintainAspectRatio:false,
          interaction:{mode:'index',intersect:false}, layout:{padding:6},
          scales:{
            x:{type:'linear',grid:{color:'rgba(255,255,255,.08)'},ticks:{maxTicksLimit:6, callback:v=>fmt(v,2)+'s'}},
            y:{title:{display:true,text:yLabel},grid:{color:'rgba(255,255,255,.08)'},ticks:{maxTicksLimit:5, callback:v=>si(v)}}
          },
          plugins:{
            legend:{labels:{boxWidth:10,usePointStyle:true}},
            decimation:{enabled:true,algorithm:'lttb'},
            tooltip:{callbacks:{label:(c)=>`${c.dataset.label}: ${si(c.parsed.y)}`}}
          },
          elements:{line:{tension:0,borderWidth:2.2},point:{radius:0}}
        }
      });
    }
    function mkNoopChart(){ return { data:{datasets:[]}, options:{scales:{y:{},y2:{}}}, update:()=>{} }; }

    const COLORS={ va:'#ef4444', vb:'#22c55e', vc:'#3b82f6', ea:'#9ca3af', ia:'#ef4444', ib:'#22c55e', ic:'#3b82f6', te:'#f97316' };
    const chVolts = HAS_CHART ? mkChart(document.getElementById('volts'),'V') : mkNoopChart();
    const chI     = HAS_CHART ? mkChart(document.getElementById('currents'),'A') : mkNoopChart();
    const chFFT   = HAS_CHART ? new Chart(document.getElementById('fft'),{
      type:'bar',
      data:{labels:[],datasets:[{label:'% of 1st',data:[],borderWidth:0,backgroundColor:'rgba(96,165,250,.85)',barThickness:10}]},
      options:{
        parsing:false,responsive:true,maintainAspectRatio:false,
        scales:{
          x:{grid:{color:'rgba(255,255,255,.08)'},ticks:{color:'#9fb6d6',maxTicksLimit:10}},
          y:{grid:{color:'rgba(255,255,255,.08)'},type:'linear',suggestedMin:0,suggestedMax:120,ticks:{maxTicksLimit:6,callback:v=>fmt(v,0)+'%'}}
        },
        plugins:{legend:{display:false},tooltip:{callbacks:{label:(ctx)=>`${ctx.label}차: ${fmt(ctx.parsed.y,1)}%`}}}
    }) : null;

    function ensureDatasets(){
      if(!HAS_CHART) return;
      if(chVolts.data.datasets.length===0){
        chVolts.data.datasets.push(
          {key:'va',label:'v_a',data:[],borderColor:COLORS.va},
          {key:'vb',label:'v_b',data:[],borderColor:COLORS.vb,borderDash:[6,4]},
          {key:'vc',label:'v_c',data:[],borderColor:COLORS.vc,borderDash:[2,3]},
          {key:'ea',label:'e_a (back-EMF)',data:[],borderDash:[5,4],borderColor:COLORS.ea}
        );
      }
      if(chI.data.datasets.length===0){
        chI.data.datasets.push(
          {key:'ia',label:'i_a',data:[],borderColor:COLORS.ia},
          {key:'ib',label:'i_b',data:[],borderColor:COLORS.ib,borderDash:[6,4]},
          {key:'ic',label:'i_c',data:[],borderColor:COLORS.ic,borderDash:[2,3]},
          {key:'te',label:'T_e [Nm]',data:[],yAxisID:'y2',borderDash:[5,2],borderColor:COLORS.te}
        );
        chI.options.scales.y2={position:'right',title:{display:true,text:'Nm'},grid:{drawOnChartArea:false},ticks:{maxTicksLimit:5,callback:v=>si(v)}};
      }
    }
    ensureDatasets();

    function applyYScales(){
      if(els.autoYV.checked){ chVolts.options.scales.y.min=chVolts.options.scales.y.max=undefined; }
      else{ const y=+els.yv.value; chVolts.options.scales.y.min=-y; chVolts.options.scales.y.max=y; }
      if(els.autoYI.checked){ chI.options.scales.y.min=chI.options.scales.y.max=undefined; }
      else{ const y=+els.yi.value; chI.options.scales.y.min=-y; chI.options.scales.y.max=y; }
      chI.options.scales.y2.min=-(+els.yT.value); chI.options.scales.y2.max=(+els.yT.value);
    }
    ['change','input'].forEach(ev=>{
      els.autoYV.addEventListener(ev,applyYScales);
      els.autoYI.addEventListener(ev,applyYScales);
      els.yv.addEventListener(ev,applyYScales);
      els.yi.addEventListener(ev,applyYScales);
      els.yT.addEventListener(ev,applyYScales);
    });
    els.fftLog.addEventListener('change', ()=>{
      if(!HAS_CHART || !chFFT) return;
      chFFT.options.scales.y.type = els.fftLog.checked ? 'logarithmic' : 'linear';
      chFFT.update();
    });
    function applyVisibility(){
      if(!HAS_CHART) return;
      const V={va:els.chk_va.checked, vb:els.chk_vb.checked, vc:els.chk_vc.checked, ea:els.chk_ea.checked};
      const I={ia:els.chk_ia.checked, ib:els.chk_ib.checked, ic:els.chk_ic.checked, te:els.chk_te.checked};
      chVolts.data.datasets.forEach(ds=> ds.hidden=!V[ds.key]);
      chI.data.datasets.forEach(ds=> ds.hidden=!I[ds.key]);
    }
    ['chk_va','chk_vb','chk_vc','chk_ea','chk_ia','chk_ib','chk_ic','chk_te'].forEach(id=> els[id].addEventListener('change',applyVisibility));

    // ===== 시뮬레이션 & 로깅 =====
    let state={ dt:50e-6, substeps:60, t:0, theta:0, id:0, iq:0, timeWindow:3.0, samples:1000, vCycle:[], v:0, rpm:0 };
    let FFT_HARM_MAX=40;
    const log={ t:[], va:[], vb:[], vc:[], ea:[], ia:[], ib:[], ic:[], Te:[], vab:[] };

    // ===== IPMSM & 제어 =====
    function updateModeBadge(mode){
      let zone='선형 영역', txt='기본';
      if(mode==='ovm'){ zone='과변조 (플랫탑)'; txt='과변조'; }
      if(mode==='six'){ zone='6-스텝 (구형파)'; txt='6-스텝'; }
      els.modeText.textContent=txt; els.zoneText.textContent='('+zone+')';
      els.zoneDot.className='dot '+(mode==='basic'?'zone-basic':mode==='ovm'?'zone-ovm':'zone-6step');
      els.hudMode.textContent=txt;
    }
    function mtpa_id(iq,Ld,Lq,lf){ const dL=(Ld-Lq); const term=lf/(2*dL); const inside=Math.max(0,term*term+iq*iq); const id=-term+Math.sqrt(inside); return isFinite(id)?id:0; }
    function torque_of(id,iq,p,lf,Ld,Lq){ return 1.5*p*( lf*iq + (Ld-Lq)*id*iq ); }
    function volt_dq(id,iq,we,Rs,Ld,Lq,lf){ return { vd:-we*Lq*iq + Rs*id, vq: we*(Ld*id + lf) + Rs*iq }; }
    function magnitude(a,b){ return Math.sqrt(a*a+b*b); }
    function required_m_for_v1(V1,Vdc){ return (V1/(Vdc/2))*V3H_MAX; }
    function choose_mode_from_m(m){ if(m<=1.0) return 'basic'; if(m<=1.3) return 'ovm'; return 'six'; }
    function solve_iq_for_torque(Tref,p,lf,Ld,Lq){
      let lo=0, hi=1200; for(let it=0; it<40; it++){ const mid=0.5*(lo+hi); const id=mtpa_id(mid,Ld,Lq,lf); const T=torque_of(id,mid,p,lf,Ld,Lq); if(T<Tref) lo=mid; else hi=mid; }
      const iq=0.5*(lo+hi); return { iq, id: mtpa_id(iq,Ld,Lq,lf) };
    }

    // ===== 주행 사이클러 (v_ref + PI→throttle) =====
    const cycler={ mode:'manual', playing:true, t:0, speedScale:1.0, timeScale:1.0, prof:null, vref:0, integ:0 };
    function makeProfile(points){
      const T=points[points.length-1].t;
      return { length:T, eval(t){
        t=((t%T)+T)%T; let i=0; while(i<points.length-1 && t>points[i+1].t) i++;
        const a=points[i], b=points[i+1]||a; const u=(t-a.t)/Math.max(1e-9,(b.t-a.t)); return a.v+(b.v-a.v)*clamp(u,0,1);
      }};
    }
    const profiles={
      urban: makeProfile([{t:0,v:0},{t:12,v:10.5},{t:22,v:11.0},{t:30,v:6.0},{t:36,v:0},{t:42,v:8.0},{t:50,v:11.0},{t:56,v:4.0},{t:60,v:0}]),
      highway: makeProfile([{t:0,v:0},{t:20,v:20},{t:45,v:25},{t:70,v:28},{t:120,v:30},{t:140,v:22},{t:160,v:30},{t:200,v:28}]),
      stopgo: makeProfile([{t:0,v:0},{t:4,v:6.5},{t:8,v:7.0},{t:12,v:0},{t:16,v:0},{t:20,v:6.5},{t:24,v:7.0},{t:30,v:0}])
    };
    function updateCycleInfo(){ if(cycler.mode==='manual'){ els.cycleInfo.textContent='—'; return; } els.cycleInfo.textContent=`주기 ${fmt(cycler.prof.length*cycler.timeScale,1)}s`; }
    els.cycleSel.addEventListener('change',()=>{
      cycler.mode=els.cycleSel.value;
      if(cycler.mode==='manual'){ cycler.prof=null; }
      else{ cycler.prof=profiles[cycler.mode]; cycler.t=0; cycler.integ=0; }
      if(els.throttle) els.throttle.disabled = cycler.mode!=='manual'; updateCycleInfo();
    });
    els.cycleV.addEventListener('input',()=>{ cycler.speedScale=+els.cycleV.value; updateCycleInfo(); });
    els.cycleT.addEventListener('input',()=>{ cycler.timeScale=+els.cycleT.value; updateCycleInfo(); });
    els.btnCyclePlay.addEventListener('click',()=>{ cycler.playing=!cycler.playing; els.btnCyclePlay.textContent=cycler.playing?'⏸ 일시정지':'▶ 재생'; });

    function speedControllerStep(P,frameDt){
      if(cycler.mode==='manual'){ els.hudVref.textContent=fmt(0,1); return P.throttle; }
      if(!cycler.prof) return P.throttle;
      if(cycler.playing) cycler.t += frameDt / cycler.timeScale;
      const vref=cycler.prof.eval(cycler.t) * cycler.speedScale; cycler.vref=vref; els.hudVref.textContent=fmt(vref,1);
      const kp=0.15, ki=0.25; const e=vref-state.v; cycler.integ=clamp(cycler.integ+e*ki*frameDt,-1,1);
      const u=clamp(kp*e+cycler.integ,-1,1);
      els.throttle.value=u; els.throttle.dispatchEvent(new Event('input'));
      els.cycleTNow.textContent=`t=${fmt(cycler.t,1)}s`;
      return u;
    }

    // ===== 차량 스텝 =====
    function vehicle_step(P,dt){
      const rho=1.2, Crr=0.012, g=9.81, eta=0.95; const Tmax=280;
      const Tref=P.throttle*Tmax;
      const omega_w=state.v/P.Rw; const wm=omega_w*P.G; const we=wm*P.p;
      let mode=P.mode, m=P.m, id=state.id, iq=state.iq;

      if(P.ctrlMode==='auto'){
        const s=Math.sign(Tref)||1;
        const sol=solve_iq_for_torque(Math.abs(Tref),P.p,P.lf,P.Ld,P.Lq); id=sol.id*s; iq=sol.iq*s;
        const {vd,vq}=volt_dq(id,iq,we,P.Rs,P.Ld,P.Lq,P.lf); const V1=magnitude(vd,vq); const mreq=required_m_for_v1(V1,P.Vdc);
        m=Math.min(1.5,mreq); mode=choose_mode_from_m(mreq);
      }

      const {vd,vq}=volt_dq(id,iq,we,P.Rs,P.Ld,P.Lq,P.lf);
      const did=(vd + we*P.Lq*state.iq - P.Rs*state.id)/P.Ld;
      const diq=(vq - we*P.Ld*state.id - we*P.lf - P.Rs*state.iq)/P.Lq;
      state.id+=did*dt; state.iq+=diq*dt;

      const Te=torque_of(state.id,state.iq,P.p,P.lf,P.Ld,P.Lq);
      const Ftrac=(Te*P.G*eta)/P.Rw, Fdrag=0.5*rho*P.CdA*state.v*state.v*Math.sign(state.v), Froll=Crr*P.mveh*g*Math.sign(state.v||1);
      const dv=(Ftrac-Fdrag-Froll)/P.mveh*dt; state.v+=dv; if(Math.abs(state.v)<0.05 && Math.abs(P.throttle)<0.02) state.v=0;
      state.rpm=wm*60/(2*Math.PI);
      return { mode, m, we, Te };
    }

    // ===== 3D =====
    const three={ renderer:null, scene:null, camera:null, wheels:[], road:null, orbit:{az:0.7,el:0.35,dist:9,dragging:false,lastX:0,lastY:0} };
    function makeNoiseHeight(size=128){
      const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); const img=ctx.createImageData(size,size);
      for(let y=0;y<size;y++) for(let x=0;x<size;x++){
        const i=(y*size+x)*4; const n=(Math.sin(x*0.35)+Math.sin(y*0.27)+Math.sin((x+y)*0.19)+Math.random()*0.3)/3.5;
        const g=Math.floor(130+60*n); img.data[i]=img.data[i+1]=img.data[i+2]=g; img.data[i+3]=255;
      }
      ctx.putImageData(img,0,0); return c;
    }
    function heightToNormalTex(heightCanvas){
      const w=heightCanvas.width,h=heightCanvas.height; const ctx=heightCanvas.getContext('2d'); const data=ctx.getImageData(0,0,w,h).data;
      const out=document.createElement('canvas'); out.width=w; out.height=h; const octx=out.getContext('2d'); const img=octx.createImageData(w,h);
      const s=1/255, scale=2.5;
      function H(x,y){ x=(x+w)%w; y=(y+h)%h; return data[(y*w+x)*4]*s; }
      for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const dx=(H(x+1,y)-H(x-1,y))*scale, dy=(H(x,y+1)-H(x,y-1))*scale;
        const nx=-dx, ny=-dy, nz=1.0; const l=1/Math.sqrt(nx*nx+ny*ny+nz*nz);
        const r=((nx*l)*0.5+0.5)*255, g=((ny*l)*0.5+0.5)*255, b=((nz*l)*0.5+0.5)*255; const i=(y*w+x)*4;
        img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255;
      }
      octx.putImageData(img,0,0);
      const tex=new THREE.CanvasTexture(out); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(20,80); return tex;
    }
    function makeProceduralEnvMap(renderer){
      const rt=new THREE.WebGLCubeRenderTarget(256,{generateMipmaps:true,minFilter:THREE.LinearMipmapLinearFilter,encoding:THREE.sRGBEncoding});
      const scene=new THREE.Scene(); const cam=new THREE.CubeCamera(0.1,100,rt);
      const floor=new THREE.Mesh(new THREE.PlaneGeometry(20,20),new THREE.MeshStandardMaterial({color:0x20242c,roughness:0.9})); floor.rotation.x=-Math.PI/2; scene.add(floor);
      const p1=new THREE.Mesh(new THREE.PlaneGeometry(6,6),new THREE.MeshBasicMaterial({color:0xffffff})); p1.position.set(-4,3,-4); scene.add(p1);
      const p2=new THREE.Mesh(new THREE.PlaneGeometry(6,6),new THREE.MeshBasicMaterial({color:0xbcdfff})); p2.position.set(4,3,4); scene.add(p2);
      const s=new THREE.Mesh(new THREE.SphereGeometry(2,32,16),new THREE.MeshBasicMaterial({color:0x6aa2ff})); s.position.set(0,2,0); scene.add(s);
      cam.update(renderer,scene);
      const pmrem=new THREE.PMREMGenerator(renderer); pmrem.compileCubemapShader();
      const envTex=pmrem.fromCubemap(rt.texture).texture; pmrem.dispose(); rt.dispose();
      return envTex;
    }
    function init3D(){
      if(!HAS_THREE) return;
      const canvas=document.getElementById('car3d'); if(!canvas) return;
      let r;
      try{
        r=new THREE.WebGLRenderer({canvas,antialias:true,alpha:true});
      }catch(e){
        console.error('WebGL 초기화 실패', e);
        return;
      }
      three.renderer=r; r.setPixelRatio(DPR);
      r.shadowMap.enabled=true; r.shadowMap.type=THREE.PCFSoftShadowMap; r.outputEncoding=THREE.sRGBEncoding;
      r.toneMapping=THREE.ACESFilmicToneMapping; r.toneMappingExposure=1.08;
      const scene=new THREE.Scene(); three.scene=scene; scene.fog=new THREE.Fog(0x0b0f14,18,46);
      const cam=new THREE.PerspectiveCamera(55,1,0.1,1000); three.camera=cam; updateCamera();
      const env=makeProceduralEnvMap(r); scene.environment=env;
      const sky=new THREE.Mesh(new THREE.SphereGeometry(300,32,16), new THREE.ShaderMaterial({
        uniforms:{ top:{value:new THREE.Color(0x0b1b2b)}, bottom:{value:new THREE.Color(0x090d12)} },
        vertexShader:`varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
        fragmentShader:`varying vec3 vPos; uniform vec3 top; uniform vec3 bottom; void main(){ float h=normalize(vPos).y*0.5+0.5; vec3 col=mix(bottom,top,pow(h,1.6)); gl_FragColor=vec4(col,1.0);} `,
        side:THREE.BackSide, depthWrite:false
      })); scene.add(sky);
      const hemi=new THREE.HemisphereLight(0xa0d8ff,0x0b0f14,0.7); scene.add(hemi);
      const dir=new THREE.DirectionalLight(0xffffff,1.2); dir.position.set(8,12,6); dir.castShadow=true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);
      const road=new THREE.Group(); three.road=road; scene.add(road);
      const htex=heightToNormalTex(makeNoiseHeight(128));
      const plane=new THREE.Mesh(new THREE.PlaneGeometry(100,400), new THREE.MeshStandardMaterial({color:0x0f1520,roughness:0.95,metalness:0.0,normalMap:htex,normalScale:new THREE.Vector2(0.6,0.6)}));
      plane.rotation.x=-Math.PI/2; plane.position.z=-40; plane.receiveShadow=true; road.add(plane);
      const guardMat=new THREE.MeshStandardMaterial({color:0x1b2738, metalness:0.3, roughness:0.6});
      const guardGeo=new THREE.BoxGeometry(0.1,0.4,8);
      for(let i=0;i<40;i++){
        const a=new THREE.Mesh(guardGeo,guardMat); a.position.set(-1.6,0.25,i*10-180); a.castShadow=true; road.add(a);
        const b=a.clone(); b.position.x=1.6; road.add(b);
      }
      const city=new THREE.Group();
      for(let i=0;i<40;i++){
        const bx=new THREE.Mesh(new THREE.BoxGeometry(0.8+Math.random()*1.2, 1+Math.random()*2.5, 0.8+Math.random()*1.2),
          new THREE.MeshStandardMaterial({color:0x263446, metalness:0.5, roughness:0.4, envMapIntensity:0.6}));
        bx.position.set((Math.random()<0.5?-1:1)*(3.5+Math.random()*6), bx.geometry.parameters.height/2, Math.random()*-240);
        bx.castShadow=true; city.add(bx);
      }
      scene.add(city);
      const car=new THREE.Group(); scene.add(car);
      const body=new THREE.Mesh(new THREE.BoxGeometry(1.8,0.5,4.0), new THREE.MeshPhysicalMaterial({color:0x273650, envMapIntensity:1.2, metalness:0.5, roughness:0.25, clearcoat:0.8, clearcoatRoughness:0.18}));
      body.position.y=0.55; body.castShadow=true; body.receiveShadow=true; car.add(body);
      const glass=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.36,1.4), new THREE.MeshPhysicalMaterial({color:0x8fd3ff, transparent:true, opacity:0.22, roughness:0.05, metalness:0, transmission:0.7, ior:1.45, thickness:0.02, envMapIntensity:1.4}));
      glass.position.set(0,0.86,0.2); car.add(glass);
      const wheelGeo=new THREE.CylinderGeometry(0.35,0.35,0.24,64,1,true);
      const tireMat=new THREE.MeshStandardMaterial({color:0x0d121c, metalness:0.1, roughness:0.85, envMapIntensity:0.3});
      function mkWheel(x,z){
        const w=new THREE.Mesh(wheelGeo,tireMat); w.rotation.z=Math.PI/2; w.position.set(x,0.35,z); w.castShadow=true; w.receiveShadow=true; car.add(w); three.wheels.push(w);
        const rim=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.26,32), new THREE.MeshStandardMaterial({color:0xbcdfff, metalness:0.9, roughness:0.2, envMapIntensity:1.0}));
        rim.rotation.z=Math.PI/2; rim.position.set(x,0.35,z); rim.castShadow=true; car.add(rim);
      }
      mkWheel(-0.8,-1.3); mkWheel(0.8,-1.3); mkWheel(-0.8,1.3); mkWheel(0.8,1.3);

      const card=document.getElementById('car3dCard');
      card.addEventListener('mousedown',e=>{ three.orbit.dragging=true; three.orbit.lastX=e.clientX; three.orbit.lastY=e.clientY; });
      window.addEventListener('mouseup',()=> three.orbit.dragging=false);
      window.addEventListener('mousemove',(e)=>{
        if(!three.orbit.dragging) return;
        const dx=(e.clientX-three.orbit.lastX)/180, dy=(e.clientY-three.orbit.lastY)/180;
        three.orbit.az+=dx; three.orbit.el=clamp(three.orbit.el+dy,0.05,1.2);
        three.orbit.lastX=e.clientX; three.orbit.lastY=e.clientY; updateCamera();
      });
      card.addEventListener('wheel',(e)=>{ three.orbit.dist=clamp(three.orbit.dist+(e.deltaY>0?0.5:-0.5),5,16); updateCamera(); });
      resize3D();
    }
    function updateCamera(){
      if(!three.camera) return; const o=three.orbit;
      const x=o.dist*Math.sin(o.az)*Math.cos(o.el), y=o.dist*Math.sin(o.el), z=o.dist*Math.cos(o.az)*Math.cos(o.el);
      three.camera.position.set(x,y,z); three.camera.lookAt(0,0.55,0);
    }
    function resize3D(){
      const canvas=document.getElementById('car3d'); if(!canvas||!three.renderer||!three.camera) return;
      const r=canvas.getBoundingClientRect(); const w=r.width*DPR, h=r.height*DPR;
      three.renderer.setSize(w/DPR,h/DPR,false); three.camera.aspect=(w/h)||1; three.camera.updateProjectionMatrix();
    }
    function animate3D(P,dt){
      if(!HAS_THREE || !three.renderer||!three.scene) return;
      const omega_w = state.v / P.Rw;
      three.wheels.forEach(w=>{ w.rotation.x -= omega_w*dt; });
      if(three.road){
        three.road.children.forEach(obj=>{
          if(obj.geometry && obj.geometry.type==='BoxGeometry'){ obj.position.z += state.v*dt*6; if(obj.position.z>20) obj.position.z-=400; }
        });
      }
      three.renderer.render(three.scene,three.camera);
    }
    window.addEventListener('resize',resize3D);

    // ===== Plot & FFT =====
    function pushPlot(ch,arr){
      if(!HAS_CHART) return;
      const maxN=state.samples, t=state.t;
      for(let i=0;i<arr.length;i++){
        const ds=ch.data.datasets[i]; if(!ds) continue;
        ds.data.push({x:t,y:arr[i]});
        while(ds.data.length>maxN) ds.data.shift();
      }
    }
    function updateFFT(cycle){
      if(!HAS_CHART || !chFFT) return;
      const H=FFT_HARM_MAX, N=cycle.length; if(N<96) return;
      function binMag(k){ let re=0,im=0; for(let n=0;n<N;n++){ const ang=-2*Math.PI*k*n/N; const x=cycle[n]; re+=x*Math.cos(ang); im+=x*Math.sin(ang);} return Math.sqrt(re*re+im*im)*2/N; }
      const a1=binMag(1)||1e-9; const mags=[]; for(let k=1;k<=H;k++) mags.push(binMag(k)/a1*100);
      chFFT.data.labels=Array.from({length:H},(_,i)=>String(i+1)); chFFT.data.datasets[0].data=mags;
    }

    // ===== CSV =====
    function csvString(){
      const cols=['t','va','vb','vc','ea','ia','ib','ic','Te','vab']; const N=log.t.length; const lines=[cols.join(',')];
      for(let i=0;i<N;i++){
        lines.push([log.t[i],log.va[i],log.vb[i],log.vc[i],log.ea[i],log.ia[i],log.ib[i],log.ic[i],log.Te[i],log.vab[i]]
          .map(x=> typeof x==='number'?x.toFixed(5):x).join(','));
      }
      return lines.join('\n');
    }
    if(els.btnCSV){
      els.btnCSV.addEventListener('click',()=>{
        const blob=new Blob([csvString()],{type:'text/csv'});
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download='ipmsm_sim.csv'; document.body.appendChild(a); a.click();
        setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
      });
    }

    // ===== 메인 루프 =====
    function stepOnce(){
      const P={
        Vdc:+els.vdc.value, p:+els.pp.value, Rs:+els.rs.value,
        Ld:+els.ld.value/1000, Lq:+els.lq.value/1000, lf:+els.lambdaF.value,
        G:+els.gear.value, Rw:+els.wheelR.value, mveh:+els.mass.value, CdA:+els.cda.value,
        throttle:+els.throttle.value, ctrlMode:els.ctrlMode.value, mode:els.modeSel.value, m:+els.midx.value
      };

      // 사이클러 → throttle
      P.throttle = speedControllerStep(P, state.dt*state.substeps);

      const frameDt=state.dt*state.substeps;
      let mode=P.mode, m=P.m, we=0, Te=0;

      for(let k=0;k<state.substeps;k++){
        const res = (P.ctrlMode==='auto') ? vehicle_step(P,state.dt)
                   : (function(){
                        const rpm=state.rpm||3000; we=(rpm*2*Math.PI/60)*P.p; return {mode:P.mode,m:P.m,we,Te:torque_of(state.id,state.iq,P.p,P.lf,P.Ld,P.Lq)};
                      })();
        mode=res.mode; m=res.m; we=res.we; Te=res.Te;

        state.theta+=we*state.dt; if(state.theta>=2*Math.PI) state.theta-=2*Math.PI;

        const {va,vb,vc}=synthesizeVoltages(state.theta,m,P.Vdc,mode);
        const ea=we*P.lf*Math.sin(state.theta);

        if(P.ctrlMode!=='auto'){
          const {vd,vq}=volt_dq(state.id,state.iq,we,P.Rs,P.Ld,P.Lq,P.lf);
          const did=(vd + we*P.Lq*state.iq - P.Rs*state.id)/P.Ld;
          const diq=(vq - we*P.Ld*state.id - we*P.lf - P.Rs*state.iq)/P.Lq;
          state.id+=did*state.dt; state.iq+=diq*state.dt;
          Te=torque_of(state.id,state.iq,P.p,P.lf,P.Ld,P.Lq);
        }

        state.vCycle.push(va); if(state.vCycle.length>4096) state.vCycle.shift();

        if(k===state.substeps-1){
          const {ia,ib,ic}=invPark(state.id,state.iq,state.theta);
          pushPlot(chVolts,[va,vb,vc,ea]); pushPlot(chI,[ia,ib,ic,Te]);
          log.t.push(state.t); log.va.push(va); log.vb.push(vb); log.vc.push(vc); log.ea.push(ea);
          log.ia.push(ia); log.ib.push(ib); log.ic.push(ic); log.Te.push(Te); log.vab.push(va-vb);
        }
        if(state.theta<1e-6){ updateFFT(state.vCycle.slice()); state.vCycle.length=0; }
      }

      state.t+=frameDt; updateModeBadge(mode); animate3D(P,frameDt);
      els.hudV.textContent=fmt(state.v,2); els.hudRPM.textContent=fmt(state.rpm,0); els.hudM.textContent=fmt(P.m,2);
    }

    let running=true;
    function loop(){
      stepOnce();
      state.timeWindow=+els.timeWin.value;
      const frameDt=state.dt*state.substeps; state.samples=Math.max(60,Math.floor(state.timeWindow/frameDt));
      applyYScales(); applyVisibility();
      if(HAS_CHART){ chVolts.update(); chI.update(); if(chFFT) chFFT.update(); }
      if(running) requestAnimationFrame(loop);
    }

    window.addEventListener('keydown',e=>{
      if(e.key===' '){ running=!running; if(running) requestAnimationFrame(loop); }
      if(e.key==='ArrowRight'){ els.throttle.value=Math.min(1,+els.throttle.value+0.05); els.throttle.dispatchEvent(new Event('input')); }
      if(e.key==='ArrowLeft'){  els.throttle.value=Math.max(-1,+els.throttle.value-0.05); els.throttle.dispatchEvent(new Event('input')); }
      if(e.key.toLowerCase()==='s'){ els.throttle.value=0; els.throttle.dispatchEvent(new Event('input')); state.v=0; }
    });
    els.harmMax.addEventListener('input',()=>{ FFT_HARM_MAX=+els.harmMax.value; });
    els.fftLog.addEventListener('change', ()=> { if(HAS_CHART && chFFT) chFFT.update(); });

    // ===== Self-tests 결과 표시 =====
    (function runTests(){
      const T=[]; const okpush=(ok,name,msg='')=>T.push({ok,name,msg});
      let mx=-1e9; for(let i=0;i<=20000;i++){ const x=i*(2*Math.PI/20000); const v=Math.sin(x)+(1/6)*Math.sin(3*x); if(v>mx) mx=v; }
      okpush(Math.abs(mx-1.1547005)<1e-3,'V3H_MAX check',`found=${mx.toFixed(6)}`);
      const z=synthesizeVoltages(1.234,0.0,400,'basic'); okpush(Math.abs(z.va)<1e-9&&Math.abs(z.vb)<1e-9&&Math.abs(z.vc)<1e-9,'m=0 → zero volts');
      const six=synthesizeVoltages(Math.PI/2,0.8,400,'six'); okpush(Math.abs(six.va-200)<1e-9 && Math.abs(six.vb+200)<1e-9 && Math.abs(six.vc+200)<1e-9,'6-step signs π/2');
      (function(){ const th=1.2,id=3.2,iq=-1.7; const abc=invPark(id,iq,th); const dq=parkTransform(abc.ia,abc.ib,abc.ic,th);
        okpush(Math.abs(dq.v_d-id)<1e-6 && Math.abs(dq.v_q-iq)<1e-6,'Park↔InvPark'); })();
      const ov=synthesizeVoltages(0.7,1.4,400,'ovm'); const within=Math.max(Math.abs(ov.va),Math.abs(ov.vb),Math.abs(ov.vc))<=200+1e-9; okpush(within,'OVM clip ±Vdc/2');
      okpush(si(1234)==='1.23k','SI 1.23k');
      if(HAS_CHART){
        (function(){ const N=256,cyc=[]; for(let n=0;n<N;n++) cyc.push(Math.sign(Math.sin(2*Math.PI*n/N))); updateFFT(cyc);
          const nz=(chFFT && chFFT.data.datasets[0].data.some(x=>x>0.1)); okpush(nz,'FFT non-zero'); })();
      }
      const ok=T.every(t=>t.ok);
      const div=document.getElementById('selfTests'); if(div){
        div.innerHTML=(ok?'✅ Self-tests PASS':'⚠️ Self-tests FAIL')+' · '+T.map(t=>`${t.ok?'✔':'✖'} ${t.name}${t.msg?('('+t.msg+')'):''}`).join(' | ');
      }
      console.group('Self-tests'); T.forEach(t=> console[t.ok?'log':'error'](`${t.ok?'PASS':'FAIL'} — ${t.name} ${t.msg||''}`)); console.groupEnd();
    })();

    // ===== Boot =====
    requestAnimationFrame(()=>{ if(HAS_THREE) init3D(); applyYScales(); applyVisibility(); loop(); });
    console.log('%cIPMSM Drive Lab','padding:6px 10px; background:#124a63; color:#e8eef9; border-radius:6px;',
      ['MTPA→OVM→6-Step 자동전환 / 수동 모드 지원','오실로스코프: 축 Auto/수동, 신호 토글, FFT 로그 스케일','3D: 환경맵 + 소프트 섀도우 + 스카이돔',].join('\n')
    );
  }); // ready
})();
</script>
</body>
</html>
