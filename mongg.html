<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EV Free Drive — IPMSM + 7-DOF Vehicle (ABS/TCS, Regen Blend, Combined-Slip Tire)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111826; --muted:#7d8aa3; --text:#e8eef9;
      --accent:#4cc9f0; --accent2:#a0e9ff; --shadow:0 10px 30px rgba(0,0,0,.35); --radius:18px
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:radial-gradient(1200px 800px at 80% -10%,#1a2330 0%,#0b0f14 55%);
      color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Apple SD Gothic Neo,Noto Sans KR,Arial
    }
    header{
      display:flex;align-items:center;justify-content:space-between;padding:10px 14px;position:sticky;top:0;
      backdrop-filter:blur(6px);z-index:50;border-bottom:1px solid rgba(255,255,255,.06);
      background:linear-gradient(180deg,rgba(8,11,17,.86),rgba(8,11,17,.45))
    }
    header .left{display:flex;align-items:center;gap:10px}
    header h1{font-size:16px;margin:0;font-weight:800}
    header .sub{color:#9fb3cc;font-size:11px}
    .btnbar{display:flex;gap:6px;flex-wrap:wrap}
    .btn{
      background:linear-gradient(180deg,#1e2635,#141b27);border:1px solid rgba(255,255,255,.12);
      color:#e8f3ff;padding:8px 10px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:var(--shadow);font-size:12px
    }
    .btn.accent{background:linear-gradient(180deg,#34d5ff,#1aaadb);color:#06283b;border-color:rgba(76,201,240,.6)}
    .btn.warn{background:linear-gradient(180deg,#ffd76a,#f3b740);color:#2a1d00}
    .drawer{display:none}
    .drawer.open{display:block}
    .card{
      background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);box-shadow:var(--shadow);margin:8px 14px
    }
    .card h2{
      font-size:12px;letter-spacing:.35px;text-transform:uppercase;color:var(--accent2);
      margin:0;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.06)
    }
    .tabs{display:grid;grid-template-columns: repeat(5,1fr);gap:6px;padding:8px}
    .tab{cursor:pointer;text-align:center;padding:8px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0f1522;font-size:12px}
    .tab.active{background:linear-gradient(180deg,#34d5ff,#1aaadb);color:#052531;border-color:rgba(76,201,240,.6);font-weight:800}
    .panel{display:none;padding:10px 12px 12px}
    .panel.active{display:block}
    .group{border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px;margin-bottom:10px;background:rgba(255,255,255,.02)}
    .group-title{color:#b9d7ff;font-weight:800;font-size:11px;text-transform:uppercase;letter-spacing:.35px;margin-bottom:8px}
    .row{display:grid;grid-template-columns: 1fr auto;gap:8px;align-items:center;margin:6px 0}
    input[type=number],select{width:120px;background:#0d1320;color:var(--text);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:6px 8px;font-size:12px}
    input[type=range]{width:100%}

    /* ===== Layout tuned ===== */
    .app{display:grid;grid-template-columns: 1fr 520px;gap:10px;padding:8px 14px}
    #three-wrap{height:clamp(460px, 58vh, 720px);border-radius:18px;overflow:hidden;outline:none}
    .telemetry{display:grid;grid-template-columns: repeat(auto-fit, minmax(120px,1fr));gap:6px;padding:6px 0}
    .tile{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:8px 10px}
    .tile .k{font-size:10px;color:#9fd3ff;text-transform:uppercase;letter-spacing:.35px}
    .tile .v{font-size:16px;font-weight:800;margin-top:2px}
    .sidebar{display:flex;flex-direction:column;gap:10px;min-height:0}
    canvas.chart{width:100%;height:130px}

    /* phasor: move to top-right under tiles */
    .phasor-top{display:flex;justify-content:flex-end;margin:4px 0 8px}
    #phasor{width:320px;height:160px;background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.08);border-radius:14px}

    @media (max-width: 1200px){ .app{grid-template-columns:1fr} }
    footer{color:#7d8aa3;font-size:11px;text-align:center;padding:8px}
    .flag{font-size:11px;font-weight:800;padding:2px 6px;border-radius:10px;border:1px solid rgba(255,255,255,.15);display:inline-block}
  </style>

  <!-- Import Map (CDN) -->
  <script type="importmap">
  { "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <header>
    <div class="left">
      <button id="btnControls" class="btn">☰ Controls</button>
      <h1>EV Free Drive — IPMSM + 7DOF Vehicle</h1>
      <span class="sub">W/↑ 가속 · S/↓ 브레이크 · A/D 좌우 · Space 일시정지/재개 · 🎮 RT/LT/LS-X</span>
    </div>
    <div class="btnbar">
      <button id="btnStart" class="btn accent">▶ 시작</button>
      <button id="btnPause" class="btn">⏸ 일시정지</button>
      <button id="btnReset" class="btn warn">↺ 초기화</button>
      <button id="btnCsv" class="btn">⤓ CSV</button>
      <button id="btnFollow" class="btn">🎥 Follow: ON</button>
      <button id="btnStep80" class="btn">⏱ 속도스텝 0→80</button>
    </div>
  </header>

  <!-- Controls -->
  <section id="controlsDrawer" class="card drawer" aria-hidden="true">
    <h2>Controls</h2>
    <div class="tabs">
      <div class="tab active" data-tab="drive">Drive</div>
      <div class="tab" data-tab="vehicle">Vehicle</div>
      <div class="tab" data-tab="tire">Tire/ABS/TCS</div>
      <div class="tab" data-tab="motor">Motor/Inverter</div>
      <div class="tab" data-tab="help">Help</div>
    </div>

    <div class="panel active" id="panel-drive">
      <div class="group">
        <div class="group-title">주행 모드</div>
        <div class="row">
          <label>모드</label>
          <select id="mode">
            <option value="pedal">Pedal (스로틀/브레이크)</option>
            <option value="cruise" selected>Cruise (목표속도)</option>
          </select>
        </div>
        <div id="cruiseBox">
          <div class="row"><label>목표 속도 (km/h)</label><input id="targetKmh" type="number" value="80" step="1"></div>
          <div class="row"><label>속도 PI Kp/Ki</label>
            <span><input id="Kps" type="number" value="6" step="0.5" style="width:70px"> / <input id="Kis" type="number" value="2" step="0.2" style="width:70px"></span>
          </div>
          <div class="row"><label>속도 타임콘스턴트 τv(s)</label><input id="taus" type="number" value="0.8" step="0.1"></div>
        </div>
        <div id="pedalBox" style="display:none">
          <div class="row"><label>스로틀 (%)</label><input id="throttle" type="range" min="0" max="100" value="0"></div>
          <div class="row"><label>브레이크 (%)</label><input id="brake" type="range" min="0" max="100" value="0"></div>
          <div class="row"><label>조향 (°)</label><input id="steer" type="range" min="-30" max="30" value="0"></div>
          <div class="row"><label>키 반응(%/s)</label>
            <select id="keyRate"><option value="50">느림</option><option value="100" selected>보통</option><option value="180">빠름</option></select>
          </div>
        </div>
        <div class="btnbar" style="margin-top:8px">
          <button id="btnDisturb" class="btn">⚡ 부하시험(+300Nm, 2s)</button>
          <span class="flag" id="flagABS">ABS: OFF</span>
          <span class="flag" id="flagTCS">TCS: OFF</span>
        </div>
      </div>
    </div>

    <div class="panel" id="panel-vehicle">
      <div class="group"><div class="group-title">차량/차축/휠</div>
        <div class="row"><label>질량 m (kg)</label><input id="mass" type="number" value="1600" step="10"></div>
        <div class="row"><label>Yaw 관성 Iz (kg·m²)</label><input id="Iz" type="number" value="2500" step="50"></div>
        <div class="row"><label>Lf / Lr (m)</label><span><input id="Lf" type="number" value="1.35" step="0.05" style="width:90px"> / <input id="Lr" type="number" value="1.35" step="0.05" style="width:90px"></span></div>
        <div class="row"><label>트랙폭 (m)</label><input id="track" type="number" value="1.58" step="0.02"></div>
        <div class="row"><label>무게중심 높이 h<sub>cg</sub> (m)</label><input id="hcg" type="number" value="0.55" step="0.02"></div>
        <div class="row"><label>휠 반지름 Rw (m)</label><input id="Rw" type="number" value="0.31" step="0.01"></div>
        <div class="row"><label>휠 관성 Jw (kg·m²)</label><input id="Jw" type="number" value="1.2" step="0.1"></div>
        <div class="row"><label>기어비 G / 효율 η</label><span><input id="gear" type="number" value="9.0" step="0.1" style="width:90px"> / <input id="eta" type="number" value="0.95" step="0.01" style="width:90px"></span></div>
        <div class="row"><label>CdA / c<sub>r</sub></label><span><input id="CdA" type="number" value="0.70" step="0.05" style="width:90px"> / <input id="cr" type="number" value="0.012" step="0.002" style="width:90px"></span></div>
        <div class="row"><label>공기밀도 ρ (kg/m³)</label><input id="rho" type="number" value="1.225" step="0.01"></div>
        <div class="row"><label>등판(°)</label><input id="gradeDeg" type="number" value="0" step="0.5"></div>
      </div>
    </div>

    <div class="panel" id="panel-tire">
      <div class="group"><div class="group-title">타이어/노면 (결합 슬립 Pacejka 간이형)</div>
        <div class="row"><label>마찰계수 μ</label><input id="mu" type="number" value="1.0" step="0.05"></div>
        <div class="row"><label>Bκ/Cκ/Dκ/Eκ</label><span><input id="Bk" type="number" value="10.0" step="0.5" style="width:80px"> / <input id="Ck" type="number" value="1.9" step="0.1" style="width:80px"> / <input id="Dk" type="number" value="1.0" step="0.1" style="width:80px"> / <input id="Ek" type="number" value="0.97" step="0.01" style="width:80px"></span></div>
        <div class="row"><label>By/Cy/Dy/Ey</label><span><input id="By" type="number" value="5.0" step="0.3" style="width:80px"> / <input id="Cy" type="number" value="1.3" step="0.1" style="width:80px"> / <input id="Dy" type="number" value="1.0" step="0.1" style="width:80px"> / <input id="Ey" type="number" value="0.97" step="0.01" style="width:80px"></span></div>
      </div>
      <div class="group"><div class="group-title">ABS / TCS / 브레이크</div>
        <div class="row"><label>ABS</label><select id="absOn"><option value="1" selected>ON</option><option value="0">OFF</option></select></div>
        <div class="row"><label>TCS</label><select id="tcsOn"><option value="1" selected>ON</option><option value="0">OFF</option></select></div>
        <div class="row"><label>ABS κ<sub>target</sub></label><input id="kappaAbs" type="number" value="0.20" step="0.02"></div>
        <div class="row"><label>TCS κ<sub>target</sub></label><input id="kappaTcs" type="number" value="0.10" step="0.02"></div>
        <div class="row"><label>브레이크 바이어스 Front</label><input id="brkBiasF" type="number" value="0.62" step="0.02"></div>
        <div class="row"><label>최대 마찰브레이크 토크/휠 (Nm)</label><input id="TbrkMax" type="number" value="4000" step="100"></div>
      </div>
    </div>

    <div class="panel" id="panel-motor">
      <div class="group">
        <div class="group-title">인버터/전원</div>
        <div class="row"><label>Vdc (V)</label><input id="Vdc" type="number" value="400" step="10"></div>
        <div class="row"><label>전류 제한 Imax (A)</label><input id="Imax" type="number" value="600" step="10"></div>
        <div class="row"><label>제어 모드</label>
          <select id="ctrlMode">
            <option value="auto" selected>Auto (FOC→Overmod→6-Step)</option>
            <option value="foc">FOC (SVPWM만)</option>
            <option value="six">강제 6-Step</option>
          </select>
        </div>
        <div class="row"><label>MTPA</label>
          <select id="mtpaOn"><option value="1" selected>ON</option><option value="0">OFF (Id=0)</option></select>
        </div>
        <div class="row"><label>Flux Weakening 게인</label><input id="Kfw" type="number" value="1200" step="50"></div>
        <div class="row"><label>PWM fsw (kHz)</label><input id="fswKhz" type="number" value="10" step="1"></div>
        <div class="row"><label>Deadtime</label><select id="deadOn"><option value="1" selected>ON</option><option value="0">OFF</option></select></div>
        <div class="row"><label>Td (µs)</label><input id="deadUs" type="number" value="1.0" step="0.1"></div>
      </div>
      <div class="group"><div class="group-title">IPMSM 파라미터</div>
        <div class="row"><label>극쌍수 p</label><input id="pp" type="number" value="4" step="1"></div>
        <div class="row"><label>Rs (Ω)</label><input id="Rs" type="number" value="0.05" step="0.005"></div>
        <div class="row"><label>Ld/Lq (H)</label>
          <span><input id="Ld" type="number" value="0.00025" step="0.00005" style="width:90px"> / <input id="Lq" type="number" value="0.00050" step="0.00005" style="width:90px"></span>
        </div>
        <div class="row"><label>자속 ψf (Wb)</label><input id="psif" type="number" value="0.06" step="0.005"></div>
        <div class="row"><label>관성 J (kg·m²)</label><input id="J" type="number" value="0.35" step="0.05"></div>
        <div class="row"><label>점성 B (Nms)</label><input id="B" type="number" value="0.02" step="0.01"></div>
      </div>
      <div class="group"><div class="group-title">회생제동 한계</div>
        <div class="row"><label>I<sub>regen</sub> (A)</label><input id="Iregen" type="number" value="400" step="10"></div>
        <div class="row"><label>P<sub>regen</sub> (kW)</label><input id="Pregen" type="number" value="120" step="5"></div>
      </div>
      <div class="group"><div class="group-title">응답 튠</div>
        <div class="row"><label>I Slew (A/s)</label><input id="Islew" type="number" value="5500" step="500"></div>
        <div class="row"><label>토크 지연 τ (ms)</label><input id="tauTqMs" type="number" value="60" step="10"></div>
      </div>
    </div>

    <div class="panel" id="panel-help">
      <div class="group"><div class="group-title">도움</div>
        <div>이 버전은 7-DOF(차체 3자유도 + 4휠 회전), 결합 슬립 타이어, ABS/TCS, 회생제동 블렌딩과 함께,</div>
        <div><b>입력 LPF/슬루 제한</b>, <b>전류 Slew/토크 지연</b>, <b>속도연동 FOV + 스프링 카메라</b>, <b>Gamepad</b>가 적용됐습니다.</div>
      </div>
    </div>
  </section>

  <main class="app">
    <section class="card" style="padding:8px">
      <div class="telemetry">
        <div class="tile"><div class="k">속도</div><div class="v" id="v_kmh">0.0 km/h</div></div>
        <div class="tile"><div class="k">모터 rpm</div><div class="v" id="rpm">0</div></div>
        <div class="tile"><div class="k">i_d / i_q</div><div class="v" id="idq">0 / 0 A</div></div>
        <div class="tile"><div class="k">v_d / v_q</div><div class="v" id="vdq">0 / 0 V</div></div>
        <div class="tile"><div class="k">|V| / m</div><div class="v" id="Vmag">0 / 0.00</div></div>
        <div class="tile"><div class="k">영역</div><div class="v" id="region">SVPWM</div></div>
        <div class="tile"><div class="k">E_bemf</div><div class="v" id="ebemf">0 V</div></div>
        <div class="tile"><div class="k">토크</div><div class="v" id="tq">0 N·m</div></div>
        <div class="tile"><div class="k">ABS/TCS</div><div class="v" id="absTcs">—</div></div>
      </div>

      <!-- moved phasor to top-right under tiles -->
      <div class="phasor-top">
        <canvas id="phasor" width="320" height="160"></canvas>
      </div>

      <div id="three-wrap" tabindex="0"></div>
    </section>

    <aside class="sidebar">
      <div class="card" style="padding:10px">
        <div style="font-weight:800;color:#bfe3ff;margin:6px 2px">📈 Telemetry (Time s)</div>
        <canvas id="chartSpeed"   class="chart"></canvas>
        <canvas id="chartSlip"    class="chart"></canvas>
        <canvas id="chartMod"     class="chart"></canvas>
        <canvas id="chartDQ"      class="chart"></canvas>
        <canvas id="chartTorque"  class="chart"></canvas>
      </div>
      <!-- phasor card removed (now top-right in main) -->
    </aside>
  </main>

  <footer>© EV Free Drive — IPMSM + 7DOF Vehicle (ABS/TCS, Regen Blend, Combined-Slip Tire)</footer>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---------- Utils ----------
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
    const sign0=(x)=> Math.abs(x)<1e-9 ? 0 : (x>0?1:-1);

    const smoother=(()=>{ const m=new Map(); let last=performance.now(); return{
      dt(){ const now=performance.now(); const d=now-last; last=now; return d; },
      run(k,target,tauMs,dtMs){ if(!tauMs||tauMs<=1){m.set(k,target);return target;}
        const prev=m.has(k)?m.get(k):target; const a=1-Math.exp(-dtMs/Math.max(1,tauMs));
        const out=prev+a*(target-prev); m.set(k,out); return out; }
    };})();

    const $=id=>document.getElementById(id);
    const els={
      btnControls:$('btnControls'), drawer:$('controlsDrawer'),
      btnStart:$('btnStart'), btnPause:$('btnPause'), btnReset:$('btnReset'), btnCsv:$('btnCsv'), btnFollow:$('btnFollow'),
      btnDisturb:$('btnDisturb'), btnStep80:$('btnStep80'),
      tabs:[...document.querySelectorAll('.tab')], panels:{drive:$('panel-drive'), vehicle:$('panel-vehicle'), tire:$('panel-tire'), motor:$('panel-motor'), help:$('panel-help')},
      // drive
      mode:$('mode'), targetKmh:$('targetKmh'), Kps:$('Kps'), Kis:$('Kis'), taus:$('taus'),
      throttle:$('throttle'), brake:$('brake'), steer:$('steer'), keyRate:$('keyRate'),
      // vehicle
      mass:$('mass'), Iz:$('Iz'), Lf:$('Lf'), Lr:$('Lr'), track:$('track'), hcg:$('hcg'),
      Rw:$('Rw'), Jw:$('Jw'), gear:$('gear'), eta:$('eta'), CdA:$('CdA'), cr:$('cr'), rho:$('rho'), gradeDeg:$('gradeDeg'),
      // tire
      mu:$('mu'), Bk:$('Bk'), Ck:$('Ck'), Dk:$('Dk'), Ek:$('Ek'), By:$('By'), Cy:$('Cy'), Dy:$('Dy'), Ey:$('Ey'),
      absOn:$('absOn'), tcsOn:$('tcsOn'), kappaAbs:$('kappaAbs'), kappaTcs:$('kappaTcs'), brkBiasF:$('brkBiasF'), TbrkMax:$('TbrkMax'),
      // motor/inverter
      Vdc:$('Vdc'), Imax:$('Imax'), ctrlMode:$('ctrlMode'), mtpaOn:$('mtpaOn'), Kfw:$('Kfw'),
      pp:$('pp'), Rs:$('Rs'), Ld:$('Ld'), Lq:$('Lq'), psif:$('psif'), J:$('J'), B:$('B'),
      fswKhz:$('fswKhz'), deadOn:$('deadOn'), deadUs:$('deadUs'), Iregen:$('Iregen'), Pregen:$('Pregen'),
      Islew:$('Islew'), tauTqMs:$('tauTqMs'),
      // tiles
      v_kmh:$('v_kmh'), rpm:$('rpm'), idq:$('idq'), vdq:$('vdq'), Vmag:$('Vmag'), region:$('region'), ebemf:$('ebemf'), tq:$('tq'), absTcs:$('absTcs'),
      flagABS:$('flagABS'), flagTCS:$('flagTCS')
    };

    // Drawer + tabs
    els.btnControls.addEventListener('click',()=>{ els.drawer.classList.toggle('open'); els.drawer.setAttribute('aria-hidden', !els.drawer.classList.contains('open'));});
    els.tabs.forEach(t=>t.addEventListener('click',()=>{ els.tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active'); const k=t.dataset.tab; Object.values(els.panels).forEach(p=>p.classList.remove('active')); $('panel-'+k).classList.add('active');}));

    // Mode UI
    const cruiseBox=document.getElementById('cruiseBox'), pedalBox=document.getElementById('pedalBox');
    const setModeVis=()=>{ const m=els.mode.value; cruiseBox.style.display=m==='cruise'?'':'none'; pedalBox.style.display=m==='pedal'?'':''; };
    els.mode.addEventListener('change', setModeVis); setModeVis();

    // ---------- Charts ----------
    const mkX=()=>({type:'linear', title:{display:true, text:'Time (s)', color:'#cfe4ff'}, ticks:{color:'#9fb3cc'}, grid:{color:'rgba(255,255,255,.08)'}});
    const mkY=(t)=>({title:{display:!!t, text:t, color:'#cfe4ff'}, ticks:{color:'#9fb3cc'}, grid:{color:'rgba(255,255,255,.06)'}});
    const plugins={legend:{labels:{color:'#cfe4ff'}}, decimation:{enabled:true, algorithm:'lttb', samples:800}};

    const cSpeed=new Chart($('chartSpeed'),{type:'line',data:{datasets:[
      {label:'Speed (km/h)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Ref (km/h)',   data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('km/h')}, plugins}});

    const cSlip=new Chart($('chartSlip'),{type:'line',data:{datasets:[
      {label:'κ_FL', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'κ_FR', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'κ_RL', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'κ_RR', data:[], borderWidth:2, pointRadius:0, tension:.18}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('κ')}, plugins}});

    const cMod=new Chart($('chartMod'),{type:'line',data:{datasets:[
      {label:'|Vdq,act| (V)', data:[], yAxisID:'y1', borderWidth:2, pointRadius:0, tension:.18},
      {label:'m(ref)', data:[], yAxisID:'y2', borderWidth:2, pointRadius:0, tension:.18},
      {label:'E_bemf(V)', data:[], yAxisID:'y1', borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y1:mkY('V'), y2:{position:'right', grid:{drawOnChartArea:false}, ticks:{color:'#9fb3cc'}, title:{display:true, text:'m', color:'#cfe4ff'}}}, plugins}});

    const cDQ=new Chart($('chartDQ'),{type:'line',data:{datasets:[
      {label:'i_d(A)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'i_q(A)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'v_d(V)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]},
      {label:'v_q(V)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('A / V')}, plugins}});

    const cTorque=new Chart($('chartTorque'),{type:'line',data:{datasets:[
      {label:'Motor Torque (Nm)', data:[], borderWidth:2, pointRadius:0, tension:.18},
      {label:'Axle Limit (Nm)', data:[], borderWidth:2, pointRadius:0, tension:.18, borderDash:[6,4]}
    ]},options:{animation:false, scales:{x:mkX(), y:mkY('Nm')}, plugins}});

    const MAX_POINTS=6000;
    const pushXY=(chart, arr)=>{ const t=state.t; chart.data.datasets.forEach((ds,i)=>{ ds.data.push({x:t, y:arr[i]}); if(ds.data.length>MAX_POINTS) ds.data.shift(); const win=timeWindowSec(); while(ds.data.length && ds.data[0].x < t-win) ds.data.shift();}); chart.update('none'); };
    function chartIntervalMs(){ return 140; }
    function timeWindowSec(){ return 70; }

    // ---------- 3D Scene ----------
    const wrap=$('three-wrap');
    const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0f14);
    const camera=new THREE.PerspectiveCamera(55, wrap.clientWidth/Math.max(1,wrap.clientHeight), .1, 5000); camera.position.set(-18,10,18);
    const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(wrap.clientWidth, wrap.clientHeight); renderer.shadowMap.enabled=true; wrap.appendChild(renderer.domElement);
    const controls=new OrbitControls(camera, renderer.domElement); controls.target.set(0,1,0); controls.update();
    wrap.addEventListener('pointerdown',()=>wrap.focus()); window.addEventListener('load',()=>wrap.focus(),{once:true});
    scene.add(new THREE.HemisphereLight(0xbfd1ff, 0x202020, .9));
    const dir=new THREE.DirectionalLight(0xffffff,.9); dir.position.set(25,40,20); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); scene.add(dir);
    const ground=new THREE.Mesh(new THREE.PlaneGeometry(4000,4000), new THREE.MeshStandardMaterial({color:0x0e1624, metalness:.25, roughness:.95}));
    ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
    scene.add(new THREE.GridHelper(2000, 200, 0x2b415e, 0x0e1624));

    function wheel(){
      const tire=new THREE.Mesh(new THREE.TorusGeometry(0.42,0.11,16,28), new THREE.MeshStandardMaterial({color:0x111, roughness:0.9, metalness:0.1})); tire.rotation.y=Math.PI/2;
      const rim=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.16,16), new THREE.MeshStandardMaterial({color:0xcad6e3, metalness:0.7, roughness:0.35})); rim.rotation.z=Math.PI/2; rim.position.x=0.02;
      const g=new THREE.Group(); g.add(tire,rim); g.castShadow=true; return g;
    }
    function createSedan(){
      const car=new THREE.Group();
      const L=4.4, W=1.88, wheelbase=2.7, track=1.58, groundClear=0.18;
      const lower=new THREE.Mesh(new THREE.BoxGeometry(L,0.45,W), new THREE.MeshStandardMaterial({color:0x122a44, metalness:.6, roughness:.35}));
      lower.position.set(0, groundClear+0.225, 0); lower.castShadow=true; car.add(lower);
      const body=new THREE.Mesh(new THREE.BoxGeometry(L*0.86,0.6,W*0.98), new THREE.MeshStandardMaterial({color:0x1a3f6a, metalness:.6, roughness:.28}));
      body.position.set(0.05, groundClear+0.75, 0); body.castShadow=true; car.add(body);
      const hood=new THREE.Mesh(new THREE.BoxGeometry(1.35,0.35,W*0.95), new THREE.MeshStandardMaterial({color:0x1a4a7c, metalness:.6, roughness:.28}));
      hood.position.set(L*0.5-1.2, groundClear+0.95, 0); hood.rotation.z=-Math.PI*0.06; hood.castShadow=true; car.add(hood);
      const trunk=new THREE.Mesh(new THREE.BoxGeometry(1.05,0.35,W*0.95), new THREE.MeshStandardMaterial({color:0x173a63, metalness:.6, roughness:.28}));
      trunk.position.set(-L*0.5+0.9, groundClear+0.95, 0); trunk.rotation.z= Math.PI*0.03; trunk.castShadow=true; car.add(trunk);
      const glass=new THREE.Mesh(new THREE.BoxGeometry(1.9,0.5,W*0.85), new THREE.MeshPhysicalMaterial({color:0xaad4ff, metalness:0, roughness:0.05, transmission:0.6, transparent:true, ior:1.45}));
      glass.position.set(-0.15, groundClear+1.25, 0); glass.rotation.z=0.08; car.add(glass);
      const bumperM = new THREE.MeshStandardMaterial({color:0x0f2034, metalness:.5, roughness:.45});
      const frontB = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.28,W*0.96), bumperM); frontB.position.set(L*0.5-0.25, groundClear+0.45, 0); car.add(frontB);
      const rearB  = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.28,W*0.96), bumperM); rearB.position.set(-L*0.5+0.25, groundClear+0.45, 0); car.add(rearB);
      const wFL=wheel(), wFR=wheel(), wRL=wheel(), wRR=wheel();
      const xF =  wheelbase*0.5, xR = -wheelbase*0.5, z = track*0.5;
      wFL.position.set( xF, groundClear+0.42,  z);
      wFR.position.set( xF, groundClear+0.42, -z);
      wRL.position.set( xR, groundClear+0.42,  z);
      wRR.position.set( xR, groundClear+0.42, -z);
      car.add(wFL,wFR,wRL,wRR);
      const carAxes=new THREE.AxesHelper(1.2); carAxes.position.set(0, groundClear+0.4, 0); car.add(carAxes);
      car.userData.wheels = {wFL,wFR,wRL,wRR, pos:{
        FL:{x:xF, y: z}, FR:{x:xF, y:-z}, RL:{x:xR, y: z}, RR:{x:xR, y:-z}
      }}; return car;
    }
    const car = createSedan(); scene.add(car);

    // ---------- Phasor canvas ----------
    const phasor=$('phasor'); const pctx=phasor.getContext('2d');
    function drawCircle(ctx,cx,cy,r){ ctx.beginPath(); ctx.arc(cx,cy,r,0,2*Math.PI); ctx.stroke(); }
    function drawHex(ctx,cx,cy,r){
      ctx.beginPath();
      for(let k=0;k<6;k++){ const a=Math.PI/6+k*Math.PI/3, x=cx+r*Math.cos(a), y=cy-r*Math.sin(a); if(k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.closePath(); ctx.stroke();
    }
    function drawLine(ctx,x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    function drawPhasor(Vd,Vq,Vdc){
      const w=phasor.width, h=phasor.height, cx=w/2, cy=h/2, padding=12;
      const rHex=Math.min(w,h)/2 - padding; const Vhex=2*Vdc/3, Vlin=Vdc/Math.sqrt(3); const s=rHex/Vhex;
      pctx.clearRect(0,0,w,h); pctx.lineWidth=1;
      pctx.strokeStyle='#2e415c'; drawCircle(pctx,cx,cy,Vlin*s);
      pctx.strokeStyle='#f3b740'; drawHex(pctx,cx,cy,Vhex*s);
      pctx.strokeStyle='rgba(255,255,255,.18)'; drawLine(pctx,padding,cy,w-padding,cy); drawLine(pctx,cx,padding,cx,h-padding);
      pctx.strokeStyle='#e8eef9'; pctx.lineWidth=2; drawLine(pctx,cx,cy,cx+Vd*s,cy- Vq*s);
      pctx.fillStyle='#34d5ff'; pctx.beginPath(); pctx.arc(cx+Vd*s, cy- Vq*s,3,0,2*Math.PI); pctx.fill();
    }

    // ---------- State ----------
    const state={
      running:false, follow:true, t:0,
      // vehicle 7DOF
      vx:0, vy:0, r:0, psi:0, x:0, y:0,
      w:{FL:0, FR:0, RL:0, RR:0},
      // elec
      theta_e:0, id:0, iq:0, vd:0, vq:0, va:0, vb:0, vc:0,
      // controller
      evInt:0,
      // per-wheel ABS mod gain (0..1)
      abs:{FL:1, FR:1, RL:1, RR:1},
      // TCS gain (0..1)
      tcsGain:1,
      // input smoothing
      u:{ thr:0, brk:0, steer:0, thrTar:0, brkTar:0, steerTar:0 },
      // current reference with slew
      ref:{ id:0, iq:0, tqf:0 },
      // camera spring rig
      cam:{pos:new THREE.Vector3(-12,6,-12), vel:new THREE.Vector3(0,0,0)},
      // logs
      log:[]
    };
    let last=performance.now();

    // ---------- Param access ----------
    function P(){ return {
      // drive
      mode:els.mode.value, targetKmh:+els.targetKmh.value, Kps:+els.Kps.value, Kis:+els.Kis.value, taus:+els.taus.value,
      thr:(+els.throttle?.value||0)/100, brk:(+els.brake?.value||0)/100, keyRate:+els.keyRate?.value||100, steerDeg:+(els.steer?.value||0),
      // vehicle
      m:+els.mass.value, Iz:+els.Iz.value, Lf:+els.Lf.value, Lr:+els.Lr.value, track:+els.track.value, hcg:+els.hcg.value,
      Rw:+els.Rw.value, Jw:+els.Jw.value, gear:+els.gear.value, eta:+els.eta.value, CdA:+els.CdA.value, cr:+els.cr.value, rho:+els.rho.value,
      grade:+els.gradeDeg.value*Math.PI/180,
      // tire
      mu:+els.mu.value, Bk:+els.Bk.value, Ck:+els.Ck.value, Dk:+els.Dk.value, Ek:+els.Ek.value, By:+els.By.value, Cy:+els.Cy.value, Dy:+els.Dy.value, Ey:+els.Ey.value,
      absOn:(els.absOn.value==='1'), tcsOn:(els.tcsOn.value==='1'), kappaAbs:+els.kappaAbs.value, kappaTcs:+els.kappaTcs.value, brkBiasF:+els.brkBiasF.value, TbrkMax:+els.TbrkMax.value,
      // motor/inverter
      Vdc:+els.Vdc.value, Imax:+els.Imax.value, ctrlMode:els.ctrlMode.value, mtpa:(els.mtpaOn.value==='1'), Kfw:+els.Kfw.value,
      pp:+els.pp.value, Rs:+els.Rs.value, Ld:+els.Ld.value, Lq:+els.Lq.value, psif:+els.psif.value, Jm:+els.J.value, Bm:+els.B.value,
      fsw:(+els.fswKhz.value||10)*1000, deadOn:(els.deadOn.value==='1'), Td:+els.deadUs.value*1e-6,
      Iregen:+els.Iregen.value, Pregen:+els.Pregen.value*1000,
      // response
      Islew:+els.Islew.value, tauTq: Math.max(0.005, (+els.tauTqMs.value||60)/1000)
    };}

    // ---------- Transforms ----------
    function dq_to_ab(d,q,th){ const c=Math.cos(th), s=Math.sin(th); return {a:c*d - s*q, b:s*d + c*q}; }
    function ab_to_dq(a,b,th){ const c=Math.cos(th), s=Math.sin(th); return {d:c*a + s*b, q:-s*a + c*b}; }
    function ab_to_abc(a,b){
      const va = a, vb = -0.5*a + (Math.sqrt(3)/2)*b, vc = -0.5*a - (Math.sqrt(3)/2)*b;
      return {va,vb,vc};
    }
    function abc_to_ab(va,vb,vc){ const a=(2/3)*(va-0.5*(vb+vc)); const b=(2/3)*((Math.sqrt(3)/2)*(vb-vc)); return {a,b}; }

    // ---------- IPMSM core ----------
    function torque_ipmsm(pp, psif, Ld, Lq, id, iq){ return 1.5*pp*( psif*iq + (Ld - Lq)*id*iq ); }
    function voltage_dq(Rs, Ld, Lq, psif, id, iq, we){
      return {vd: Rs*id - we*Lq*iq, vq: Rs*iq + we*(Ld*id + psif)};
    }
    function mtpa_idiq(Is, Ld, Lq, psif){
      const dlt=Ld-Lq; if(Math.abs(Is)<1e-9) return {id:0,iq:0};
      const num = -psif + Math.sqrt(psif*psif + 8*dlt*dlt*Is*Is);
      const id = num/(4*dlt), iq = Math.sqrt(Math.max(0, Is*Is - id*id)); return {id,iq};
    }
    function ref_with_MTPA_MTPV(Tm_ref, we, p){
      const Imax=p.Imax, Vlin=p.Vdc/Math.sqrt(3), Vhex=2*p.Vdc/3; const Vtarget=(p.ctrlMode==='foc')?Vlin:Vhex;
      let id_ref=0, iq_ref=0;
      if(p.mtpa){
        let lo=0, hi=Imax, best={id:0,iq:0};
        for(let k=0;k<20;k++){
          const Is=(lo+hi)/2; let {id,iq}=mtpa_idiq(Is,p.Ld,p.Lq,p.psif); iq=Math.sign(Tm_ref)*Math.abs(iq);
          const T=torque_ipmsm(p.pp,p.psif,p.Ld,p.Lq,id,iq); if(Math.abs(T)>=Math.abs(Tm_ref)){ best={id,iq}; hi=Is; } else lo=Is;
        } id_ref=best.id; iq_ref=best.iq;
      }else{ iq_ref=clamp(Tm_ref/(1.5*p.pp*p.psif), -Imax, Imax); id_ref=0; const Is=Math.hypot(id_ref,iq_ref); if(Is>Imax){ const k=Imax/Is; id_ref*=k; iq_ref*=k; } }

      let {vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we), V=Math.hypot(vd,vq);
      if(V>Vtarget && Math.abs(we)>1e-6){
        const err=V-Vtarget; id_ref -= (p.Kfw*err)/(Math.abs(we)+1e-6);
        let Is=Math.hypot(id_ref,iq_ref); if(Is>Imax){ const k=Imax/Is; id_ref*=k; iq_ref*=k; }
        ({vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we)); V=Math.hypot(vd,vq);
      }
      if(V>Vtarget && Math.abs(we)>1e-6){
        const Is=Math.hypot(id_ref,iq_ref);
        for(let it=0; it<60 && V>Vtarget; it++){ id_ref -= 0.005*Is; const sc=Is/Math.max(1e-9,Math.hypot(id_ref,iq_ref)); id_ref*=sc; iq_ref*=sc;
          ({vd,vq}=voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,id_ref,iq_ref,we)); V=Math.hypot(vd,vq); }
      }
      return {id:id_ref, iq:iq_ref};
    }

    // ---------- Modulation ----------
    const M_HEX=2/Math.sqrt(3);
    function regionFromM(m){ return (m<=1)?'SVPWM':(m<M_HEX-1e-9?'Overmod':'6-Step'); }
    function svm_duties(vα,vβ,Vdc,Ts,region){
      let θ=Math.atan2(vβ,vα); if(θ<0) θ+=2*Math.PI; const sector=Math.floor(θ/(Math.PI/3))+1; const base=(sector-1)*(Math.PI/3); const α=θ-base;
      const Vref=Math.hypot(vα,vβ); const K=(Math.sqrt(3)/Vdc)*Vref;
      let T1=K*Math.sin(Math.PI/3-α)*Ts, T2=K*Math.sin(α)*Ts; T1=Math.max(0,T1); T2=Math.max(0,T2); let T0=Ts-T1-T2;
      if(region==='SVPWM' && T0<0){ const s=Ts/(T1+T2+1e-12); T1*=s; T2*=s; T0=0; }
      if(region==='Overmod'){ if(T0<0){ const s=Ts/(T1+T2+1e-12); T1*=s; T2*=s; T0=0; } else T0=0; }
      if(region==='6-Step'){ T1=Ts; T2=0; T0=0; }
      const halfT0=T0/2; let da,db,dc;
      switch(sector){
        case 1: da=(T1+T2+halfT0)/Ts; db=(T2+halfT0)/Ts; dc=halfT0/Ts; break;
        case 2: da=(T1+halfT0)/Ts;     db=(T1+T2+halfT0)/Ts; dc=halfT0/Ts; break;
        case 3: da=halfT0/Ts;          db=(T1+T2+halfT0)/Ts; dc=(T2+halfT0)/Ts; break;
        case 4: da=halfT0/Ts;          db=(T1+halfT0)/Ts;     dc=(T1+T2+halfT0)/Ts; break;
        case 5: da=(T2+halfT0)/Ts;     db=halfT0/Ts;          dc=(T1+T2+halfT0)/Ts; break;
        case 6: da=(T1+T2+halfT0)/Ts;  db=halfT0/Ts;          dc=(T1+halfT0)/Ts; break;
      }
      return {da:clamp(da,0,1), db:clamp(db,0,1), dc:clamp(dc,0,1), sector};
    }
    function phaseVoltages_fromDuties(da,db,dc,Vdc){
      const va=(2/3)*Vdc*(da-0.5*(db+dc)); const vb=(2/3)*Vdc*(db-0.5*(dc+da)); const vc=(2/3)*Vdc*(dc-0.5*(da+db)); return {va,vb,vc};
    }
    function abc_from_six(theta,Vdc){
      const ang=(theta%(2*Math.PI)+2*Math.PI)%(2*Math.PI); const sec=Math.floor(ang/(Math.PI/3));
      const map=[[1,1,0],[0,1,0],[0,1,1],[0,0,1],[1,0,1],[1,0,0]][sec];
      const pa=(map[0]?+Vdc/2:-Vdc/2), pb=(map[1]?+Vdc/2:-Vdc/2), pc=(map[2]?+Vdc/2:-Vdc/2); const avg=(pa+pb+pc)/3; return {va:pa-avg,vb:pb-avg,vc:pc-avg};
    }
    function apply_deadtime(va,vb,vc, ia,ib,ic, Vdc, Td, Ts){
      const Vdead=Vdc*(Td/Math.max(1e-9,Ts));
      return {va:va - Vdead*Math.sign(ia||0), vb:vb - Vdead*Math.sign(ib||0), vc:vc - Vdead*Math.sign(ic||0)};
    }
    function applyModulation(vα_ref, vβ_ref, p, theta_e, ia,ib,ic){
      const Vlin=p.Vdc/Math.sqrt(3), Vref=Math.hypot(vα_ref,vβ_ref), m_ref=Vref/Vlin; let region=regionFromM(m_ref);
      if(p.ctrlMode==='foc') region='SVPWM'; if(p.ctrlMode==='six') region='6-Step';
      let va,vb,vc, da,db,dc;
      if(region==='6-Step' && p.ctrlMode!=='foc'){ ({va,vb,vc}=abc_from_six(theta_e,p.Vdc)); }
      else{
        let vα=vα_ref, vβ=vβ_ref; if(p.ctrlMode==='foc' && Vref>Vlin){ const k=Vlin/Vref; vα*=k; vβ*=k; }
        ({da,db,dc}=svm_duties(vα,vβ,p.Vdc,1/Math.max(1,p.fsw),region)); ({va,vb,vc}=phaseVoltages_fromDuties(da,db,dc,p.Vdc));
      }
      if(p.deadOn){ ({va,vb,vc}=apply_deadtime(va,vb,vc, ia,ib,ic, p.Vdc, p.Td, 1/Math.max(1,p.fsw))); }
      const ab=abc_to_ab(va,vb,vc); const Vmag=Math.hypot(ab.a,ab.b);
      return {va,vb,vc,Vmag,m:Math.min(M_HEX,m_ref),region,duties:{da,db,dc}};
    }

    // ---------- Tire model ----------
    function pacejka_y(B,C,D,E, x){ return D*Math.sin(C*Math.atan(B*x - E*(B*x - Math.atan(B*x)))); }
    function tireForcesCombined(kappa, alpha, Fz, mu, prm){
      const Dlong = prm.Dk * mu * Fz;
      const Dlat  = prm.Dy * mu * Fz;
      const Fx0 = pacejka_y(prm.Bk, prm.Ck, Dlong, prm.Ek, kappa);
      const Fy0 = pacejka_y(prm.By, prm.Cy, Dlat , prm.Ey, alpha);
      const mag0 = Math.hypot(Fx0, Fy0), cap = mu*Fz;
      const G = (mag0<=cap || cap<=1e-6) ? 1 : (cap/mag0);
      return {Fx:Fx0*G, Fy:Fy0*G};
    }

    // ---------- Input handling (Keyboard + Gamepad) ----------
    const down=new Set();
    function ensurePedalMode(){ if(els.mode.value!=='pedal'){ els.mode.value='pedal'; els.mode.dispatchEvent(new Event('change')); } }
    window.addEventListener('keydown',e=>{
      const tag=(e.target?.tagName||'').toLowerCase(); if(tag==='input'||tag==='select'||tag==='textarea') return;
      if(['KeyW','KeyS','KeyA','KeyD','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)){ e.preventDefault(); down.add(e.code); }
    }, {capture:true});
    window.addEventListener('keyup',e=>down.delete(e.code), {capture:true});

    // simple gamepad read (use first gamepad)
    function readGamepad(){
      const gps = navigator.getGamepads?.(); if(!gps) return null;
      const gp = gps[0]; if(!gp) return null;
      const rt = gp.buttons?.[7]?.value ?? 0, lt = gp.buttons?.[6]?.value ?? 0, lsx = gp.axes?.[0] ?? 0;
      return {thr: clamp(rt,0,1), brk: clamp(lt,0,1), steer: clamp(lsx, -1, 1)};
    }

    function slewToward(target, current, rateUp, rateDown, dt){
      const rate = (target>current)?rateUp:rateDown;
      const delta = clamp(target-current, -rate*dt, rate*dt);
      return current + delta;
    }
    function lpf(current, target, tau, dt){
      if(tau<=1e-4) return target;
      const a = 1 - Math.exp(-dt/tau);
      return current + a*(target-current);
    }
    function pedalMap(x){ const y = Math.pow(clamp(x,0,1), 1.6); return (y<0.7)? y*0.9 : 0.9 + (y-0.7)*0.7; }

    function applyKey(dt){
      const p=P();

      // === FIX: if in cruise and any drive key is pressed, auto-switch to pedal ===
      const driveKeyDown = down.has('KeyW')||down.has('ArrowUp')||down.has('KeyS')||down.has('ArrowDown')||down.has('KeyA')||down.has('ArrowLeft')||down.has('KeyD')||down.has('ArrowRight');
      if(p.mode==='cruise'){
        if(driveKeyDown){ ensurePedalMode(); setModeVis(); }
        else { if(down.has('Space')){ toggleRun(); } return; }
      }

      // base targets from sliders
      state.u.thrTar = (+els.throttle.value||0)/100;
      state.u.brkTar = (+els.brake.value||0)/100;
      state.u.steerTar = (+els.steer.value||0)/30;

      // keyboard nudges
      if(down.has('KeyW')||down.has('ArrowUp'))   state.u.thrTar += (p.keyRate/100)*dt;
      if(down.has('KeyS')||down.has('ArrowDown')) state.u.brkTar += (p.keyRate/100)*dt;
      if(down.has('KeyA')||down.has('ArrowLeft')) state.u.steerTar -= 1.8*dt;
      if(down.has('KeyD')||down.has('ArrowRight'))state.u.steerTar += 1.8*dt;

      if(!(down.has('KeyW')||down.has('ArrowUp')))   state.u.thrTar -= (p.keyRate/100)*0.6*dt;
      if(!(down.has('KeyS')||down.has('ArrowDown'))) state.u.brkTar -= (p.keyRate/100)*0.8*dt;

      // gamepad
      const gp = readGamepad();
      if(gp){
        state.u.thrTar = Math.max(state.u.thrTar, gp.thr);
        state.u.brkTar = Math.max(state.u.brkTar, gp.brk);
        state.u.steerTar = Math.abs(gp.steer)>0.05 ? gp.steer : state.u.steerTar;
      }

      // clamp + mutual exclusion
      state.u.thrTar = clamp(state.u.thrTar, 0, 1);
      state.u.brkTar = clamp(state.u.brkTar, 0, 1);
      state.u.steerTar = clamp(state.u.steerTar, -1, 1);
      if(state.u.thrTar>0 && state.u.brkTar>0){ if(state.u.thrTar>state.u.brkTar) state.u.brkTar=0; else state.u.thrTar=0; }

      // slew + lpf
      state.u.thr = lpf(slewToward(state.u.thrTar, state.u.thr, 2.0, 3.0, dt), state.u.thrTar, 0.10, dt);
      state.u.brk = lpf(slewToward(state.u.brkTar, state.u.brk, 3.0, 4.0, dt), state.u.brkTar, 0.10, dt);
      state.u.steer = lpf(slewToward(state.u.steerTar, state.u.steer, 3.0, 6.0, dt), state.u.steerTar, 0.10, dt);

      // reflect to UI
      els.throttle.value = Math.round(100*state.u.thr);
      els.brake.value    = Math.round(100*state.u.brk);
      els.steer.value    = Math.round(30*state.u.steer);

      if(down.has('Space')){ toggleRun(); }
      ensurePedalMode();
    }

    function toggleRun(){ state.running=!state.running; down.delete('Space'); if(state.running){ last=performance.now(); requestAnimationFrame(loop);} }

    // ---------- Simulation ----------
    const DT_ELEC=0.0005;
    const DT_VEH =0.001;
    let lastChart=0;

    function stepSim(dt){
      const p=P();

      // steering w/ speed-dependent limit
      const vmag_body = Math.hypot(state.vx, state.vy);
      const steerDegCmd = (p.mode==='cruise'?0:(+els.steer.value||0));
      const maxDeg = 30, minDeg=8, vmax=150/3.6;
      const allow = minDeg + (maxDeg-minDeg)*clamp(1 - vmag_body/vmax, 0, 1);
      const delta = clamp(steerDegCmd, -allow, allow) * Math.PI/180;

      // torque command
      let Tm_cmd = 0;
      if(p.mode==='cruise'){
        const vref = clamp(p.targetKmh,0,220)/3.6;
        const ev = vref - vmag_body;
        const torqueCmd = p.Kps*ev + state.evInt*p.Kis;
        const Kaw_s = 1/Math.max(0.1, p.taus); state.evInt += ( ev + Kaw_s*0 ) * dt;
        Tm_cmd = clamp(torqueCmd*400, -8000, 8000);
      }else{
        const demand = pedalMap(state.u.thr);
        const Tcur = 1.5*p.pp*p.psif*p.Imax;
        Tm_cmd = demand * Tcur;
      }

      // braking & regen
      const isBraking = (p.mode==='pedal' ? state.u.brk>0.02 : false);
      let Tm_cmd_brake = 0, T_fric_total = 0;
      const w_wheel_avg = (state.w.RL + state.w.RR)/2;
      const w_mech = w_wheel_avg * p.gear;
      const we = p.pp * w_mech;

      const T_elec_I = 1.5*p.pp*p.psif * Math.min(p.Iregen, p.Imax);
      const T_elec_P = (Math.abs(w_mech)>1e-3) ? (p.Pregen/Math.abs(w_mech)) : 1e9;

      const g=9.80665, L=p.Lf+p.Lr;
      const ax_proxy = (Tm_cmd*p.gear*p.eta/p.Rw)/Math.max(1e-6,p.m);
      const Fzr_total = p.m*g*(p.Lf/L) + p.m*ax_proxy*(p.hcg/L);
      const FzR = Math.max(0.1, Fzr_total/2);
      const FxR_trac = p.mu * (2*FzR);
      const T_regen_trac = (FxR_trac*p.Rw)/(p.gear*Math.max(1e-6,p.eta));
      const Tm_regen_limit = Math.max(0, Math.min(T_elec_I, T_elec_P, T_regen_trac));

      if(isBraking){
        const demandMotorSide = - (state.u.brk) * (2*p.TbrkMax) * p.eta / p.gear;
        Tm_cmd = Math.min(Tm_cmd, demandMotorSide);
        if(Tm_cmd<0){
          const Tm_req_motor = Math.max(-Tm_regen_limit, Tm_cmd);
          Tm_cmd_brake = Tm_req_motor;
          T_fric_total  = -(Tm_cmd - Tm_req_motor) * (p.gear/Math.max(1e-6,p.eta));
        }
      }

      // torque lag
      const Treq = (Tm_cmd_brake || Tm_cmd);
      state.ref.tqf += (Treq - state.ref.tqf) * (dt/Math.max(1e-3,p.tauTq));

      // current ref + slew
      let {id:id_ref_cmd, iq:iq_ref_cmd} = ref_with_MTPA_MTPV(state.ref.tqf, we, p);
      const dImax = p.Islew * dt;
      state.ref.id = clamp(id_ref_cmd, state.ref.id - dImax, state.ref.id + dImax);
      state.ref.iq = clamp(iq_ref_cmd, state.ref.iq - dImax, state.ref.iq + dImax);

      const vDQ_ff = voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,state.ref.id,state.ref.iq,we);
      const vAB_ref = dq_to_ab( vDQ_ff.vd, vDQ_ff.vq, state.theta_e );

      const iab = dq_to_ab(state.id, state.iq, state.theta_e);
      const iabc = ab_to_abc(iab.a, iab.b);

      const mod = applyModulation(vAB_ref.a, vAB_ref.b, p, state.theta_e, iabc.va, iabc.vb, iabc.vc);
      const ab_act = abc_to_ab(mod.va, mod.vb, mod.vc); const vdq_act = ab_to_dq(ab_act.a, ab_act.b, state.theta_e);
      state.vd=vdq_act.d; state.vq=vdq_act.q;

      // Electrical dynamics
      const did = (state.vd - p.Rs*state.id + we*p.Lq*state.iq)/p.Ld;
      const diq = (state.vq - p.Rs*state.iq - we*(p.Ld*state.id + p.psif))/p.Lq;
      state.id += did*dt; state.iq += diq*dt;
      const Tm = torque_ipmsm(p.pp,p.psif,p.Ld,p.Lq,state.id,state.iq);

      // Vehicle dynamics
      const halfTrack = p.track/2;
      const wheels = ['FL','FR','RL','RR'];
      const steer = {FL:delta, FR:delta, RL:0, RR:0};
      const pos = {FL:{x: p.Lf, y: +halfTrack}, FR:{x: p.Lf, y:-halfTrack}, RL:{x:-p.Lr, y:+halfTrack}, RR:{x:-p.Lr, y:-halfTrack}};
      let sumFx=0, sumFy=0, sumMz=0;

      let Tbrake = {FL:0, FR:0, RL:0, RR:0};
      if(T_fric_total>0){
        const front = p.brkBiasF*T_fric_total, rear=(1-p.brkBiasF)*T_fric_total;
        Tbrake.FL += front/2; Tbrake.FR += front/2; Tbrake.RL += rear/2; Tbrake.RR += rear/2;
      }

      const mu = p.mu;
      const prm = {Bk:p.Bk,Ck:p.Ck,Dk:p.Dk,Ek:p.Ek, By:p.By,Cy:p.Cy,Dy:p.Dy,Ey:p.Ey};
      const Fzf_base = p.m*9.80665*(p.Lr/(p.Lf+p.Lr))/2;
      const Fzr_base = p.m*9.80665*(p.Lf/(p.Lf+p.Lr))/2;
      let kappa = {FL:0, FR:0, RL:0, RR:0};
      for(const w of wheels){
        const xi=pos[w].x, yi=pos[w].y;
        const vxi = state.vx - state.r*yi;
        const vyi = state.vy + state.r*xi;
        const c=Math.cos(steer[w]), s=Math.sin(steer[w]);
        const u =  c*vxi + s*vyi;
        const v = -s*vxi + c*vyi;
        const rw = p.Rw, eps=0.5;
        kappa[w] = (rw*state.w[w] - u) / (Math.max(Math.abs(u), eps));
        const Fz = (w==='FL'||w==='FR') ? Fzf_base : Fzr_base;
        const alpha = Math.atan2(v, Math.max(Math.abs(u), 0.1));
        const {Fx:Fxw, Fy:Fyw} = tireForcesCombined(kappa[w], alpha, Fz, mu, prm);
        const Fx =  c*Fxw - s*Fyw;
        const Fy =  s*Fxw + c*Fyw;
        sumFx += Fx; sumFy += Fy; sumMz += xi*Fy - yi*Fx;
      }

      const F_drag = 0.5*p.rho*p.CdA*state.vx*Math.abs(state.vx);
      const F_roll = p.m*9.80665*p.cr*sign0(state.vx);
      const F_grade = p.m*9.80665*Math.sin(p.grade);

      const ax_dyn = (sumFx - F_drag - F_roll - F_grade)/p.m + state.r*state.vy;
      const ay_dyn = (sumFy)/p.m - state.r*state.vx;
      const rr_dot = sumMz/p.Iz;

      // ABS/TCS
      let absActive=false, tcsActive=false;
      if(p.absOn && (p.mode==='pedal' && state.u.brk>0.02)){
        const kABS=p.kappaAbs;
        for(const w of wheels){
          if(kappa[w] < -kABS){ state.abs[w] = Math.max(0.3, state.abs[w]-0.08); absActive=true; }
          else { state.abs[w] = Math.min(1.0, state.abs[w]+0.03); }
        }
        for(const w of wheels){ Tbrake[w] *= state.abs[w]; }
      }else{ for(const w of wheels){ state.abs[w] = Math.min(1.0, state.abs[w]+0.05); } }

      if(p.tcsOn){
        const kTCS=p.kappaTcs;
        const slipR = Math.max(kappa.RL, kappa.RR);
        if(slipR>kTCS && Tm*p.gear*p.eta>0){ tcsActive=true; state.tcsGain = Math.max(0.2, state.tcsGain-0.05); }
        else state.tcsGain = Math.min(1.0, state.tcsGain+0.03);
      } else state.tcsGain=1.0;

      const driveScaled = {FL:0, FR:0, RL:state.tcsGain*0.5*(Tm*p.gear*p.eta), RR:state.tcsGain*0.5*(Tm*p.gear*p.eta)};
      const Jw=p.Jw;
      for(const w of wheels){
        const xi=pos[w].x, yi=pos[w].y;
        const vxi = state.vx - state.r*yi;
        const vyi = state.vy + state.r*xi;
        const c=Math.cos(steer[w]), s=Math.sin(steer[w]);
        const u =  c*vxi + s*vyi;
        const Fz = (w==='FL'||w==='FR') ? Fzf_base : Fzr_base;
        const {Fx:Fxw2} = tireForcesCombined(kappa[w], 0, Fz, mu, prm);
        const Tw_tire = Fxw2 * p.Rw;
        const Tnet = driveScaled[w] - Tbrake[w] - Tw_tire;
        state.w[w] += (Tnet/Math.max(1e-6,Jw))*dt;
      }

      state.vx += ax_dyn*dt; state.vy += ay_dyn*dt; state.r += rr_dot*dt;
      state.psi += state.r*dt;

      const cPsi=Math.cos(state.psi), sPsi=Math.sin(state.psi);
      const Vxw = cPsi*state.vx - sPsi*state.vy, Vyw = sPsi*state.vx + cPsi*state.vy;
      state.x += Vxw*dt; state.y += Vyw*dt;

      state.theta_e += we*dt;

      // tiles
      const dtMs=smoother.dt(); const tau = 250;
      const speedKmh = Math.hypot(state.vx,state.vy)*3.6;
      const rpmVal = w_mech*60/(2*Math.PI);
      const Ebemf = Math.abs(we)*p.psif;
      els.v_kmh.textContent = `${smoother.run('kmh',speedKmh, tau, dtMs).toFixed(1)} km/h`;
      els.rpm.textContent   = `${smoother.run('rpm', rpmVal, tau, dtMs).toFixed(0)}`;
      els.idq.textContent   = `${smoother.run('id', state.id, tau, dtMs).toFixed(1)} / ${smoother.run('iq', state.iq, tau, dtMs).toFixed(1)} A`;
      els.vdq.textContent   = `${smoother.run('vd', state.vd, tau, dtMs).toFixed(1)} / ${smoother.run('vq', state.vq, tau, dtMs).toFixed(1)} V`;
      els.Vmag.textContent  = `${smoother.run('vm', mod.Vmag, tau, dtMs).toFixed(1)} / ${smoother.run('m', mod.m, tau, dtMs).toFixed(3)}`;
      els.region.textContent= mod.region;
      els.ebemf.textContent = `${smoother.run('eb', Ebemf, tau, dtMs).toFixed(1)} V`;
      els.tq.textContent    = `${smoother.run('tq', Tm, tau, dtMs).toFixed(1)} N·m`;
      els.absTcs.textContent= `${p.absOn?(absActive?'ABS ON':'ABS RDY'):'ABS OFF'} / ${p.tcsOn?(tcsActive?'TCS ON':'TCS RDY'):'TCS OFF'}`;
      els.flagABS.textContent = `ABS: ${absActive?'ON':'RDY'}`;
      els.flagTCS.textContent = `TCS: ${tcsActive?'ON':'RDY'}`;

      // charts
      const now=performance.now();
      if(now-lastChart>chartIntervalMs()){
        pushXY(cSpeed,[speedKmh,(p.mode==='cruise'?p.targetKmh:speedKmh)]);
        pushXY(cSlip,[kappa.FL,kappa.FR,kappa.RL,kappa.RR]);
        const Vlin=p.Vdc/Math.sqrt(3); const mref=Math.hypot( ...Object.values(voltage_dq(p.Rs,p.Ld,p.Lq,p.psif,state.ref.id,state.ref.iq,we)) )/Vlin;
        pushXY(cMod,[mod.Vmag,mref,Ebemf]);
        pushXY(cDQ,[state.id,state.iq,state.vd,state.vq]);
        const axleLimitNm = T_regen_trac*p.gear*Math.max(1e-6,p.eta);
        pushXY(cTorque,[Tm, axleLimitNm]);
        lastChart=now;
      }
      drawPhasor(state.vd,state.vq,p.Vdc);

      // 3D update
      car.position.set(state.x,0,state.y);
      car.rotation.y = -state.psi;
      const {wFL,wFR,wRL,wRR}=car.userData.wheels;
      [wFL,wFR,wRL,wRR].forEach((w,i)=>{ const key=['FL','FR','RL','RR'][i]; w.rotation.x -= state.w[key]*(1/60); });

      // Camera spring + FOV
      if(state.follow){
        const speed = Math.hypot(Vxw,Vyw);
        const fovTarget = 55 + (72-55)*(Math.tanh(speed/25));
        camera.fov += (fovTarget - camera.fov)*0.08;
        camera.updateProjectionMatrix();
        const backLocal = new THREE.Vector3(-10 - 0.06*speed, 6 + 0.01*speed, 0)
          .applyAxisAngle(new THREE.Vector3(0,1,0), -state.psi);
        const target = new THREE.Vector3(state.x,0,state.y).add(backLocal);
        const zeta=0.8, wn=7;
        const to = target.clone().sub(state.cam.pos);
        const acc = to.multiplyScalar(wn*wn).add(state.cam.vel.clone().multiplyScalar(-2*zeta*wn));
        state.cam.vel.add(acc.multiplyScalar(dt));
        state.cam.pos.add(state.cam.vel.clone().multiplyScalar(dt));
        camera.position.copy(state.cam.pos);
        const look = new THREE.Vector3(state.x+4*Math.cos(-state.psi),1,state.y+4*Math.sin(-state.psi));
        controls.target.lerp(look, .2); controls.update();
      }

      // log
      state.log.push({t:state.t, kmh:speedKmh, id:state.id, iq:state.iq, vd:state.vd, vq:state.vq, V:mod.Vmag, m:mod.m, tq:Tm, eb:Ebemf});
      state.t += dt;
    }

    function loop(now){
      if(!state.running) return;
      const dt=Math.min(.02,(now-last)/1000); last=now;
      let rem=dt; while(rem>1e-9){ const h=Math.min(DT_VEH, rem);
        applyKey(h);
        let re=h; while(re>1e-9){ const he=Math.min(DT_ELEC,re); stepSim(he); re-=he; }
        rem-=h;
      }
      requestAnimationFrame(loop);
      renderer.render(scene,camera);
    }

    new ResizeObserver(()=>{ const w=wrap.clientWidth, h=wrap.clientHeight; renderer.setSize(w,h); camera.aspect=w/Math.max(1,h); camera.updateProjectionMatrix(); }).observe(wrap);

    // ---------- Buttons ----------
    $('btnStart').addEventListener('click',()=>{ if(!state.running){ state.running=true; last=performance.now(); requestAnimationFrame(loop);} });
    $('btnPause').addEventListener('click',()=> state.running=false);
    $('btnReset').addEventListener('click',()=>{ state.running=false;
      Object.assign(state,{t:0, vx:0, vy:0, r:0, psi:0, x:0, y:0, w:{FL:0,FR:0,RL:0,RR:0}, id:0,iq:0,vd:0,vq:0,theta_e:0, abs:{FL:1,FR:1,RL:1,RR:1}, tcsGain:1, log:[], u:{thr:0,brk:0,steer:0,thrTar:0,brkTar:0,steerTar:0}, ref:{id:0,iq:0,tqf:0}});
      [cSpeed,cSlip,cMod,cDQ,cTorque].forEach(ch=>{ ch.data.datasets.forEach(ds=>ds.data=[]); ch.update(); });
      car.position.set(0,0,0); car.rotation.set(0,0,0); drawPhasor(0,0, +els.Vdc.value||400);
    });
    $('btnCsv').addEventListener('click',()=>{ if(!state.log.length) return;
      const rows=[["t(s)","speed(km/h)","id(A)","iq(A)","vd(V)","vq(V)","|V|(V)","m","torque(Nm)","E_bemf(V)"],
        ...state.log.map(d=>[d.t.toFixed(4),d.kmh.toFixed(3),d.id.toFixed(3),d.iq.toFixed(3),d.vd.toFixed(3),d.vq.toFixed(3),d.V.toFixed(3),d.m.toFixed(5),d.tq.toFixed(3),d.eb.toFixed(3)])];
      const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='ipmsm_7dof_abs_tcs_regen_compact.csv'; a.click(); URL.revokeObjectURL(url);
    });
    $('btnFollow').addEventListener('click',()=>{ state.follow=!state.follow; $('btnFollow').textContent = state.follow?'🎥 Follow: ON':'🎥 Follow: OFF'; });
    $('btnDisturb').addEventListener('click',()=>{ /* hook */ });
    $('btnStep80').addEventListener('click',()=>{ els.mode.value='cruise'; setModeVis(); els.targetKmh.value=80; });

    // init phasor
    drawPhasor(0,0,+els.Vdc.value||400);
  </script>
</body>
</html>
